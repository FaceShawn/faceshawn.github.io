---
title: 排序算法总结
categories:
  - 总结
tags:
location:
  - 图书馆
abbrlink: 'cd65786b'
permalink: 'cd65786b'
date: 2019-05-08 13:28:19
updated: 2019-05-08 13:28:19
---

## 摘要

>排序算法总结和比较。
>

<!-- more -->

## 0. 内置排序函数

```
// STL<algorithm> 
sort(array);

// js 合并为一个？
function cmp(a, b){return a-b};
arr.sort(cmp);
```

## 1. 插入排序

###  ~~1.1 直接插入~~

- 基本思想：从后往前查找待插入位置，比待插入元素大的**逐个后移** 哨兵
- 最易理解
- 性能：
  - n（有序）	n^2^ 	n^2^（逆序）
  - O(1)
  - 稳定：一趟排序后，元素放到最终位置

### ==1.2 折半插入==

- 二分查找，**统一后移**，移动次数不变

- 性能：

  - n^2^ 
  - O(1)
  - 稳定

### 1.3 希尔排序

- 间隔步长倍数位置分为一组，组内直接插入排序；步长d[i]：n/2 -> 1（步长为1的希尔排序即直接插入排序）
- 缩小增量
## 2. 交换排序

### ==2.1 冒泡排序==

- 基本思想：从后往前，两两排序（逆序则交换）作为一趟冒泡。
- flag 作为一趟冒泡是否发生交换的标志
- 性能：
  - n	n^2^	n^2^
  - O(1)
  - 稳定：一趟冒泡后，元素放到最终位置
### ==2.2 快速排序== 
- 基本思想：划分（分治法），对左右两部分**递归**快速排序
- 平均性能最优 划分最平衡 平均情况最接近最坏情况
- 性能：
  - n^2^ 	nlgn 	n^2^ （划分不对称）
  - 递归工作栈：lgn 	n	lgn
  - 一趟排序后，元素放在最终位置
  - 提高：
    1. 子序列规模较小时用直接插入
    2. 划分尽量对称

## 3. 选择排序

### ==3.1 简单选择排序== 
- 基本思想：一趟排序查找最小（最合适）的元素
- 代码最简单
- 性能：
  - n^2^
  - O(1)
```c++
// 3.1 简单选择排序
// 传向量地址
void selectSort(vector<int> &vt)
{
    // n-1 趟
    for(int i=0; i<vt.size()-1; ++i)
    {
        int  mini=i;
        // 下一个位置开始
        for(int j=i+1; j<vt.size(); ++j)
        {
            // 由小到大
            if(vt[j] < vt[mini])
                mini = j;
        }
        // 最小值为当前元素时不移动
        // 算法笔记说这样提高的效率并不高，可省略
        if(mini != i)
            swap(vt[mini], vt[i]);
    }
}
```



### 3.2 堆排序

- 大根堆：
  1. 完全二叉树；
  2. 任意结点 >= 其子结点和右兄弟结点；
- 基本思想：
  - **建堆**：对以 len/2 为根的子树**调整堆**， len/2 -> 1（向前遍历）；
  - **向下调整堆**（使该子树成为堆）：看子树的根结点是否 >= 左右子结点中的较大值，否则与之交换；交换后可能破坏下一级堆的结构，用**循环**反复比较交换子树结点，直到以该结点为根的子树成为堆为止；
  -  **排序**：初始**建堆**，从堆底开始，循环**弹出堆顶**和**调整堆**，直至剩下一个元素为止。
  - **弹出（删除）堆顶**：输出堆顶元素，堆顶和堆底交换；
  - **插入堆顶**：放在堆底，**向上调整**；
- 性能：
  - nlgn
  - O(1)

## 4. （2-路）归并排序

- 基本思想：将序列看作长度为1的n个有序表，两两归并，直到合并成1个长度为n的有序表。
- A 的左右两段分别有序，双指针，辅助数组B=A
- 性能：
  - nlgn
  - O(n)
  - 稳定

## 5. 基数排序

- 基本思想：统一正整数长度，从最低位开始，对每一位数字排序。
- 多关键字排序 
- 稳定