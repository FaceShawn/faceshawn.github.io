<blockquote>
  <p>摘要：数据结构中，线性结构有数组、字符串、链表、栈和队列、哈希表，非线性结构有堆、树、二叉树、图。手撕算法多为框架，包括常用技巧、十大排序算法、二分查找、分治与递归、动态规划、BFS 框架、DFS框架与回溯、贪心、缓存淘汰算法。基本涵盖<a href="https://github.com/labuladong/fucking-algorithm">labuladong 的算法小抄</a>、<a href="https://codetop.cc/">CodeTop</a>频度前40、<a href="https://leetcode.cn/problem-list/xb9nqhhg/">剑指 Offer（第 2 版）</a>、<a href="https://leetcode.cn/problemset/all/?listId=2cktkvj&amp;page=1&amp;sorting=W3sic29ydE9yZGVyIjoiREVTQ0VORElORyIsIm9yZGVyQnkiOiJTT0xVVElPTl9OVU0ifV0%3D">LeetCode 热题 HOT 100</a>常见例题。</p>
</blockquote>

<!-- more -->

<hr />

<h2 id="数据结构">数据结构</h2>

<blockquote>
  <p>由 Java 数组、String 类和 Java 集合框架实现。</p>

  <p>线性数据结构：数组（字符串）、链表、栈和队列、哈希表；</p>

  <p>非线性结构有堆、树、二叉树、图。</p>
</blockquote>

<h3 id="数组">数组</h3>

<p>顺序表，支持随机访问。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int[] arr = new int[5]; // 声明 + 动态初始化，程序员指定数组长度，由系统初始化每个元素的默认值，此处 int 默认值为0
int[] num = new int[]{1, 2, 3, 5, 8};  // 一般不用
int[] num = {1,2,3,5,8}; // 声明 + 静态初始化，程序员显式指定每个元素的值，由系统决定数组长度

int n = nums.length; // 数组的属性
int n = str.length(); // String 对象的方法

List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
int n = list.size(); // 泛型集合的方法，Vector、List等

// 与index无关的可用for-each
for(char ch : str) {}

// 交换函数，交换数组中两下标位置的元素，必须通过引用来交换，不能直接进行交换
public static void swap(int[] a, int i, int j) {
	int t = a[i];
	a[i] = a[j];
	a[j] = t;
}
public static void main(String[] args) {
    int[] a = { 1, 2, 3, 4, 5 };
    swap(a, 0, 3); // 传入数组的引用，交换下标 0 和 3 位置的数据
    System.out.println(a); // 打印数组的地址，I@1b6d3586
    System.out.println(Arrays.toString(a)); // 打印数组所有元素的真正方法，[4, 2, 3, 1, 5]
}

public static void swap(T[] arr, int i, int j) {
    // Need to add null check and index checks
    List list = Arrays.asList(arr);
    Collections.swap(list, i, j);
    arr = (T[]) list.toArray();
}
</code></pre></div></div>

<h5 id="nsum">nSum</h5>

<p>nSum：取出数组中 n 个数， 相加之和为 target。</p>

<ul>
  <li><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和 无序数组</a>：用 <code class="highlighter-rouge">HashMap&lt;nums[i], i&gt;</code>。注意<code class="highlighter-rouge">return new int[]{i, j}; return new int[0];</code>；也可用 <code class="highlighter-rouge">HashMap&lt;target - nums[i], i&gt;</code>。</li>
</ul>

<p><img src="assets/mol6g.gif" alt="img" style="zoom:43%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 有序数组</a>：两数之和为 <code class="highlighter-rouge">target</code> 的所有元素对，结果不能出现重复。思路就是<strong>排序 + 双指针</strong>，<code class="highlighter-rouge">sum = nums[lo] + nums[hi], 若sum &gt; target 则hi--, 若sum &lt; target 则lo++</code>；注意跳过重复元素对。</li>
</ul>

<p><img src="assets/two_sum_all_result.jpg" alt="img" style="zoom: 25%;" /><img src="assets/59rnm.gif" alt="img" style="zoom:44%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a>：<strong>nSum框架 = 递归 + 2Sum</strong>，<code class="highlighter-rouge">List&lt;List&lt;Integer&gt; &gt; nSubSum = nSum(nums, n-1, i+1, target-nums[i]);</code> 表示从 <code class="highlighter-rouge">i+1</code> 位置开始求 <code class="highlighter-rouge">(n-1)Sum</code>，加上 <code class="highlighter-rouge">nums[i]</code> 即为 <code class="highlighter-rouge">nSum</code> 的结果。</li>
</ul>

<h5 id="前缀和">前缀和</h5>

<p>前缀和技巧：<code class="highlighter-rouge">preSum[i] = sum(nums[0, ..., i-1])</code>，表示前 <code class="highlighter-rouge">i-1</code> 项的累加和。</p>

<p>主要适用场景是：不修改原始数组的情况下，<strong>频繁查询</strong>某区间的累加和。时间复杂度降为 <code class="highlighter-rouge">O(1)</code>。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private int[] preSums;

preSums = new int[n + 1];
this.preSums[0] = 0; // 默认为0，可不显式设置
// 构造前缀和
for (int i = 1; i &lt;= n; i++) { // i = 1
	// 表示[0, i-1]位置的累加和
	preSums[i] = preSums[i-1] + nums[i-1];
}
</code></pre></div></div>

<ul>
  <li><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. sumRange 区域和 - 数组不可变</a>：对 <code class="highlighter-rouge">nums[left, ..., right]</code> 求和，即 <code class="highlighter-rouge">preSums[left+1, ..., right+1]</code>，通过 <code class="highlighter-rouge">preSums[right+1] - preSums[left]</code>。</li>
</ul>

<p><img src="assets/pre_sum.jpg" alt="img" style="zoom: 30%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和 - 矩阵不可变</a>：<code class="highlighter-rouge">preSum[0][0] = 0;</code> <code class="highlighter-rouge">preSum[i+1][j+1]</code> 记录 <code class="highlighter-rouge">matrix</code> 中的子矩阵<code class="highlighter-rouge"> [1, 1, i, j]</code> 的元素累加和，<code class="highlighter-rouge">i, j &gt; 0</code>。</li>
</ul>

<p><img src="assets/pre_sum_matrix.jpg" alt="img" style="zoom:25%;" /></p>

<ul>
  <li><a href="#5.1 计数排序">5.1 计数排序</a></li>
</ul>

<h5 id="差分数组">差分数组</h5>

<p><a href="https://labuladong.github.io/algo/2/18/23/">差分数组</a>主要适用场景是：频繁对原始数组某区间的元素值进行增减。</p>

<p><code class="highlighter-rouge">diff</code> 数组：<code class="highlighter-rouge">diff[0] = nums[0]</code>，<code class="highlighter-rouge">diff[i] = nums[i] - nums[i-1]</code>，表示相邻元素间的差值。</p>

<ul>
  <li>恢复到原数组：<code class="highlighter-rouge">nums[i] = nums[i-1] + diff[i]</code>。</li>
  <li>对区间 <code class="highlighter-rouge">nums[i..j]</code> 的元素全部加 3，只需让 <code class="highlighter-rouge">diff[i] += 3</code>，再让 <code class="highlighter-rouge">diff[j+1] -= 3</code> 即可。</li>
</ul>

<p><img src="assets/diff_array.jpg" alt="img" style="zoom: 25%;" /></p>

<h5 id="有序数组">有序数组</h5>

<blockquote>
  <p>见<a href="#二分查找">二分查找</a></p>
</blockquote>

<h5 id="二维数组的花式遍历">二维数组的花式遍历</h5>

<ul>
  <li><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维递增数组中二分查找</a>：从左下角开始遍历，比 <code class="highlighter-rouge">target</code> 大则向上 <code class="highlighter-rouge">row--</code>，小则向右 <code class="highlighter-rouge">col++</code>；用二分查找效率低。类似二叉查找树。</li>
  <li><a href="https://leetcode.cn/problems/spiral-matrix/">54. 矩阵的螺旋遍历</a>【】、<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a>：收缩四个边界【】
    <ul>
      <li><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 生成螺旋矩阵 II</a>【】</li>
    </ul>
  </li>
  <li><a href="https://leetcode.cn/problems/rotate-image/">48. 顺时针旋转 90 度图像</a>：沿对角线反转矩阵，再反转每一行。【】</li>
</ul>

<h4 id="双指针">双指针</h4>

<h5 id="头尾对向双指针">头尾对向双指针</h5>

<blockquote>
  <p>前后相向双指针</p>
</blockquote>

<ul>
  <li>见 <a href="#nSum">nSum</a></li>
  <li>见 <a href="#回文串">判断全串是否回文</a></li>
  <li><a href="https://leetcode.cn/problems/reverse-string/">344. 原地反转字符数组 O(1) 额外空间</a>：数组，双指针【】</li>
</ul>

<p><img src="assets/towards_double_pointer.gif" alt="344.反转字符串" style="zoom: 44%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">剑指 Offer 21. 调整数组顺序使奇数位于前半部分</a>：<code class="highlighter-rouge">while(i &lt; j)</code>；</li>
</ul>

<h5 id="背向双指针">背向双指针</h5>

<ul>
  <li>基本上都是回文串，见 <a href="#回文串">获取最长回文子串内容</a></li>
</ul>

<h5 id="同向双指针">同向双指针</h5>

<ul>
  <li><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a>：拉链法，将双指针初始化在数组的尾部，从后向前进行合并，可避免占用多余空间；合并到 a1 中，开始时 a1 的长度即为 <code class="highlighter-rouge">m + n</code>。用于<a href="#4. （2-路）归并排序">归并排序</a>。</li>
</ul>

<h5 id="快慢双指针">快慢双指针</h5>

<ul>
  <li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. <strong>原地</strong>删除有序数组中的重复项</a>：
    <ol>
      <li><del>快慢指针指向的元素值相等时，就后移快指针；</del></li>
      <li><code class="highlighter-rouge">fast = 1;</code> 快指针与慢指针值不同时，将快指针的值附到慢指针后 <code class="highlighter-rouge">nums[++slow] = nums[fast]</code>（与第一种方法思想不同，实现代码类似）。<code class="highlighter-rouge">slow</code> 指向结果数组的最后一项，<code class="highlighter-rouge">fast</code> 指向（后续数组中）不重复的第一项，故要先 <code class="highlighter-rouge">++slow</code> 。</li>
    </ol>
  </li>
</ul>

<p><img src="assets/slow_fast_pointer.png" alt="图片" style="zoom: 40%;" /></p>

<ul>
  <li>
    <p><a href="https://leetcode.cn/problems/remove-element/">27. <strong>原地</strong>移除元素</a>：不需单调数组，快指针不为某值时覆盖慢指针。<code class="highlighter-rouge">fast = 0; nums[slow++] = nums[fast];</code></p>

    <ul>
      <li><a href="https://leetcode.cn/problems/move-zeroes/">283. <strong>原地</strong>移动零</a>：复用 [27. 移除元素] 的解法移除所有 0 <code class="highlighter-rouge">int p = removeElement(nums, 0)</code>，返回 <code class="highlighter-rouge">p</code> 为移除 0 之后的数组长度；把 p 及其后元素都置为 0，即相当于移动所有 0 到最后。【】</li>
    </ul>

    <p><img src="assets/0eeix.gif" alt="img" style="zoom:80%;" /></p>
  </li>
</ul>

<h4 id="经典例题">经典例题</h4>

<ul>
  <li><a href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a>：二维 List，输入上一层的元素，生成并返回下一层的元素【】</li>
</ul>

<p><img src="assets/ehk16.gif" alt="img" style="zoom:53%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a>：<code class="highlighter-rouge">insert</code> set 容器 <code class="highlighter-rouge">record</code> 存储 <code class="highlighter-rouge">a1</code> 的元素，遍历 <code class="highlighter-rouge">a2</code> <code class="highlighter-rouge">find</code> 查找是否有相同的元素，如果有，set 容器 <code class="highlighter-rouge">resultSet</code> 进行存储，用 <code class="highlighter-rouge">iterator</code> 将 resultSet 转换为 vector 类型。【】</li>
</ul>

<p><img src="assets/xfx1k.gif" alt="img" style="zoom:43%;" /></p>

<h3 id="字符串">字符串</h3>

<blockquote>
  <p>Java 对字符串的处理较麻烦，见常见类 String 类的常用方法。</p>
</blockquote>

<h5 id="回文串">回文串</h5>

<ul>
  <li>数组等能找到前驱的：
    <ol>
      <li><strong>判断</strong>全串是否回文 ==&gt; 可用头尾（对向）双指针向中点遍历；
        <ul>
          <li><a href="https://leetcode.cn/problems/palindrome-number/">9. 回文数</a>：转为字符串，头尾指针同步相向而行，可用一个指针 <code class="highlighter-rouge">i 和 n-i-1</code> 代替；</li>
          <li><a href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a>：头尾双指针相向而行，忽略字母大小写，用 while 忽略空格、标点；</li>
        </ul>
      </li>
      <li><strong>获取</strong>最长回文<strong>子串</strong>内容：<a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a>
        <ol>
          <li>遍历字符串，获取以 <code class="highlighter-rouge">[i, i]</code>、<code class="highlighter-rouge">[i, i+1]</code> 为回文中点的子串；</li>
          <li>传入回文中点 <code class="highlighter-rouge">l</code> 和 <code class="highlighter-rouge">r</code> ，向两侧（背向双指针）扩散（遍历判断），<code class="highlighter-rouge">l == r</code> 时回文子串长度为奇数。</li>
        </ol>
      </li>
      <li><del>根据字符数组构造回文串；</del></li>
      <li>最长回文子序列：<a href="#子序列">动态规划</a>
        <ul>
          <li>子串：是字符串中连续的一个序列；</li>
          <li>子序列：是字符串中保持相对位置（删除某些字符）的字符序列；</li>
          <li>如，<code class="highlighter-rouge">"bbbb"</code>是字符串<code class="highlighter-rouge">"bbbgb"</code>的子序列但不是子串。</li>
        </ul>
      </li>
    </ol>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 1. 判断
  
// 2. 获取以 s[lo, hi] 为中心的最长回文串，也可用于判断
String palindrome(String s, int lo, int hi) {
    // 防止索引越界
    while (lo &gt;= 0 &amp;&amp; hi &lt; s.length() &amp;&amp; s.charAt(lo) == s.charAt(hi)) {
        lo--; // 背向双指针，由中心向两端扩散
        hi++;
    }
    // 返回以 s[初始lo，初始hi] 为中心的、最长回文串[lo+1, hi)
    // lo == hi 时，回文串长度为奇数
    return s.substring(lo + 1, hi);
}
</code></pre></div>    </div>
  </li>
  <li>
    <p>链表：</p>

    <ul>
      <li><strong>判断</strong>全串是否<strong>回文</strong>：<a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 判断回文链表</a> 对称链表，<strong>==经典例题==</strong>；
        <ol>
          <li>快慢双指针找前半部分链表的尾节点（<strong>链表中点</strong>，奇数找中点前一个节点，偶数找前一个中点）；</li>
          <li>（封装函数）（头插法）<strong>反转</strong>后半部分链表；</li>
          <li>遍历短链表（即第二个），比较同向双指针，空间复杂度<code class="highlighter-rouge">O(1)</code>。</li>
          <li><strong>反转还原</strong>后半部分链表并返回结果。</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h5 id="滑动窗口">滑动窗口</h5>

<p>左右指针技巧中，把索引<strong>左闭右开</strong>的区间 <code class="highlighter-rouge">[left, right)</code> 称为一个「窗口」，长度为 <code class="highlighter-rouge">right - left</code>。方便边界处理， <code class="highlighter-rouge">[0, 0)</code>中没有元素，<code class="highlighter-rouge">[0, 1)</code>中有一个元素 0。</p>

<p>滑动窗口：保证每个窗口里字母都是唯一的。双指针的一种，大多与不重复字符有关。</p>

<p><strong>核心思想</strong>：维护一个左闭右开的窗口，不断滑动，左右指针交替前进（ <strong>不回头</strong> ），更新答案。</p>

<ul>
  <li>虽然有嵌套的 while 循环，但时间复杂度依然是 <code class="highlighter-rouge">O(n)</code>，因为每个元素都只会进入和被移出窗口一次。</li>
</ul>

<p>滑动窗口4类经典例题：</p>

<ol>
  <li>
    <p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>：当 window 内出现重复字符（HashMap 中已有当前字符）时，则调整左边界 <code class="highlighter-rouge">left = Math.max(window.get(ch) + 1, left)</code>（val 为字符对应的窗口结束位置）；调整（右移并更新） <code class="highlighter-rouge">right</code> 边界，更新子串及其长度；<code class="highlighter-rouge">O(N)</code></p>

    <ul>
      <li>
        <p><a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a>：也可用<strong>动态规划</strong>，但为<code class="highlighter-rouge">N^2</code>。<code class="highlighter-rouge">subDp[i]</code> 表示 <code class="highlighter-rouge">[0, i]</code> 区间内最长不含重复字符的子串，<code class="highlighter-rouge">subDp[i] = Math.max(subDp[i-1], longestSub)</code>，从 i 不断向前遍历可得到 <code class="highlighter-rouge">longestSub</code> = <code class="highlighter-rouge">(j, i]</code>，表示以 i 索引位置结尾的不含重复字符的最长子串。</p>

        <p><img src="assets/slide_window.png" alt="图片.png" style="zoom:52%;" /><img src="assets/longest_substr_without_repeat_char.gif" alt="longest_substr_without_repeat_char" style="zoom:50%;" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a>：包含<code class="highlighter-rouge">Target</code>所有字符的、当前字符串<code class="highlighter-rouge">Source</code>的最短子串；</p>

    <ul>
      <li>
        <p>步骤：</p>

        <ol>
          <li>need 和 window 相当于计数器，分别记录 T 中（需凑齐的）字符数量和窗口中对应字符的出现次数；</li>
          <li>寻找可行解：先不断地增加 <code class="highlighter-rouge">right</code> 指针扩大窗口 <code class="highlighter-rouge">[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code class="highlighter-rouge">T</code> 中所有字符）；</li>
        </ol>

        <p><img src="assets/min_cover_substr1.png" alt="img" style="zoom:25%;" /><img src="assets/min_cover_substr2.png" alt="img" style="zoom:25%;" /></p>

        <ol>
          <li>优化可行解：再不断右移 <code class="highlighter-rouge">left</code> 指针缩小窗口，更新窗口的起始索引及长度，直到窗口不再符合要求（不包含 <code class="highlighter-rouge">T</code> 中所有字符）。</li>
        </ol>

        <p><img src="assets/min_cover_substr3.png" alt="img" style="zoom:25%;" /><img src="assets/min_cover_substr4.png" alt="img" style="zoom:25%;" /></p>

        <ul>
          <li>
            <p><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a>【】</p>
          </li>
          <li>
            <p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a>【】</p>
          </li>
          <li>
            <p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>【】
<img src="assets/0ga4f.gif" alt="img" style="zoom:48%;" /></p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a>【】</p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口中的最大值</a>【】</p>
  </li>
</ol>

<p><img src="assets/gjz5m.gif" alt="img" style="zoom:35%;" /><img src="assets/20whr.gif" alt="img" style="zoom:33%;" /></p>

<p><strong>滑动窗口框架</strong>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    // 字符最后一次出现的位置，用map记下每个字符的索引，直接进行跳转
    Map&lt;Character, Integer&gt; window = new HashMap&lt;&gt;();
    // needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中对应字符的出现次数。
    Map&lt;Character, Integer&gt; need = new HashMap&lt;&gt;();
    for (char key : t.toCharArray) { // need.keySet()) {
    	// 不存在则初始化为0，存在则+1
  		need.put(key, map.getOrDefault(key, 0) + 1);
    }
    
    // 表示窗口中满足need条件（包含的T中字符）的个数，valid == need.size 说明窗口已完全覆盖了 T
    int valid = 0;
    for (int left = 0, right = 0; right &lt; n; right++) { // 大多数解法用while，不理解
        // 准备移入窗口的字符
        char inCh = s.charAt(right);
        // 扩大窗口的更新操作
        ...
        // debug 输出窗口的区间位置
        // System.out.printf("[" + left + ", " + right + ")");
        
        // 判断左侧窗口是否要收缩
        while (window 仍满足条件) {
            // 判断是否完全覆盖子串
            // 准备移出窗口的字符
            char outCh = s.charAt(left);
            // 缩小窗口，并更新操作，与扩大对称
            left++;
            ...
        }
    }
}
</code></pre></div></div>

<h5 id="经典例题-1">经典例题</h5>

<ul>
  <li>String 类的常用方法：见 String 类；</li>
  <li>
    <p>统计字符串中每个字符出现的频率：</p>

    <ul>
      <li>出现次数最多字符</li>
    </ul>
  </li>
  <li><a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">剑指 Offer 50. 第一个未重复的字符</a>
    <ol>
      <li>字符串运算：将所有重复的字符替换为 <code class="highlighter-rouge">""</code>；</li>
      <li><del>哈希表</del>；</li>
    </ol>
  </li>
  <li><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a>：常规方法为遍历 <code class="highlighter-rouge">charAt(i)</code>；</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StringBuffer res = new StringBuffer();
return res.toString();

// 将char转为String，并比较
String.valueOf(ch).equals(" ")

str.replaceAll("\\s", "%20"); // 模式匹配
str.replace(" "， "%20");
</code></pre></div></div>

<ul>
  <li>
    <p>简化复杂 url</p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/longest-common-prefix/">14. 字符串数组的最长公共前缀</a>：先用 <code class="highlighter-rouge">Arrays.sort(strs)</code> 为字符串数组升序排序，再从前往后遍历、对比第一个和最后一个字符串的字符。</p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a>：<a href="#链表双指针">链表位运算 两数逐位相加</a>【】</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a>【】</li>
    </ul>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>StringBuffer ans = new StringBuffer();
while (i &gt;= 0 || j &gt;= 0 || add != 0) {
	int x = (i &gt;= 0) ? num1.charAt(i) - '0' : 0;
}
// 答案需翻转
ans.reverse();
</code></pre></div>    </div>
  </li>
  <li><a href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a>
    <ol>
      <li>常规方式：将字符串 <code class="highlighter-rouge">s</code> 按空格 <code class="highlighter-rouge">split</code> 成若干单词，然后 <code class="highlighter-rouge">reverse</code> ，把单词 <code class="highlighter-rouge">join</code> 成句子。用了额外的空间。</li>
      <li>原地翻转：将字符串 <code class="highlighter-rouge">s</code> 反转，然后将每个单词分别反转再 <code class="highlighter-rouge">join()</code>；</li>
      <li>用<strong>正则匹配</strong>分割单词，放入String数组，反转数组再 <code class="highlighter-rouge">join()</code>。</li>
    </ol>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a>：字符串前 n 位原地移动到尾部；</p>

    <ol>
      <li>切片函数 + 拼接；</li>
      <li><code class="highlighter-rouge">StringBuilder()</code>，用 i 遍历 <code class="highlighter-rouge">[n, len + n]</code> ，取余 <code class="highlighter-rouge">i % len</code>。</li>
    </ol>
  </li>
</ul>

<h5 id="kmp-字符串模式匹配算法">KMP 字符串<del>模式</del>匹配算法</h5>

<p>“暴力搜索”会反复回溯主串，导致效率低下，而 KMP 算法可利用已遍历部分匹配这个有效信息（部分匹配表），保持主串上的指针不回溯；通过修改子串的指针，让模式串尽量移动到有效的位置。</p>

<ul>
  <li>应用了贪心算法。用来解决字符串查找的问题，可在字符串（S）中查找子串（W）、模式串（P）出现的位置。</li>
  <li>把字符匹配的时间复杂度缩小到 <code class="highlighter-rouge">O(m + n)</code> ，空间复杂度也只有 <code class="highlighter-rouge">O(m)</code>。</li>
</ul>

<p><img src="assets/bg2013050105.png" alt="img" style="zoom:50%;" /></p>

<p>根据<strong>部分匹配表</strong>（<code class="highlighter-rouge">next</code> 数组），最后一个匹配字符B（在已匹配的字符串中）对应的”部分匹配值”为2。移动位数 = 已匹配的字符数 - 对应的部分匹配值。</p>

<ul>
  <li>前缀：指除了最后一个字符外，字符串的全部连续字符组合；</li>
  <li>后缀：指除了第一个字符外，字符串的全部连续字符组合。</li>
  <li>部分匹配值：”前缀”和”后缀”的最长共有元素的长度。
    <ul>
      <li>如<code class="highlighter-rouge">"ABCDA"</code>的前缀为<code class="highlighter-rouge">[A, AB, ABC, ABCD]</code>，后缀为<code class="highlighter-rouge">[BCDA, CDA, DA, A]</code>，共有元素为<code class="highlighter-rouge">"A"</code>，长度为1；</li>
    </ul>
  </li>
  <li>“<strong>AB</strong>CD<strong>AB</strong>“中有两个<code class="highlighter-rouge">"AB"</code>，”部分匹配值”就是 2（”AB”的长度）。搜索词移动时，第一个<code class="highlighter-rouge">"AB"</code>向后移动4位（字符串长度-部分匹配值），就可来到第二个”AB”的位置。</li>
  <li><a href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法 阮一峰</a></li>
</ul>

<h3 id="链表">链表</h3>

<blockquote>
  <p>数组 VS 链表 、ArrayList VS LinkedList。</p>
</blockquote>

<h5 id="头指针-vs-头结点">头指针 VS 头结点</h5>

<p>指针：Java 语言中不存在指针，但可理解为<code class="highlighter-rouge">引用</code>。</p>

<ul>
  <li>
    <p>指针丢失：指针没有明确指向。</p>
  </li>
  <li>
    <p>内存泄漏：结点不判空就操作 <code class="highlighter-rouge">next</code> 域等，导致空指针异常。</p>
  </li>
</ul>

<p>头结点：在单链表的第一个结点前附加一个结点，称为头结点。头结点的 <code class="highlighter-rouge">Data</code> 域可为空，仅包含 <code class="highlighter-rouge">next</code> 域；也可记录表长等信息。</p>

<p>头指针：指向链表的第一个节点，通常用来标识一个链表，如单链表 <code class="highlighter-rouge">L</code>。</p>

<ul>
  <li><strong>若不带头结点</strong>：
    <ul>
      <li>头指针指向第一个节点的存储位置；</li>
      <li>判空：头指针为 <code class="highlighter-rouge">null</code>（Java 区分大小写，且所有关键字都是小写）时表示一个空链表。</li>
    </ul>
  </li>
  <li>若带头结点：
    <ul>
      <li>头指针指向头结点的存储位置；</li>
      <li>判空：头结点的 <code class="highlighter-rouge">next</code> 域为 <code class="highlighter-rouge">null</code> 时为空链表。</li>
    </ul>
  </li>
</ul>

<p>优点：统一头/非头节点、空/非空链表的操作。</p>

<ul>
  <li>第1个节点位置的插入、删除与其他位置的操作保持一致。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> // 通常在链表头部加入哨兵(作为头结点)，使删除的代码保持一致，不用额外考虑删除第一个节点的情况
 // 虚拟头结点技巧，插入 dummy 哑节点，用dummy.next表示真正的头节点，可避免处理头节点为null的边界问题
 ListNode dummy = new ListNode(-1);
 dummy.next = head;
 ....
 return dummy.next;
</code></pre></div></div>

<p><strong>判断边界 / 特殊情况</strong></p>

<ul>
  <li>链表为空时，判空；</li>
  <li>链表只包含一个、两个结点时；</li>
  <li>在处理头结点和尾结点时。</li>
</ul>

<h5 id="链表快慢双指针">链表快慢双指针</h5>

<p>单链表大部分都适用快慢指针技巧。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 快慢指针初始化指向 head
ListNode slow = head, fast = head;
</code></pre></div></div>

<ol>
  <li>
    <p><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 查找倒数第k个节点</a>：即正数第 <code class="highlighter-rouge">n - k + 1</code> 个结点，但 <code class="highlighter-rouge">n</code> 无法直接得到（计算链表的 length、栈），可用快慢双指针；注意 <code class="highlighter-rouge">k &gt; n</code> 时应返回 <code class="highlighter-rouge">null</code>。</p>

    <ul>
      <li>虚拟头结点技巧：为了防止空指针，如链表共有 5 个节点，删除倒数第 5 个（即正数第一个）节点，需先找到倒数第 6 个节点，但第一个节点前已没有节点。</li>
      <li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除倒数第 K 个结点</a> ：调用查找函数，获取倒数第 <code class="highlighter-rouge">k + 1</code> 个结点的引用，删除后继结点；</li>
    </ul>

    <p><img src="assets/remove_kth_node_from_end.gif" alt="remove_kth_node_from_end" style="zoom:33%;" /></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 删除倒数第 k 个，要先找倒数第 k + 1 个节点
ListNode pre = findKthFromEnd(dummy, k + 1);
</code></pre></div>    </div>

    <ul>
      <li><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a>：慢指针走一步，快指针走两步。<code class="highlighter-rouge">while (fast != null &amp;&amp; fast.next != null)</code>。偶数返回第一个节点。
        <ul>
          <li><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a>：找<strong>链表中点</strong>，<strong>合并</strong>原链表的左半端和<strong>反转</strong>后的右半端【】</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>==判断回文链表==</strong>：见字符串中的<a href="#回文串">回文串</a>；</p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 检测链表中是否有环</a>：<code class="highlighter-rouge">slow</code> 和 <code class="highlighter-rouge">fast</code> 指针相遇即有环；【】</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II 找环起点</a>： 遍历 <code class="highlighter-rouge">fast</code> 直到链表尾部，<code class="highlighter-rouge">fast、slow</code>  相遇即跳出循环；无环则 <code class="highlighter-rouge">fast、slow</code> 将相继到达链表尾部，相遇时均为 <code class="highlighter-rouge">null</code>；有环则 <code class="highlighter-rouge">fast</code> 指针在环内， <code class="highlighter-rouge">fast、slow</code> 第二次相遇即为环起点；环起点不一定在 <code class="highlighter-rouge">head</code>；</li>
    </ul>

    <p><img src="assets/find_loop.jpeg" alt="img" style="zoom:25%;" /></p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a>：判断两单链表是否相交；【】</p>

    <ul>
      <li>
        <p><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">剑指 Offer 52. 两链表的第一个公共节点</a>：找出交点（第一个公共结点）；</p>
      </li>
      <li>
        <p>方法一：用 <code class="highlighter-rouge">HashSet</code> 记录一个链表的所有节点，和另一条链表对比，缺点是需额外空间；</p>
      </li>
      <li>
        <p><strong>方法二</strong>：让 <code class="highlighter-rouge">pa</code> 遍历完链表 <code class="highlighter-rouge">A</code> 后开始遍历链表 <code class="highlighter-rouge">B</code>，…，在逻辑上拼接两条链表， <code class="highlighter-rouge">pa</code> 和 <code class="highlighter-rouge">pb</code> 能同时到达相交节点 <code class="highlighter-rouge">c</code>。空间复杂度 <code class="highlighter-rouge">O(1)</code>。</p>
      </li>
      <li>
        <p>方法三：两条链表首尾相连，问题转换成了「寻找环起点」。</p>
      </li>
      <li>
        <p>方法四（常规思路）：预先计算两条链表的长度，较长的链表 <code class="highlighter-rouge">fast</code> 指针先走，使 <code class="highlighter-rouge">p1</code> 和 <code class="highlighter-rouge">p2</code> 到达尾部的距离相同，<code class="highlighter-rouge">p1 == p2</code> 且不为空时即相交。</p>

        <p><img src="assets/merge_two_linklist.jpeg" alt="img" style="zoom:25%;" /><img src="assets/find_loop_tail.png" alt="img" style="zoom:25%;" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>循环左移</p>
  </li>
</ol>

<h5 id="链表双指针">链表双指针</h5>

<ul>
  <li>
    <p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a>：拉链法 / 归并法 <a href="#4. （2-路）归并排序">（2-路）归并排序</a></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 虚拟头结点
ListNode dummy = new ListNode(-1);
// 合并后l1、l2最多只有一个非空，直接将链表末尾指向未合并完的链表
p.next = (l1 == null) ? l2 : l1;
</code></pre></div>    </div>

    <ul>
      <li>
        <ol>
          <li>合并K个升序链表：<a href="#第K个元素">第K个元素</a></li>
        </ol>
      </li>
    </ul>
  </li>
  <li>
    <p>链表位运算</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/add-two-numbers/">2. 逆序链表按位表示整数 两数逐位相加 链表求和</a>：carry 表示进位；</li>
    </ul>

    <p><img src="assets/add_two_number.gif" alt="add_two_number" style="zoom: 40%;" /></p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/odd-even-linked-list/">328. 分离奇偶节点为两个链表再组装为一个</a>：<code class="highlighter-rouge">odd、even</code> 奇偶双指针交替前进；<code class="highlighter-rouge">even.next</code> 不能为空；<code class="highlighter-rouge">odd.next = evenhead</code>；</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a>【】</li>
    </ul>
  </li>
</ul>

<p><img src="assets/xh0aj.gif" alt="img" style="zoom:34%;" /><img src="assets/t96zg.gif" alt="img" style="zoom:38%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/sort-list/">148. 链表插入排序</a>：【】</li>
  <li><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水总数</a>：【】</li>
</ul>

<p><img src="assets/rain_water.jpg" alt="img" style="zoom:25%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>water[i] = min(
           # 左边最高的柱子
           max(height[0...i]),
           # 右边最高的柱子
           max(height[i...end])
        ) - height[i]
</code></pre></div></div>

<h5 id="经典例题-2">经典例题</h5>

<ul>
  <li>
    <p><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p>

    <ol>
      <li>
        <p><strong>头插法</strong>：不申请额外空间，就地反转，空间复杂度 <code class="highlighter-rouge">O(1)</code>；</p>
      </li>
      <li>
        <p>反转 =&gt; 栈：<a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a>；</p>
      </li>
      <li>
        <p>递归：</p>

        <ul>
          <li><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II 指定区间</a>：【】
            <ol>
              <li>迭代解法很简单，用一个 for 循环反转链表区间即可；</li>
              <li>常用来考察<strong>纯递归</strong>的形式。</li>
            </ol>
          </li>
          <li>
            <p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>：<code class="highlighter-rouge">reverseKNode</code> <strong>原地反转</strong> <code class="highlighter-rouge">[head, tail)</code> 区间的元素；</p>

            <ul>
              <li><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>：相当于 <code class="highlighter-rouge">K = 2</code> 的特殊情况，可用简化的多指针；【】</li>
            </ul>

            <p><img src="assets/20181103160226.gif" alt="img" style="zoom:32%;" /><img src="assets/6kpyu.gif" alt="img" style="zoom:34%;" /></p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">剑指 Offer 35. 复杂链表的深拷贝 random 指针</a>：</p>

    <ol>
      <li>HashMap + 递归；</li>
      <li>第一次遍历复制并后插，第二次复制随机指针并分离链表【】；</li>
    </ol>

    <p><img src="assets/whvl5.gif" alt="img" style="zoom: 33%;" /></p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">237. 删除链表中的特定节点</a>：不给头结点，只给要被删除的节点；前后节点交换值，删后继。【】</p>
  </li>
</ul>

<p><img src="assets/1navy.gif" alt="img" style="zoom:36%;" /></p>

<ul>
  <li><del>奇数位升序，偶数位降序，要求输出全局升序，不用数组</del></li>
  <li>双向链表</li>
  <li><strong>前插</strong>：右下（指向后继）+ 顺时针
    <ul>
      <li>后插：左下 + 逆时针</li>
      <li>删前驱：</li>
    </ul>
  </li>
  <li>循环链表</li>
  <li>双向循环链表</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* 迭代遍历单链表 */
for (ListNode p = head; p != null; p = p.next) {
}

/* 递归遍历单链表 */
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    // 前序位置
    traverse(head.next);
    // 后序位置
    /* 倒序打印链表元素 */
    print(head.val);
}
</code></pre></div></div>

<h3 id="栈队列">栈、队列</h3>

<h5 id="栈">栈</h5>

<p>栈常用一维数组或链表来实现：</p>

<ul>
  <li>用数组实现的栈叫作 顺序栈，</li>
  <li>用链表实现的栈叫作 <strong>链式栈</strong> 。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();
stack.push(1);
Integer x = stack.pop();

Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
</code></pre></div></div>

<h5 id="队列">队列</h5>

<p>队头（front）出队，队尾（rear）入队；</p>

<p><img src="assets/队列.png" alt="队列" style="zoom: 67%;" /></p>

<ol>
  <li>
    <p>顺序队列（数组实现）：存在“假溢出”的问题（即明明有位置却不能添加）。因为在数组中 <code class="highlighter-rouge">front</code> 和 <code class="highlighter-rouge">rear</code> 会持续向后移动，无法返回数组起始位置，数组长度固定，导致数组越界、前端有大段空白。</p>

    <ul>
      <li>
        <p>队列空：<code class="highlighter-rouge">front == rear</code> ；</p>

        <ul>
          <li>
            <p>队列满：<code class="highlighter-rouge">rear - front == QueueSize</code>；</p>
          </li>
          <li>
            <p>循环队列：可解决假溢出和越界问题。</p>

            <ul>
              <li>
                <p>队列空：<code class="highlighter-rouge">front == rear</code> ，排除队列溢出的情况；</p>
              </li>
              <li>
                <p>队列满： <code class="highlighter-rouge">(rear + 1) % QueueSize == front</code>，即 <code class="highlighter-rouge">rear</code> 在 <code class="highlighter-rouge">front</code> 前一个位置 。</p>

                <p><img src="assets/循环队列-堆满.png" alt="循环队列-队满" style="zoom: 67%;" /></p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>链式队列（链表实现）</p>
  </li>
</ol>

<p>常用于：</p>

<ol>
  <li>阻塞队列；</li>
  <li>线程池中的请求/任务队列；</li>
  <li>Linux 内核进程队列；</li>
  <li>消息队列；</li>
</ol>

<h5 id="deque-双端队列">Deque 双端队列</h5>

<blockquote>
  <p>集合框架，用于实现栈和队列。</p>
</blockquote>

<h5 id="priorityqueue-优先队列">PriorityQueue 优先队列</h5>

<p>出队顺序按照优先级的队列；常用于找最值，往往用<a href="#堆">堆</a>来实现。用于有动态添加、删除数据且需获得最值的场景。手撕算法典型题包括：</p>

<ol>
  <li><a href="#3.2 堆排序">堆排序</a>；</li>
  <li><a href="#第K个元素">第K个元素</a>；</li>
  <li><a href="#图的搜索、遍历">带权图的遍历</a>等。</li>
</ol>

<p>至少需支持下述操作：</p>

<ol>
  <li>插入带优先级的元素（offer/insert_with_priority）；</li>
  <li>查看或取出最高优先级的元素（peek、poll/pull_highest_priority_element）；</li>
</ol>

<p>其它可选的操作：</p>

<ol>
  <li>清空优先队列；</li>
  <li>调整一个元素的优先级；</li>
  <li>批量插入元素；</li>
  <li>检查优先级高的一批元素；</li>
  <li>合并多个优先队列；</li>
</ol>

<h5 id="单调栈单调队列">单调栈、单调队列</h5>

<p>单调栈：每次新元素入栈后，栈内的元素都保持有序。用途不广，只处理一类典型的问题。</p>

<p><img src="assets/monotonous-stack-after.svg" alt="img" style="zoom: 67%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a> ：由后往前对比数组元素和栈顶，逐个弹出，插入目标元素后再逐个入栈【】</li>
</ul>

<h5 id="经典例题-3">经典例题</h5>

<ul>
  <li><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a>：如用两个栈实现浏览器的回退和前进功能。
    <ol>
      <li><code class="highlighter-rouge">queue()</code> 构造：new 新栈 <code class="highlighter-rouge">stackIn</code>（s1）和 `stackOut （s2）；</li>
      <li>队尾（rear）入队（<code class="highlighter-rouge">push/offer/add</code>）：<code class="highlighter-rouge">stackIn.push(x)</code>入栈；</li>
      <li>查看队头（peek）：如果 <code class="highlighter-rouge">stackOut</code> 为空，则<code class="highlighter-rouge">stackIn</code> 全部倒入 <code class="highlighter-rouge">stackOut</code>；栈顶 <code class="highlighter-rouge">top()</code> 即为队头；</li>
      <li>队头（front）出队（<code class="highlighter-rouge">pop/poll/remove</code>）：先调用 <code class="highlighter-rouge">peek()</code> 保证 <code class="highlighter-rouge">stackOut</code> 非空，<code class="highlighter-rouge">stackOut</code>出栈；出队结束，<code class="highlighter-rouge">stackIn</code> 为空也不必重新倒回；</li>
      <li><code class="highlighter-rouge">isEmpty()</code> 判空：<code class="highlighter-rouge">stackIn</code> 和 <code class="highlighter-rouge">stackOut</code> 均为空。</li>
    </ol>
  </li>
</ul>

<p><img src="assets/two-stack-impl-queue.jpg" alt="用两个栈实现队列" style="zoom: 18%;" /><img src="assets/231167.jpg" alt="用两个栈实现队列" style="zoom: 36%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a>：只需一个队列；
    <ol>
      <li><code class="highlighter-rouge">stack()</code>构造：<code class="highlighter-rouge">sz = 0</code>，重新塞入时用于计数；</li>
      <li><code class="highlighter-rouge">push(x)</code> 入栈：<code class="highlighter-rouge">queue.offer(x)</code>入队；或维护 <code class="highlighter-rouge">topElem = x</code> 栈顶元素，x 是队列的队尾，是栈的栈顶 <code class="highlighter-rouge">topElem</code>；</li>
      <li><code class="highlighter-rouge">pop()</code> 弹出栈顶：把队尾元素移到队头（把队尾前的所有元素出队再重新塞到队尾，顶过去），原队尾（现队头）<code class="highlighter-rouge">poll()</code>出队；或返回 <code class="highlighter-rouge">topElem</code>，更新 <code class="highlighter-rouge">topElem</code> 为新队尾元素；</li>
      <li><code class="highlighter-rouge">top()</code> 查看栈顶：调用 <code class="highlighter-rouge">pop()</code> 弹出队尾元素（栈顶元素）后恢复（把队尾元素再次塞入队尾），<code class="highlighter-rouge">sz++</code>；</li>
      <li><code class="highlighter-rouge">isEmpty()</code> 判空：<code class="highlighter-rouge">queue.isEmpty()</code>。</li>
    </ol>
  </li>
</ul>

<p><img src="assets/queue-impl-stack.jpg" alt="img" style="zoom:25%;" /></p>

<ul>
  <li>
    <p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 判断有效的成对括号</a>：<code class="highlighter-rouge">Stack</code> 保存所需的<strong>右</strong>括号 + HashMap 存左右括号对应关系方便查表，若 <code class="highlighter-rouge">ch</code> 为左括号，则将<strong>对应右括号</strong>入栈，若为右括号，则与栈顶元素对比；</p>

    <ol>
      <li><a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/">921. 使括号有效的最少添加</a>、<a href="https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/">1541. 平衡括号的最少插入次数</a>【】：计算多出的<code class="highlighter-rouge">(</code>或<code class="highlighter-rouge">)</code>，<code class="highlighter-rouge">need</code> 变量记录对右括号的需求数，<code class="highlighter-rouge">(</code> 则 <code class="highlighter-rouge">need++</code>，<code class="highlighter-rouge">)</code> 则 <code class="highlighter-rouge">need--</code>；当 <code class="highlighter-rouge">need == -1</code> 时，意味着遇到一个多余的右括号，显然需插入一个左括号。</li>
      <li><a href="https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/">1614. 计算括号的最大嵌套深度</a>：<code class="highlighter-rouge">depth++</code> 时，更新 <code class="highlighter-rouge">maxDep = Math.max(maxDep, depth)</code>；</li>
      <li><a href="https://leetcode.cn/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/">1111. 根据嵌套深度 分成两个不相交的有效括号字符串</a>：【】</li>
    </ol>

    <p><img src="assets/valid_parentheses.gif" alt="valid_parentheses" style="zoom:28%;" /><img src="assets/nesting-depth-of-parentheses.png" alt="img" style="zoom: 16%;" /></p>
  </li>
  <li>
    <p>中缀表达式-&gt;后缀：根据中序结果构造二叉树，打印后序结果；</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/">剑指 Offer 31. 根据入栈序列、推断弹出序列</a>：每次入栈后，弹出所有符合<strong>弹出序列顺序</strong>的栈顶元素；</li>
      <li><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a>：用栈计算后缀表达式；</li>
    </ul>

    <p><img src="assets/4ieg7.gif" alt="img" style="zoom:30%;" /></p>
  </li>
  <li><a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a>：【】
    <ol>
      <li><code class="highlighter-rouge">bool[] inStack</code> 布尔数组保证栈中元素不重复；</li>
      <li>栈保证字符出现的顺序；</li>
      <li>类似单调栈的思路，配合计数器 <code class="highlighter-rouge">count</code> 不断 pop 掉不符合最小字典序的字符。</li>
    </ol>
  </li>
  <li>反转字符串：还可用<a href="#背向双指针">背向双指针</a></li>
</ul>

<h3 id="哈希表">哈希表</h3>

<p>哈希表：又称散列表，通过散列函数把键映射到一个<strong>大数组</strong>里，实现快速存取数据的功能。</p>

<p>解决散列冲突的方法：</p>

<ol>
  <li>拉链法：需要链表特性，操作简单，但需额外的空间存指针；</li>
  <li>线性探查法：需要数组特性，以便连续寻址，不需指针的存储空间，但操作稍复杂。</li>
</ol>

<h5 id="经典例题-4">经典例题</h5>

<ul>
  <li>
    <p><a href="https://leetcode.cn/problems/majority-element/">169. 求众数：出现次数大于 n/2 的元素</a></p>

    <ol>
      <li>哈希表法：<code class="highlighter-rouge">O(n)</code>；</li>
      <li>摩尔投票法：计数器，计数器为 0 时，假设 nums[i] 就是众数；遇到相同元素则 <code class="highlighter-rouge">++</code>，遇到不同元素则 <code class="highlighter-rouge">--</code>，空间<code class="highlighter-rouge">O(1)</code>【】</li>
    </ol>

    <p><img src="assets/8wyb2.gif" alt="img" style="zoom:43%;" /></p>
  </li>
</ul>

<h3 id="堆">堆</h3>

<h5 id="定义">定义</h5>

<p>堆是一种树，任意一个节点的值都 <code class="highlighter-rouge">&gt;=</code>（或 <code class="highlighter-rouge">&lt;=</code>）其所有子节点的值。</p>

<ul>
  <li>最大堆</li>
  <li>最小堆</li>
</ul>

<p>用途：用于只关心最值：<strong>多次</strong>插入数据或 pop 最值后，再<strong>多次获取</strong>剩余元素的最（最大或最小）值（插入/删除 + 全体排序耗费资源太多）。</p>

<h5 id="优势">优势</h5>

<p>相对于有序数组，堆的主要优势在于更新（插入或删除）数据效率较高。</p>

<ol>
  <li>初始化：有序数组用排序算法；堆为<code class="highlighter-rouge">nlg(n)</code>；</li>
  <li>查找最值： 都是<code class="highlighter-rouge">O(1)</code>；</li>
  <li>更新（插入或删除）数据： <code class="highlighter-rouge">O(n)</code>，二分法为 <code class="highlighter-rouge">lg(n)</code> + 移动数据 <code class="highlighter-rouge">O(n)</code> ；堆为<code class="highlighter-rouge">lg(n)</code>。</li>
</ol>

<h5 id="堆的存储">堆的存储</h5>

<p>通常用<strong>完全二叉树</strong>的形式来表示、存储堆。也不一定全都是完全二叉树，如斐波那契堆和二项堆。</p>

<p>用<a href="#二叉树的存储">数组存储二叉树</a>既节省空间，又方便索引。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();
pq.offer(e); // 插入堆
int e = pq.poll(); // 删除/弹出堆顶元素
</code></pre></div></div>

<h5 id="插入元素">插入元素</h5>

<p><img src="assets/堆-插入元素1.9a9e88c3.png" alt="堆-插入元素-1" style="zoom: 44%;" /></p>

<ol>
  <li>将要插入的元素放到数组末尾；</li>
  <li>自底向上堆化，将末尾元素上浮（如果父结点比该元素大则交换，直到无法交换）；</li>
</ol>

<h5 id="删除堆顶元素">删除堆顶元素</h5>

<p>删除（弹出）堆顶元素后，为了保持堆顶元素为最值的性质，需调整堆的结构，称为”<strong>堆化</strong>“。</p>

<p><img src="assets/删除堆顶元素.png" style="zoom:44%;" /></p>

<ul>
  <li>自底向上堆化：子节点接力上浮填补空白；易出现“气泡”，导致存储空间浪费。</li>
</ul>

<p><img src="assets/自底向上堆化1.png" style="zoom: 44%;" /><img src="assets/自底向上堆化2.png" style="zoom: 44%;" /></p>

<ul>
  <li><strong>自顶向下堆化</strong>：不会出现气泡；
    <ol>
      <li>将末尾元素放至堆顶；</li>
      <li>堆顶元素下沉（由最顶部向下移动）：逐步与左右子节点比较并交换位置，直到无法交换位置；</li>
    </ol>
  </li>
</ul>

<p><img src="assets/堆顶元素下沉1.png" style="zoom: 36%;" /><img src="assets/堆顶元素下沉2.png" style="zoom: 36%;" /><img src="assets/堆顶元素下沉3.png" style="zoom: 36%;" /></p>

<h5 id="堆排序"><a href="#3.2 堆排序">堆排序</a></h5>

<h5 id="第k个元素">第K个元素</h5>

<ol>
  <li>
    <p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></p>

    <ul>
      <li><code class="highlighter-rouge">PriorityQueue</code>：实现大小为 <code class="highlighter-rouge">k</code> 的最小（<strong>默认</strong>）堆，
        <ol>
          <li>方式一：弹出堆顶的最小元素再加入新元素，重复此过程，始终留下 <code class="highlighter-rouge">k</code> 个元素（维持堆的大小为 <code class="highlighter-rouge">k</code>），堆顶（最小元素）即第 k 大的元素；即 [347] 中的思路；</li>
          <li><del>方式二：全部加入堆中，不断弹出堆顶元素，直到剩下 <code class="highlighter-rouge">k</code> 个元素；占用额外空间；</del></li>
        </ol>
      </li>
      <li>方式三：快速选择算法，稍微改造了快速排序的算法思路。【】</li>
      <li>实现最大堆，弹出第 K 个元素；</li>
    </ul>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 默认创建最小堆，设置大小为k
PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; {
    return a.val - b.val;
});
// 改造为最大堆
PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(k, (a, b) -&gt; (b - a));
   
PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer a, Integer b) {
    	return map.get(a) - map.get(b);
    }
});
</code></pre></div>    </div>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a>：最小堆，借助 <strong>哈希表</strong> 来建立数字和出现次数的映射，遍历一遍数组统计元素的频率：</p>

    <ol>
      <li>维护一个元素数目为 k 的最小堆；</li>
      <li>每次都将新元素与堆顶元素（堆中频率最小的元素）进行比较；</li>
      <li>如果新元素的频率比堆顶元素大，则弹出堆顶端的元素，将新元素添加进堆中；</li>
      <li>最终，堆中的 k 个元素即为前 k 个高频元素。</li>
    </ol>
  </li>
</ol>

<p><img src="assets/xged1.gif" alt="img" style="zoom:60%;" /></p>

<ol>
  <li>
    <p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a> ：将<code class="highlighter-rouge">k</code>条链表的头结点加入最小堆（用<a href="#PriorityQueue 优先队列">PriorityQueue 优先级队列</a>实现）进行节点排序，选取堆顶元素；不断将链表的剩余节点加入最小堆。</p>

    <ul>
      <li><code class="highlighter-rouge">pq</code> 中的元素个数最多是 <code class="highlighter-rouge">k</code>，一次 <code class="highlighter-rouge">poll</code> 或 <code class="highlighter-rouge">add</code> 方法的时间复杂度是 <code class="highlighter-rouge">logk</code>；所有节点都会被加入和弹出 <code class="highlighter-rouge">pq</code>，整体是 <code class="highlighter-rouge">Nlogk</code>，其中<code class="highlighter-rouge">N</code> 是所有链表的节点总数。</li>
    </ul>

    <p><img src="https://blog-1257126549.cos.ap-guangzhou.myqcloud.com/blog/iuxmh.gif" alt="img" style="zoom:40%;" /></p>
  </li>
</ol>

<h3 id="树">树</h3>

<h5 id="基本概念">基本概念</h5>

<ul>
  <li>节点的高度 ：该节点到<strong>叶子节点</strong>的最长路径所包含的<strong>边数</strong>；
    <ul>
      <li>树的高度 ：根节点的高度。</li>
    </ul>
  </li>
  <li>节点的深度 ：<strong>根节点</strong>到该节点的路径所包含的<strong>边数</strong>；
    <ul>
      <li>树的深度：叶子节点的最大深度。</li>
    </ul>
  </li>
  <li>节点的层数 ：节点的深度+1。</li>
  <li>路径：一条从树中任意节点出发，沿父-子节点连接，达到任意节点的序列。同一节点至多出现一次 ；至少包含一个节点，且不一定经过根节点。
    <ul>
      <li>路径和：路径中各节点值的总和。</li>
      <li>单边路径和：从根节点 root 为起点的路径和。</li>
    </ul>
  </li>
</ul>

<p><img src="assets/二叉树-2.png" alt="二叉树" style="zoom: 50%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}
</code></pre></div></div>

<h5 id="树图的遍历">树、图的遍历</h5>

<p>树的 <code class="highlighter-rouge">DFS/BFS</code> 遍历算法</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 多叉树遍历框架
void traverse(TreeNode root) {
	if (root == null) return;
    for (TreeNode child : root.childern) {
        // 前序位置，在进入节点前执行的操作
        traverse(child);
        // 后序遍历的操作
    }
}
</code></pre></div></div>

<h5 id="经典题目">经典题目</h5>

<ul>
  <li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>
    <ol>
      <li>递归：根据 <code class="highlighter-rouge">root、p、q</code> 的关系递归；<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a>【】</li>
      <li>还可转化为 <a href="#链表快慢双指针">两链表的公共节点</a>；</li>
    </ol>
  </li>
  <li>Huffman 树</li>
</ul>

<h3 id="二叉树">二叉树</h3>

<p>优点：增<strong>删</strong>改查性能都很好；</p>

<p>缺点：斜树，瘸子；因此发展出变体满二叉树、完全二叉树；</p>

<h5 id="分类">分类</h5>

<ol>
  <li>
    <p>满二叉树：二叉树每层（第 k 层，深度为 k-1）的结点数都达到最大值 2^(k-1)^，即结点总数是(2^k^) -1。</p>
  </li>
  <li>
    <p>完全二叉树：最后一层若不满则缺少的节点都在右边，其余层都是满的。性质：父子节点的序号有对应关系。</p>

    <p><img src="assets/完全二叉树.c4f02f51.png" alt="img" style="zoom: 45%;" /><img src="assets/balance_bst.jpg" alt="数据结构与算法-二叉查找树平衡(DSW) - 知乎" style="zoom: 40%;" /></p>
  </li>
  <li>
    <p>二叉查找/搜索/排序树、<code class="highlighter-rouge">BST</code> 树（<code class="highlighter-rouge">Binary Search Tree、ordered binary tree、sorted binary tree</code>）：若不为空，任意节点的值均 &gt; 左子树任意结点、均 &lt; 右子树任意节点（所有节点的值都不相等），且左右子树都是二叉查找树（即<strong>中序遍历</strong>为单调递增的二叉树 + 二分查找思想）。</p>
  </li>
</ol>

<ul>
  <li>压扁了就是无重复值的有序数组。<del>由二叉树的<strong>层序遍历</strong>扩展而来，常用于求无权图的<strong>最短路径</strong>。维护了一组数据的顺序性，得到一个数据的上下界。</del></li>
  <li>注意不是所有的 BST 题目都需递归，有的只需 <code class="highlighter-rouge">while</code> 循环即可；</li>
  <li><strong>查找</strong>、插入、删除（CRUD）节点：复杂度均为 <code class="highlighter-rouge">O(h+1)</code>，<code class="highlighter-rouge">h</code>为树的高度/深度，最好（平衡二叉树）为 <code class="highlighter-rouge">O(lgN)</code>，最坏（斜树）为 <code class="highlighter-rouge">lgN</code>；</li>
  <li>缺点：若插入的是已有序的序列，可能退化成斜树、链表，CRUD 的性能均从 <code class="highlighter-rouge">lgN</code> 降为 <code class="highlighter-rouge">O(N)</code>；因此引入平衡二叉树。</li>
</ul>

<ol>
  <li>
    <p>平衡二叉树、<code class="highlighter-rouge">AVL</code> 树：除了空树，每个节点的左右子树都是一棵平衡二叉树、且高度差的绝对值不超过1。常用实现方法有 <strong>红黑树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong> 等。</p>
  </li>
  <li>
    <p>红黑树（自平衡二叉查找树、对称二叉 <code class="highlighter-rouge">B</code> 树）：<a href="https://zhuanlan.zhihu.com/p/78249704">一篇漫画告诉你–什么是红黑树？</a></p>
  </li>
</ol>

<ul>
  <li>一种<strong>二叉查找树</strong>，满足：
    <ol>
      <li>根、所有叶子节点（为空、NIL 或 null）都是黑色；</li>
      <li>每个红节点必须有两个黑子节点。（或红节点的父、子节点均是黑色）（或从每个叶子到根的所有路径上不能有两个连续的红节点）（或不存在两个相邻（父子关系）的红节点）；</li>
      <li>从任一节点到每个叶子的所有简单路径都包含相同数目的黑节点。确保没有一条路径会比其他路径长出两倍。</li>
    </ol>
  </li>
  <li>既有线性表的二分查找、有序，又有链表的增删性能。可在 <code class="highlighter-rouge">O(lgN)</code> 时间内完成查找、插入和删除。</li>
  <li>典型用途是实现关联数组，<code class="highlighter-rouge">TreeMap、TreeSet</code> 及 <code class="highlighter-rouge">JDK1.8</code> 的 <code class="highlighter-rouge">HashMap</code> 底层都用到红黑树。</li>
  <li>变色：添加、删除；</li>
  <li>左旋算法：父节点被自己的<strong>右孩子</strong>取代。</li>
</ul>

<p><img src="assets/450px-Red-black_tree_example.svg.png" alt="An example of a red-black tree" style="zoom: 75%;" /><img src="assets/left_handed.jpg" alt="img" style="zoom: 60%;" /></p>

<ol>
  <li>
    <p><code class="highlighter-rouge">B</code> 树 / 多路平衡查找树、<code class="highlighter-rouge">B+</code> 树：用于数据库索引的实现。</p>

    <ol>
      <li>B 树的所有节点存放键和数据；</li>
      <li>而 B+树只有叶子节点存放 <code class="highlighter-rouge">key</code> 和 <code class="highlighter-rouge">data</code>，其他内节点只存放 <code class="highlighter-rouge">key</code>。</li>
    </ol>
  </li>
  <li>
    <p><code class="highlighter-rouge">Trie</code> 树、字典树、前缀树、单词查找树：由二叉树衍生出来，主要用于处理字符串前缀相关的操作、保存和统计大量的字符串和相关的信息。</p>
  </li>
  <li>
    <p>线段树：处理数组区间信息的汇总（求和、最值等）、单点更新、区间更新问题。</p>
  </li>
  <li>
    <p>树状数组：处理数组的前缀和、单点更新、区间更新问题。</p>
  </li>
</ol>

<h5 id="二叉树的存储">二叉树的存储</h5>

<ul>
  <li>链式存储</li>
  <li>顺序存储：用于<a href="#堆的存储">堆的存储</a>；
    <ul>
      <li>根结点的序号为 0，则下标为 <code class="highlighter-rouge">i</code> 的节点对应的：
        <ol>
          <li>父结点：<code class="highlighter-rouge">(i - 1) / 2</code></li>
          <li>左子结点：<code class="highlighter-rouge">2 * i + 1</code></li>
          <li>右子结点：<code class="highlighter-rouge">2 * i + 2</code></li>
          <li>非叶节点：<code class="highlighter-rouge">[0, (n-1)/2]</code>，用于<a href="#3.2 堆排序">建堆</a>；</li>
        </ol>

        <p><img src="assets/y1l6o3nhel.png" alt="img" style="zoom: 80%;" /></p>
      </li>
      <li>根结点的序号为 1，若根结点的序号为 <code class="highlighter-rouge">1</code>，对于树中任意节点 <code class="highlighter-rouge">i</code>，其
        <ol>
          <li>父结点：<code class="highlighter-rouge">i / 2</code></li>
          <li>左子节点序号为： <code class="highlighter-rouge">2 * i</code></li>
          <li>右子节点为： <code class="highlighter-rouge">2 * i + 1</code></li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h5 id="bst-二叉查找树">BST 二叉查找树</h5>

<ul>
  <li><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将升序数组转为高度平衡的二叉搜索树</a>：在前序位置，取 <code class="highlighter-rouge">mid</code> 位置的元素构造当前 <code class="highlighter-rouge">root</code> 节点，递归创建左右子树；【】
    <ul>
      <li><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>：链表和数组相比一个关键差异是无法通过索引快速访问元素；【】
        <ol>
          <li>把链表转化成数组；</li>
          <li>用双指针获取链表的中点；</li>
          <li>利用中序遍历的特点写出最优化的解法。</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h5 id="层序遍历">层序遍历</h5>

<p>外部变量 + <strong>迭代遍历</strong>一遍：对应<a href="#回溯算法框架">回溯算法核心框架</a>，简单易懂；</p>

<ul>
  <li>
    <p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>：从上到下用 <code class="highlighter-rouge">while</code> 遍历每层、并塞入<strong>队列</strong>，自左向右用 <code class="highlighter-rouge">for</code> 遍历每行、将结果加入 List。可扩展出 <a href="#BFS 算法框架">BFS 算法框架</a>；</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></li>
      <li><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a>：奇偶层 <code class="highlighter-rouge">ArrayList</code> 分别用 <code class="highlighter-rouge">addLast()、addFirst()</code>；【】</li>
      <li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的自底向上层序遍历 II</a>【】</li>
      <li>从上到下打印每行中的最大值；</li>
      <li><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a>【】
        <ol>
          <li>用 BFS <strong>层序遍历</strong>算法，从右往左遍历每行，每层 <code class="highlighter-rouge">queue</code> 的第一个节点就是右视图。</li>
          <li>用 DFS <del>递归遍历</del>算法，反过来从右往左遍历每一行，先递归 <code class="highlighter-rouge">root.right</code> 再递归 <code class="highlighter-rouge">root.left</code>，同时用 <code class="highlighter-rouge">res</code> 记录每层的最右侧节点作为右视图。</li>
        </ol>
      </li>
    </ul>

    <p><img src="assets/binary_level_order.gif" alt="img" style="zoom: 33%;" /><img src="assets/20181115113908.gif" alt="img" style="zoom: 33%;" /></p>
  </li>
</ul>

<p><strong>层序遍历框架</strong>：</p>

<p><img src="assets/binary_bfs.jpeg" alt="img" style="zoom: 28%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 层序遍历：非递归实现
public List&lt;List&lt;Integer&gt; &gt; levelOrderTraverse(TreeNode root) {
    // 一维结果
    // List&lt;Integer&gt; res = new LinkedList&lt;&gt;();
    // 二维结果
    List&lt;List&lt;Integer&gt; &gt; res = new LinkedList&lt;&gt;();
    if (root == null) return res;
    Deque&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();
    q.offer(root);
    
    // 从上到下遍历二叉树的每一层
    while (!q.isEmpty()) {
    	// depth++; // 深度，初始化为0
        int sz = q.size();
        List&lt;Integer&gt; re = new LinkedList&lt;&gt;(); // not List new，level，长度可变
        // 右视图从右往左遍历，且保存队头（队列中第0个元素）
        // TreeNode last = q.peek();
        // 从左到右遍历本层的每个节点
        for (int i = 0; i &lt; sz; i++) {
            TreeNode cur = q.poll(); //	
            re.add(cur.val); // not offer() push()
            if (0 == res.size()%2) { // 奇数层
            }
            // 二叉树的最小深度
            if (node.left == null &amp;&amp; node.right == null) {
                return depth;
            }
            // 将下一层节点放入队列
            if (cur.left != null) {
                q.offer(cur.left);
            }
            // 从右往左遍历时，right先入队，用于右视图等
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
        res.add(re);
        // 前插每层的遍历结果，就是自底向上的层序遍历
        //res.addFirst(level);
        // 用于右视图
        //res.add(last.val);
    }
    return res;
}

// 层序遍历：递归实现
List&lt;List&lt;Integer&gt; &gt; res = new ArrayList&lt;&gt;(); // 需用到get()，not LinkedList
List&lt;List&lt;Integer&gt; &gt; levelOrderTraverse(TreeNode root) {
    if (root == null) {
        return res;
    }
    // root 深度为 0，视为第 0 层
    traverse(root, 0);
    return res;
}

void traverse(TreeNode root, int depth) {
    if (root == null) {
        return;
    }
    // 前序位置，判断是否已存储 depth 层的节点
    if (res.size() &lt;= depth) {
        // 第一次进入 depth 层
        res.add(new LinkedList&lt;&gt;());
    }
    // 前序位置，在 depth 层添加 root 节点的值
    res.get(depth).add(root.val);
    traverse(root.left, depth + 1);
    traverse(root.right, depth + 1);
}
</code></pre></div></div>

<h5 id="前序中序后序遍历">前序/中序/后序遍历</h5>

<ol>
  <li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>：逻辑上用栈，实际在递归的前序位置用<strong>递归栈</strong>；</li>
  <li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>：在递归的中序位置用<strong>递归栈</strong>；【】</li>
  <li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a>：在递归的后序位置用<strong>递归栈</strong>；【】
    <ul>
      <li><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>：递归后序遍历时，计算单边路径和、最大路径和【】</li>
    </ul>
  </li>
</ol>

<p><img src="assets/v17b8.gif" alt="img" style="zoom:36%;" /><img src="assets/y7nxo.gif" alt="img" style="zoom:36%;" /></p>

<ol>
  <li>
    <p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 根据前序与中序遍历序列构造二叉树</a>：<code class="highlighter-rouge">inorderValToIdxMap&lt;&gt;</code> 存储中序序列的值到索引的映射；前序序列 <code class="highlighter-rouge">preorder[preStart, preEnd]</code> 确定 root 、左子树 + 右子树的范围，再根据中序序列 <code class="highlighter-rouge">inorder[inStart, inEnd]</code> 确定（划分）左右子树的长度，得到左右子树的前序和中序序列，递归；</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a>【】</li>
    </ul>

    <p><img src="assets/btree_pre_in_order.jpeg" alt="img" style="zoom: 35%;" /><img src="assets/btree_pre_in_order2.jpeg" alt="img" style="zoom:28%;" /></p>
  </li>
</ol>

<p><strong>递归框架</strong>：</p>

<p>在递归函数中，将当前节点<strong>分解</strong>为子问题（子树），通过子树的结果推导出当前节点的结果：对应<a href="#动态规划算法框架">动态规划核心框架</a>；</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public List&lt;Integer&gt; preorderTraverse(TreeNode root) {
    List&lt;Integer&gt; res = new LinkedList&lt;&gt;();
    if (root == null) ret urn res;
    
    // 前序位置：自顶向下、自左向右遍历node、执行代码；从根节点遍历过来的过程能顺带记录前序位置的信息，如节点的深度；快速排序，对前中后序位置不敏感的代码；
    res.add(root.val);
    res.addAll(preorderTraverse(root.left));
    // 中序位置：主要用在 BST 二叉查找树场景
    res.addAll(preorderTraverse(root.right));
    // 后序位置：自底向上遍历node、执行代码；只有后序位置才能通过返回值获取子树的信息，如树的深度/高度、二叉树的最大深度（即根节点到「最远」叶子节点的最长路径上的节点数）、节点的高度；归并排序、大多数和子树有关的、倒序打印单链表、二叉树的最长直径（即任意两个结点间的路径长度，不一定要穿过根结点=左右子树的最大深度之和+1）
    return res;
}
</code></pre></div></div>

<h3 id="图">图</h3>

<blockquote>
  <p>面试笔试很少出现图相关的问题，就算有大多也是简单的遍历问题，基本上可完全照搬多叉树的遍历。</p>

</blockquote>

<h5 id="基本概念-1">基本概念</h5>

<p>图（G）由顶点的有穷非空集合（V）和顶点间的边（E）组成，通常表示为：<strong>G(V,E)</strong>。如社交软件上好友关系。</p>

<ul>
  <li>无向图和有向图；</li>
  <li>无权图和带权图；</li>
</ul>

<p>树和图的根本区别：树不含环，图可能含环。树是一种图，即无环连通图，图是多叉树的延伸。如果图没有环，可拉伸成一棵树。</p>

<ul>
  <li>度（degree）：每个节点相连的边数。
    <ul>
      <li>入度（indegree）：有向图中指向每个节点的边数；</li>
      <li>出度（outdegree）：有向图中从每个节点出发的边数。</li>
    </ul>
  </li>
</ul>

<h5 id="图的存储">图的存储</h5>

<blockquote>
  <p>表示方法、具体实现、物理结构</p>
</blockquote>

<ul>
  <li>
    <p>邻接矩阵：优点是简单直接（用一个二维数组），可快速判断两点间是否连通，可进行矩阵运算，但（图比较稀疏时）会浪费空间。</p>
  </li>
  <li>
    <p><strong>邻接表</strong>：比较节省空间，但很多操作效率低，如无法快速判断两个节点是否连通。在常规的算法题中使用更频繁。</p>
    <ul>
      <li>在无向图中，邻接表元素个数等于边数的两倍；</li>
      <li>在有向图中，邻接表元素个数等于边的条数；</li>
    </ul>
  </li>
</ul>

<p><img src="assets/graph_impl.jpeg" alt="img" style="zoom: 15%;" /><img src="assets/有向图的邻接矩阵存储.46663a1b.png" alt="有向图的邻接矩阵存储" style="zoom: 36%;" /> <img src="assets/有向图的邻接表存储.362b00d5.png" alt="有向图的邻接表存储" style="zoom:36%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 邻接矩阵
// graph[x][y] 记录 x 是否有一条指向 y 的边、或边的权重
boolean/int[][] graph;

// 邻接表
// graph[x] = List&lt;Integer&gt; ？存储 x 的所有相邻节点
List&lt;Integer&gt;[] graph;
</code></pre></div></div>

<h5 id="图的搜索遍历">图的搜索、遍历</h5>

<p>各种搜索问题其实都是树的遍历问题：</p>

<ul>
  <li><a href="#DFS 框架、回溯">DFS 深度优先搜索</a>：用<strong>栈</strong>回溯；</li>
  <li><a href="#BFS 框架">BFS 广度优先搜索</a>：把问题抽象成图，每次将当前节点周围的所有节点加入<strong>队列</strong>。</li>
</ul>

<p>二者最主要的区别是：BFS 的 <code class="highlighter-rouge">depth</code> 每增加一次，队列中的所有节点都向前迈一步，保证了第一次到达终点时，走的步数是最少的，可在不遍历完整棵树的条件下找到<strong>最短路径</strong>。DFS 实际上是靠递归的堆栈记录走过的路径，把二叉树中所有节点都走完才能对比出<strong>最短路径</strong>。</p>

<p>BFS 空间复杂度比 DFS 大。</p>

<p><img src="assets/tree_select.jpg" alt="img" style="zoom: 25%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 记录被遍历过的节点
boolean[] visited;
// 记录从起点到当前节点的路径，用于判断是否成环
boolean[] onPath;

// 图的遍历框架：递归实现
void traverse(Graph graph, int s) { // 节点 s
    if (visited[s]) return;
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (int neighbor : graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}
</code></pre></div></div>

<ul>
  <li><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a>【】
    <ul>
      <li><a href="https://leetcode.cn/problems/bP4bmD/">剑指 Offer II 110. 所有路径</a>【】</li>
    </ul>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 记录所有路径
List&lt;List&lt;Integer&gt; &gt; res = new LinkedList&lt;&gt;();

public List&lt;List&lt;Integer&gt; &gt; allPathsSourceTarget(int[][] graph) {
    // 维护递归过程中经过的路径
    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();
    traverse(graph, 0, path);
    return res;
}

// 图的遍历框架：非递归实现
void traverse(int[][] graph, int s, LinkedList&lt;Integer&gt; path) {
    // 添加节点 s 到路径
    path.addLast(s);

    int n = graph.length;
    if (s == n - 1) {
        // 到达终点
        res.add(new LinkedList&lt;&gt;(path));
        // 可在这直接 return，但要 removeLast 正确维护 path
        path.removeLast();
        return;
        // 不 return 也可，因为图中不含环，不会出现无限递归
    }
    // 递归每个相邻节点
    for (int v : graph[s]) {
        traverse(graph, v, path);
    }
    // 从路径移出节点 s
    path.removeLast();
}
</code></pre></div></div>

<h5 id="最小生成树-kruskal-算法">最小生成树 Kruskal 算法</h5>

<blockquote>
  <p>经典算法，学有余力可以掌握一下</p>
</blockquote>

<p>图的生成树：生成树是包含图中所有顶点的<strong>无环连通子图</strong>（无环树）。</p>

<p><a href="https://visualgo.net/zh/mst">最小生成树（MST）</a>：权重和最小的生成树。都用了贪心思想。<a href="https://leetcode.cn/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a>【】</p>

<ol>
  <li><code class="highlighter-rouge">Kruskal</code> 克鲁斯卡尔算法：用到了贪心思想，使权重和尽可能小。对所有边按照权重从小到大排序，从权重最小的边开始，选择合适的边加入 <code class="highlighter-rouge">mst</code> 集合；如果边的两端点不属于同一集合，则合并，直到所有的点都属于同一个集合为止。用并查集算法来保证生成树不含环且不是森林：</li>
  <li>如果一条边的两个节点是连通的，则会出现环；</li>
  <li>如果最后的连通分量总数大于 1，则说明是「森林」。</li>
  <li>并查集 Union-Find Disjoin Sets（UFDS）：用于处理不相交集合的动态连接问题。模拟多个不相交集，能在几乎常数时间内确定一个元素属于哪个集、测试两个元素是否属于同一个集、将两个不相交集合并为一个。在<code class="highlighter-rouge">Kruskal</code>算法中用来寻找无向图中的连接分量。</li>
  <li><code class="highlighter-rouge">Prim</code> 普瑞姆算法：核心是切分定理（将图分为两个不重叠且非空的节点集合），每次都把权重最小的「横切边」拿出来，直到把构成最小生成树的所有边都切出来为止。用 BFS 算法思想 和 <code class="highlighter-rouge">visited</code> 布尔数组避免成环。</li>
</ol>

<h5 id="最短路径-dijkstra-算法">最短路径 Dijkstra 算法</h5>

<blockquote>
  <p>经典算法，学有余力可以掌握一下</p>
</blockquote>

<p>简单图（有向无向皆可）的最短路径 Dijkstra 迪杰斯特拉算法：注意是长度而不是具体的路径。是 BFS 算法的加强版，都是从二叉树的层序遍历衍生出来。</p>

<h5 id="经典题目-1">经典题目</h5>

<ul>
  <li>看到依赖问题 ==&gt; 首先想到的就是把问题转化成「有向图」</li>
</ul>

<p>比较基本且有用的算法，应较熟练地掌握：</p>

<ul>
  <li>
    <p>有向图的环检测、循环依赖判断：<a href="https://leetcode.cn/problems/course-schedule/">207. 课程表 选修依赖先修</a><a href="https://labuladong.github.io/algo/2/20/49/">二分图判定算法</a>，常用邻接表，DFS 算法遍历图的框架 + <code class="highlighter-rouge">visited</code> 数组</p>

    <ul>
      <li>DFS 实现</li>
      <li>BFS 实现</li>
    </ul>
  </li>
  <li>
    <p>拓扑排序（Topological Sorting）：是一个<strong>有向无环图</strong>所有顶点的线性序列；</p>

    <ol>
      <li>每个顶点出现且只出现一次；</li>
      <li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。</li>
    </ol>

    <p><img src="assets/399159-20151229144326901-1530781288.png" alt="img" style="zoom:50%;" /></p>

    <p>直观说就是，把一幅图「拉平」，且所有箭头方向都是一致的。存在环，则肯定做不到所有箭头方向一致。如返回一个合理的上课顺序，保证开始修每个课程时，前置课程都已修完。实现：</p>

    <ul>
      <li>DFS 实现（可进一步理解递归）</li>
      <li>BFS 实现（更简洁）</li>
    </ul>
  </li>
  <li>
    <p>二分图的判定、图论的双色问题：二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。</p>
  </li>
</ul>

<h3 id="布隆过滤器">布隆过滤器</h3>

<p>布隆过滤器：可非常方便地判断一个给定数据<strong>不存在于</strong>海量数据中（哈希函数）；用于解决 Redis 中的<strong>缓存穿透</strong>。</p>

<h2 id="手撕算法">手撕算法</h2>

<h3 id="算法定义">算法定义</h3>

<ul>
  <li>数据结构：是解决问题的过程中（存放、处理数据）的容器和缓存，是空间换时间思想的体现。</li>
  <li>算法：是（正确、高效）解决问题的方法：
    <ul>
      <li>算法工程师（数学算法）：重点在数学建模和调参经验，计算机只是拿来做计算的工具而已；</li>
      <li>数据结构与算法（计算机算法）：重点是计算机思维，站在计算机的视角，抽象、化简实际问题，用合理的数据结构去解决问题。</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>大部分开发岗位工作中都是基于现成的开发框架做事，不怎么会碰到底层数据结构和算法相关的问题，但技术相关的岗位，数据结构和算法的考察，公认的程序员基本功。</p>
</blockquote>

<h3 id="常用技巧">常用技巧</h3>

<blockquote>
  <p>一题多解、多题一解。一句话题解、写题目详解、写总结。</p>
</blockquote>

<ul>
  <li>排序类</li>
  <li>数组、字符串：<strong><a href="#二分查找">二分查找</a></strong>
    <ul>
      <li>n数之和：<a href="#nSum">nSum</a></li>
      <li>子数组的和：<a href="#前缀和">前缀和</a>
        <ul>
          <li>频繁对子数组增减：<a href="#差分数组">差分数组</a></li>
        </ul>
      </li>
      <li>双指针：左右（相向、背向）；同向（快慢、同速）</li>
      <li>子串：动态规划</li>
      <li>数组元素的取值都在 <code class="highlighter-rouge">[0, n-1]</code> 范围内：哈希表 <code class="highlighter-rouge">HashMap&lt;Integer, Integer&gt;</code></li>
    </ul>
  </li>
  <li>单链表：
    <ul>
      <li>子串：<strong><a href="#快慢双指针">快慢双指针</a></strong>（滑动窗口）</li>
      <li>反转链表</li>
    </ul>
  </li>
  <li>递归类：
    <ul>
      <li>二叉树：
        <ul>
          <li><strong>回溯</strong>算法核心框架：遍历一遍二叉树得出答案；</li>
          <li><strong>动态规划</strong>核心框架：通过分解问题计算出答案；</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>非递归类：无遗漏（正确不出错）、无冗余（优化算法的时间、空间复杂度）聪明的穷举。
    <ul>
      <li><strong>贪心</strong>：在题目中发现一些规律（专业点叫贪心选择性质），不用完整穷举所有解。</li>
    </ul>
  </li>
  <li><strong>分治</strong>：核心依然是大问题分解成子问题，只不过没有重叠子问题</li>
</ul>

<h3 id="时间空间复杂度">时间、空间复杂度</h3>

<h3 id="排序">排序</h3>

<blockquote>
  <p>排序算法总结和比较。注意写代码的流畅度。</p>
</blockquote>

<ul>
  <li>
    <p><a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/cs-basics/algorithms/10-classical-sorting-algorithms.md#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-radix-sort">10-classical-sorting-algorithms</a></p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a></p>
  </li>
</ul>

<p>可分为：</p>

<ol>
  <li>内部排序：数据记录在内存中进行排序；</li>
  <li>比较类排序：通过比较元素大小来排序；</li>
  <li>（线性时间）非比较类排序 ：不通过比较、而是通过每个元素前的元素个数来排序（决定元素间的相对次序）；
    <ul>
      <li>一次遍历即可，可突破基于比较排序的时间下界，以线性时间运行，算法时间复杂度 <code class="highlighter-rouge">O(n)</code>；</li>
      <li>以空间换时间：需占用空间来确定唯一位置，对数据规模和分布有一定要求。</li>
    </ul>
  </li>
  <li>外部排序：数据量很大，内存一次不能容纳全部记录，需访问外部文件（外存）。</li>
</ol>

<p>四个不稳定的算法：<strong>希快选堆</strong>。可能变为不稳定：插冒。</p>

<p><img src="assets/sort_time_complex.png" alt="img" style="zoom: 64%;" /><img src="assets/sort_classify.png" alt="排序算法分类" style="zoom:20%;" /></p>

<h4 id="0-内置排序函数">0. 内置排序函数</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Arrays.sort(nums);

List&lt;User&gt; list = new ArrayList&lt;User&gt;();
Collections.sort(list);
</code></pre></div></div>

<h4 id="1-插入排序">1. 插入排序</h4>

<h5 id="11-插入排序">1.1 插入排序</h5>

<ul>
  <li>工作原理：（将待排序元素）分为已排序和未排序两部分。相当于<strong>抓牌 + 插牌</strong>的过程：
    <ol>
      <li>抓牌：遍历未排序元素，作为待插入元素；</li>
      <li>插牌：
        <ol>
          <li>直接插入：<strong>由后向前</strong>查找当前元素在已排序元素中的位置，将后面的元素<strong>逐个后移</strong>，插入目标位置；</li>
          <li>折半插入：<a href="#二分查找框架">二分查找</a>插入位置，统一后移。</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>最易理解</li>
  <li>性能：<code class="highlighter-rouge">n（有序、设置flag表示此趟是否排序） n^2^  n^2^（逆序） O(1)</code></li>
  <li>稳定：<strong>查找右边界（值相等就停止查找）时</strong>，值相等的元素保持原来的相对位置（原序）。</li>
</ul>

<p><img src="assets/insertion-sort-1-animate-example.svg" alt="insertion sort animate example" style="zoom: 50%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void directInsertSort(int[] arr) {
    for (int i = 1; i &lt; arr.length; i++) { // 第0个不用排序
        int target = arr[i];
        int j = i - 1;
        for (; j &gt;= 0 &amp;&amp; arr[j] &gt; target; j--){ // 防止下界溢出
            arr[j + 1] = arr[j]; // 逐个后移
        }
        // if (j &gt;= 0) {
            arr[j + 1] = target; // j最小为-1，此时待插入元素最小，插入0位置
        //}
    }
}

public static void binaryInsertSort(int[] arr) {
    for (int i = 1; i &lt; n; i++) {
        int target = arr[i];
        // 在已排序序列中二分查找插入位置，相当于在区间[0, i-1]中查找右边界
        int pos = binaryRightBound(arr, 0, i-1, target);
        // 将pos后、[pos, i - 1]内的元素由后往前、统一逐位后移
        for (int j = i - 1; j &gt;= 0 &amp;&amp; j &gt;= pos; j--) { // not while, pos = -1
            nums[j + 1] = nums[j];
        }
        // target插入pos位置
        arr[pos] = target; // pos == j + 1 &gt;= 0 
    }
}

// right bound not found, then return min value's index witch greater than target
public static int binaryRightBound(int[] arr, int lo, int hi, int target) {
    while (lo &lt;= hi) { // 同二分查找算法框架
		int mid = lo + (hi-lo)/2;
		// 2.找右边界时，收缩左侧边界
		if (nums[mid] &lt;= target) {
			lo = mid + 1;
		} else if (nums[mid] &gt; target) {
			hi = mid - 1;
		}
	}
    return lo; // [0, -1] return lo=0
}
</code></pre></div></div>

<h5 id="12-希尔排序">1.2 希尔排序</h5>

<ul>
  <li>又称缩小增量排序；</li>
  <li>基本思想：
    <ol>
      <li>将整个待排序的记录，分成为若干组子序列，在组内（直接插入）排序；当整个序列中的记录基本有序时，再对全体记录排序；</li>
      <li>间隔为步长（倍数）的位置分为一组（物理上并不相邻，逻辑上通过步长相邻），组内直接插入排序，不断缩小步长，通常步长减半 <code class="highlighter-rouge">gap[i]：n/2 -&gt; 1</code>（步长为1即直接插入排序）。</li>
    </ol>
  </li>
  <li><code class="highlighter-rouge">nlogn  nlogn?  n^2^  O(n)</code></li>
  <li><strong>不稳定</strong>：同组内元素交换位置后，不同组内相等元素的相对位置可能改变。如<code class="highlighter-rouge">[4, 2, 2, 3]</code>。</li>
</ul>

<p><img src="assets/shell_sort.png" alt="shell_sort" style="zoom: 33%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void shellSort(int[] nums) {
	...
	for (int gap = n/2; gap &gt; 0; gap /= 2) { // 步长减半
		// 分组内进行直接插入排序，逐个分组排序
		for (int i = gap * 1; i &lt; n; i++) {
			// 取出各组内第2个元素（总第gap个元素）作为待插入元素；
			// 取出各组内第3个元素（总第gap*2个元素）
            int target = nums[i];
			int pre = i - gap; // 同组的前一个元素的索引
			// 同组内i（当前元素）前的元素直接插入排序
			while (pre &gt;= 0 &amp;&amp; nums[pre] &gt; target) { // &amp;&amp;，相当于插入排序中的for逐个后移
				// 比当前元素大的在组内向后移，如第1个覆盖第2个
				nums[pre + gap] = nums[pre];
				pre -= gap;	// 向前迈一个步长
			}
			nums[pre + gap] = target; // 插入待排序元素
		}
	}
}
</code></pre></div></div>

<h4 id="2-交换排序">2. 交换排序</h4>

<h5 id="21-冒泡排序">2.1 冒泡排序</h5>

<ul>
  <li>基本思想：在未排序序列 <code class="highlighter-rouge">[0，n-i)</code> 范围内冒泡一次，相邻元素两两排序（逆序则交换）作为一趟冒泡，最大的元素向后冒泡，加入已排序元素的左侧。注意 i、j 的起始取值。</li>
  <li>性能：<code class="highlighter-rouge">n  n^2^  n^2^  O(1)</code></li>
  <li>稳定：交换时，元素相等就停止交换，可保证相对位置不变；（若改成 <code class="highlighter-rouge">arr[j-1] &gt;= arr[j]</code>），两个相等的记录就会交换位置，则变为<strong>不稳定</strong>。</li>
</ul>

<p><img src="assets/bubble_sort.gif" alt="冒泡排序" style="zoom:50%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void bubbleSort(int[] nums) {
	int n = nums.length;
	for (int i = 0; i &lt; n; i++) { // [0, n)表示n次排序
		boolean runSort = false; // flag 作为一趟冒泡是否发生交换的标志
		for (int j = 1; j &lt; n - i; j++) { // 在[0，n-i)范围内冒泡一次，注意j=1
			if (nums[j-1] &gt; nums[j]) { // 逆序（前面的大于后面的）
				swap(nums, j-1, j); // 则交换
				runSort = true; // not i = n, then break from 2-for
			}
		}
		// 若一次交换也没有发生，则跳出循环
		if (!runSort) {
			break;
		}
	}
}
</code></pre></div></div>

<h5 id="22-快速排序">2.2 快速排序</h5>

<ul>
  <li>又称分区交换排序。</li>
  <li>基本思想：选取一个基准元素 <code class="highlighter-rouge">pivot</code>（即划分标杆、枢纽、比较子），通过一趟划分（分治法）将序列分隔成两个子序列：比基准元素小的元素都放在其左侧，大的放在右侧，对左右两部分<strong>递归</strong>。</li>
  <li>平均性能最优，划分最平衡，平均情况最接近最坏情况。</li>
  <li>性能：<code class="highlighter-rouge">nlgn   nlgn  n^2^</code>（最坏情况为划分不对称，如 <code class="highlighter-rouge">[1, 2, 3, 4]</code>，取最大值4/最小值1作为 pivot）</li>
  <li>空间：因为快排用递归（调用）实现， 每次函数调用中都用了常数的空间，因此空间复杂度 = 递归（工作栈的）深度 <code class="highlighter-rouge">Θ(lgn)</code>；用双指针、后者覆盖前者的方式代替交换函数。</li>
  <li><strong>不稳定</strong>：
    <ul>
      <li>待排序数组: <code class="highlighter-rouge">int a[] = {1, 2, 2, 3};</code></li>
      <li>在快速排序的随机选择 pivot 时：
        <ol>
          <li>若把等于基准元素的数放在左边，选择第一个 <code class="highlighter-rouge">2</code> 作为基准时，第二个 <code class="highlighter-rouge">2</code> 会被放在第一个 <code class="highlighter-rouge">2</code> 右边，二者非原序（即不稳定）；</li>
          <li>若把等于基准元素的数放在右边，选择第二个 <code class="highlighter-rouge">2</code> 作为基准时，第一个 <code class="highlighter-rouge">2</code> 会被放在第二个 <code class="highlighter-rouge">2</code> 右边，二者非原序（即不稳定）；</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>提高：
    <ol>
      <li>子序列规模较小时用直接插入；</li>
      <li>划分尽量对称；</li>
    </ol>
  </li>
</ul>

<p><img src="assets/quick_sort2.gif" alt="图片" style="zoom: 44%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static int partation(int[] nums, int lo, int hi) {
	int pivot = nums[lo]; // 取最左一位作为基准，not povit
	while (lo &lt; hi) {
		while (lo &lt; hi &amp;&amp; nums[hi] &gt;= pivot) { // &gt;=, not nums[pivot]
			hi--;
		}
		if (lo &lt; hi) {
			nums[lo++] = nums[hi]; // 覆盖最左
		}
		while (lo &lt; hi &amp;&amp; nums[lo] &lt; pivot) { // not &gt; or &lt;=
			lo++;
		}
		if (lo &lt; hi) {
			nums[hi--] = nums[lo]; //
		}
	}
	nums[lo] = pivot; // lo即为pivot最终放的index
	return lo;
}

public static void quickSort(int[] nums, int lo, int hi) {
	if (lo &lt; hi) { // 快排和归并都用此方法控制递归深度
        int pos = partation(nums, lo, hi); // partation
        quickSort(nums, lo, pos-1);	// -1
        quickSort(nums, pos+1, hi);
     }
}
</code></pre></div></div>

<h4 id="3-选择排序">3. 选择排序</h4>

<h5 id="31-简单选择排序">3.1 简单选择排序</h5>

<ul>
  <li>基本思想：一趟排序中，<strong>选择</strong>未排序序列中最小的元素，与未排序序列第一个元素交换，即添加在已排序序列的最后。</li>
  <li>代码最简单直观。</li>
  <li>性能：<code class="highlighter-rouge">n^2^ O(1)</code>  用于数据规模很小时，不占用额外的内存空间；</li>
  <li><strong>不稳定</strong>：<code class="highlighter-rouge">[2, 2, 1, 3]</code>，选择最小的 <code class="highlighter-rouge">1</code>，与第一个<code class="highlighter-rouge">2</code>交换后，两个<code class="highlighter-rouge">2</code>的相对顺序改变了。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void selectSort(int[] nums) {
    int n = nums.length;
    for (int i = 0; i &lt; n - 1; i++) { // n-2 趟,第n趟无意义
        int mini = i;
        // 从下一个位置开始查找，在[i+1, n)内查找
        for (int j = i + 1; j &lt; n; j++) {
            if (nums[j] &lt; nums[mini]) {
                mini = j; // 记录最小值的index
            }
        }
        // 最小值为未排序序列第一个（当前）元素时不移动；提高的效率并不高，可省略
        if (mini != i) {
            swap(nums,mini,i);
        }
    }
}
</code></pre></div></div>

<h5 id="32-堆排序">3.2 堆排序</h5>

<ul>
  <li><a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html">堆排序演示图</a>；如 <code class="highlighter-rouge">PriorityQueue</code> 即用堆排序实现；</li>
  <li><a href="https://oi-wiki.org/basic/heap-sort/">基本思想</a>：
    <ol>
      <li><strong><a href="https://visualgo.net/zh/heap">建大顶堆</a></strong>：将无序数组建立为一个<a href="#堆">二叉堆</a> <code class="highlighter-rouge">[0, n)</code>；<code class="highlighter-rouge">i = (n-1)/2 -&gt; 0</code> <strong>从后向前</strong>遍历非叶节点，按序逐个加入堆 <code class="highlighter-rouge">[i, n)</code>，对所有以非叶节点 <code class="highlighter-rouge">i</code> 为根的子树向下调整堆；</li>
      <li>交换堆顶 <code class="highlighter-rouge">a[0]</code> 和（堆底）末尾元素 <code class="highlighter-rouge">a[i = n-1-&gt;1]</code>，堆长度为<code class="highlighter-rouge">[0, i)</code>，已排序序列为  <code class="highlighter-rouge">[i, n)</code>：
        <ol>
          <li>弹出堆顶元素，作为最大值附在无序数组后（有序数组最前）；</li>
          <li>将末尾元素放至根结点，堆长度减一 。</li>
        </ol>
      </li>
      <li>维持剩余堆的性质，<strong>向下调整新堆</strong>（即自顶向下堆化 <code class="highlighter-rouge">heapify</code>，使该子树成为堆）：
        <ol>
          <li>交换非叶结点与左右子结点中的较大值 ；</li>
          <li>交换后可能破坏子堆的结构，沿交换后的子节点向下，交换较大的子节点，直到父结点 <code class="highlighter-rouge">&gt;=</code> 左右子节点（以该结点为根的子树成为堆）为止；</li>
          <li>时间复杂度为 <code class="highlighter-rouge">lgn</code>；</li>
        </ol>
      </li>
      <li>遍历无序数组（堆），直到其中的所有元素都取出为止：
        <ul>
          <li>将堆顶的元素取出，作为次大值，与数组倒数第二位元素交换，并维持剩余堆的性质。</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>性能：<code class="highlighter-rouge">nlgn  O(1)</code></li>
  <li><strong>不稳定</strong>：
    <ol>
      <li>在建堆时，关键字相同的两个记录，按序逐个加入并调整堆，相对位置不变，是稳定的；</li>
      <li>但在堆顶与堆尾交换时，排在后面的元素可能被调整到前面，两个相等的记录（在序列中的）相对位置可能发生改变，是不稳定的。</li>
    </ol>
  </li>
</ul>

<p><img src="assets/heap_sort.gif" alt="图片" style="zoom:50%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void heapSort(int[] nums) {
	// buildMaxHeap(nums)
	for (int i = (n-1)/2; i &gt;= 0; i--) { // not n/2 - 1
		adjustDownHeap(heap, i, n); // 自下而上构建大顶堆[i, n)
	}
	for (int i = n-1; i &gt; 0; i--) { // not n/2-1, not &gt;=
		swap(heap, 0, i); // 交换堆顶和堆底
		adjustDownHeap(heap, 0, i); // 维持剩余堆的性质，将[0,i)调整为大顶堆, not i-1
	}
}

// 自上而下调整大顶堆[root, n)（非递归）while
public static void adjustDownHeap(int[] nums, int root, int n) {
	// while 版
	int child = root*2+1; // 沿root节点较大的子节点向下调整
	while (child &lt; n) {
		// 如果左子结点小于右子结点
		if (child + 1 &lt; n &amp;&amp; nums[child] &lt; nums[child+1]) { // 注意边界child+1
			child ++; // 则取右子结点
		}
		if (nums[root] &gt;= nums[child]) { // not &gt;, 如果堆顶结点最大
			break; // 则调整结束
		} else {
			swap(nums, root, child); // 将大者与父结点交换
			root = child; // 将大者作为root，继续向下(递归)调整
			child = root*2 + 1;
		}
	}
	
	// for not swap版，教科书写法
	int x = nums[root];
	for (int child = 2*root + 1; child &lt; n; child = child*2 + 1) {
		....
		} else {
			nums[root] = nums[child]; // 将大者赋给父结点
			root = child;
		}
	}
	nums[root] = x;	// 将堆顶节点放到最终位置
}

// 自上而下调整大顶堆（递归）
public static void adjustDownHeap(int[] nums, int root, int n) {
	int left = i*2 + 1;
	int right = i*2 + 2;
	if (left &lt; n &amp;&amp; nums[i] &lt; nums[left]) {
		swap(nums, i, left);
		adjustHeap(nums, left, n);
	}
	if (right &lt; n &amp;&amp; nums[i] &lt; nums[right]) {
		swap(nums, i, right);
		adjustHeap(nums, right, n);
	}
}
</code></pre></div></div>

<h4 id="4-2-路归并排序">4. （2-路）归并排序</h4>

<ul>
  <li>基本思想：将序列看作长度为 <code class="highlighter-rouge">1</code> 的 <code class="highlighter-rouge">n</code> 个有序子序列，相邻子序列两两归并，合并为长度为 <code class="highlighter-rouge">2</code> 的有序子序列，直到合并成长度为 <code class="highlighter-rouge">n</code> 的1个有序序列。分治法的典型应用。</li>
  <li>性能：<code class="highlighter-rouge">nlgn O(n)</code>，需额外的内存空间；稳定。</li>
  <li>算法步骤：
    <ol>
      <li>只有一个元素时直接返回，否则将序列分为两个子序列，并<strong>递归</strong>进行归并排序；</li>
      <li>在递归后序位置进行<strong>归并</strong>，可使用返回的递归结果：
        <ol>
          <li>设定两个指针，分别指向两个已排序子序列的起始位置；</li>
          <li>比较两指针所指向的元素，选择相对小的元素放入到归并结果，移动指针到下一位置；直到某一指针达到序列结尾；</li>
          <li>将另一序列剩下的所有元素直接复制到合并序列后。</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>经典例题：
    <ul>
      <li><a href="#同向双指针">88. 合并两个有序数组</a>：拉链法，将双指针初始化在数组的尾部，从后向前进行合并，可避免占用多余空间；</li>
      <li><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">剑指 Offer 25. 合并两个排序的链表</a>：归并法；链表双指针技巧；</li>
      <li><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a>【】</li>
    </ul>
  </li>
</ul>

<p><img src="assets/merge_sort.gif" alt="img" style="zoom:50%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void merge(int[] a, int low, int mid, int high) { // int firstStart, int firstEnd, int secondStart, int secondEnd
    //int[] firstCopy = new int(secondEnd - firstStart + 1);
    //for (int i = s1; i &lt; e2; i++) {
        //c[i] = a[i];
    //}
	// 改进：先将原数组a复制出来，结果可直接放进a
	int[] temp = Arrays.copyOfRange(a, low, high + 1); // [lo, hi+1)
	int i = low; // 第一个数组（左半部分）的指针
	int j = mid + 1; // 第二个数组的指针
	int k = low; // 注意下标不从0开始
	// 已排序数组[low, mid] 和 [mid + 1, high]
	while (i &lt;= mid &amp;&amp; j &lt;= high) { // &amp;&amp;
		if (temp[i] &lt; temp[j]) {
			a[k++] = temp[i++];
		} else {
			a[k++] = temp[j++];
		}
	}
	// 把第一个数组剩余的数移入原数组
    while (i &lt;= mid) { // [lo, mid], not high
    	a[k++] = temp[i++];
    }
	while (j &lt;= high) { // [mid+1, hi]
    	a[k++] = temp[j++];
    }
}

// 在[lo, hi]排序，初始值为[0, n-1]
public static void mergeSort(int[] a, int low, int high) {
	// low == high 时只有一个元素
	if (low &lt; high) { // not n == 1
		int mid = low + (high - low) / 2;
		// 左边
		mergeSort(a, low, mid); // not mid-1, n/2-1);
		mergeSort(a, mid + 1, high); // not mid
		// 左右归并
		merge(a, low, mid, high);
		// System.out.println(Arrays.toString(a));
	}
}
</code></pre></div></div>

<h4 id="5-非比较类的排序">5. 非比较类的排序</h4>

<h5 id="51-计数排序">5.1 计数排序</h5>

<ul>
  <li>
    <p>核心思想：</p>

    <ul>
      <li>将输入的数据值 <code class="highlighter-rouge">A[i]</code> 作为数组<code class="highlighter-rouge">C</code>的下标 <code class="highlighter-rouge">j</code>，即第 <code class="highlighter-rouge">j</code> 个元素是待排序数组 <code class="highlighter-rouge">A</code> 中值等于 <code class="highlighter-rouge">j</code> 的元素的个数；根据 <code class="highlighter-rouge">C</code> 将 <code class="highlighter-rouge">A</code> 中的元素排到正确的位置。</li>
      <li>适用于数据有确定范围、范围很小的<strong>整数</strong>数组，可用在基数排序中、用来排序数据范围更大的数组。</li>
    </ul>
  </li>
  <li>
    <p>算法步骤：</p>

    <ol>
      <li>找出最大和最小的元素；</li>
      <li>创建新数组 <code class="highlighter-rouge">C</code>，长度是<code class="highlighter-rouge">max+1</code>或 <code class="highlighter-rouge">max-min+1</code>，有助于节省新数组占用空间，默认值都为 0；</li>
      <li>遍历原数组 <code class="highlighter-rouge">A</code>，统计每个值为<code class="highlighter-rouge">j</code>的元素（<code class="highlighter-rouge">j = nums[i]</code>或<code class="highlighter-rouge">j = nums[i] - min</code> ）<strong>出现的次数</strong> <code class="highlighter-rouge">cnt</code>，存入<code class="highlighter-rouge"> count[j] = cnt</code>；</li>
      <li>求每个数出现次数 <code class="highlighter-rouge">count</code> 的 <a href="#前缀和">前缀和</a>：对所有的计数累加，新元素的值是该元素与前一个元素值的和，即当 <code class="highlighter-rouge">j&gt;1</code> 时 <code class="highlighter-rouge">preCount[j] = count[j] + preCount[j-1]</code>，此处代码中 <code class="highlighter-rouge">preCount</code> 仍为 <code class="highlighter-rouge">count</code>，表示原地求前缀和；</li>
      <li>创建结果数组 <code class="highlighter-rouge">re</code>，长度和原始数组 <code class="highlighter-rouge">A</code> 一致；</li>
      <li><strong>从后向前</strong>遍历原始数组 <code class="highlighter-rouge">A</code> ，利用前缀和，从右至左计算每个数的排名。反向填充结果数组：将 <code class="highlighter-rouge">nums[i]</code> 放在结果数组 <code class="highlighter-rouge">re</code> 中的<code class="highlighter-rouge">preCount[j]-1</code> 位置，<code class="highlighter-rouge">preCount[j] -= 1</code>。</li>
    </ol>

    <p><img src="assets/counting-sort-1-animate-example.svg" alt="counting sort animate example" style="zoom: 44%;" /><img src="assets/counting_sort.gif" alt="图片" style="zoom:40%;" /></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">n + max</code>； <code class="highlighter-rouge">O(k)</code>，需额外的内存空间；稳定。</p>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static int[] countingSort(int[] nums) {
	if (n &lt; 2) return nums;
	// Arrays.sort(nums);
	int[] extremum = getMinAndMax(nums);
	int min = extremum[0];
	int max = extremum[1];
	// int min = Collections.min(Arrays.asList(nums));
	
	int len = max - min + 1; // 元素大小的极值差，用于减小数组count的大小
	// int count[len+1] = 0;
	int[] count = new int[len+1];
	int[] re = new int[n];

	for (int num : nums) {
		int j = num - min; // 减去极差
		count[j] += 1; // 初始化数组，（1表示值为j的元素有1个），统计值为j的元素个数
	}
	for (int j = 1; j &lt;= len; j++) { // len = count.length - 1
		count[j] += count[j-1]; // 原数组求前缀和，count[j-1]表示偏移量
	}
	for (int i = n - 1; i &gt;= 0; i--) {
		int j = count[i] + min - 1;	// -1，前缀和是为了求元素在最终结果re的索引j
		re[j] = count[i];
		count[i+1] -= 1; // i+1处元素数量-1
	}
	return re;
}

public static int[] getMinAndMax(int[] arr) {
    int maxValue = arr[0];
    int minValue = arr[0];
    for (int i = 0; i &lt; arr.length; i++) {
        if (arr[i] &gt; maxValue) {
            maxValue = arr[i];
        } else if (arr[i] &lt; minValue) {
            minValue = arr[i];
        }
    }
    return new int[] { minValue, maxValue };
}
public static int[] getMinAndMax(List&lt;Integer&gt; arr) {
    int maxValue = arr.get(0);
    int minValue = arr.get(0);
    for (int i : arr) {
        if (i &gt; maxValue) {
            maxValue = i;
        } else if (i &lt; minValue) {
            minValue = i;
        }
    }
    return new int[] { minValue, maxValue };
}
</code></pre></div></div>

<h5 id="52-基数排序">5.2 基数排序</h5>

<ul>
  <li>又称多关键字排序；</li>
  <li>基本思想：（统一正整数长度），（从最低位开始）对元素中的每一位数字进行排序。最早用于解决卡片排序问题 。</li>
  <li>算法步骤：
    <ol>
      <li>取数组中的最大值，计算其位数，作为迭代次数 <code class="highlighter-rouge">N</code>，如：数组中最大值为 1000，则 <code class="highlighter-rouge">N = 4</code>；</li>
      <li>收集：从最低位开始取每位数字放入 <code class="highlighter-rouge">radix</code> 数组；</li>
      <li>（利用计数排序适用于小范围数的特点）对 <code class="highlighter-rouge">radix</code> 进行计数排序；</li>
      <li>将 <code class="highlighter-rouge">radix</code> 依次赋值给原数组；</li>
      <li>重复 2~4 步骤 <code class="highlighter-rouge">N</code> 次。</li>
    </ol>
  </li>
  <li><code class="highlighter-rouge">O(n x k)</code>，<code class="highlighter-rouge">k</code> 为数组中元素的最大的位数；需额外的内存空间； 稳定；</li>
</ul>

<p><img src="assets/radix_sort2.gif" alt="图片" style="zoom:50%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static int[] radixSort(int[] arr) {
    if (arr.length &lt; 2) {
        return arr;
    }
    int maxValue = arr[0];
    for (int element : arr) {
        if (element &gt; maxValue) {
            maxValue = element;
        }
    }
    int N = (int)(Math.log10(maxValue) + 1);
    /*
    int N = 0;
    while (maxValue != 0) {
        maxValue /= 10;
        N += 1;
    }
    */
    
    for (int i = 0; i &lt; N; i++) {
        // 第i位初始化
        List&lt;List&lt;Integer&gt; &gt; radix = new ArrayList&lt;&gt;();
        // 第i位有10种取值
        for (int k = 0; k &lt; 10; k++) {
            radix.add(new ArrayList&lt;Integer&gt;());
        }
        // 收集
        for (int element : arr) {
        	// 取第i位的数字
            int idx = (element / (int)Math.pow(10, i) ) % 10;
            radix.get(idx).add(element);
        }
        // 赋给原数组
        int idx = 0;
        for (List&lt;Integer&gt; list : radix) {
            for (int x : list) {
                arr[idx++] = x;
            }
        }
    }
}
</code></pre></div></div>

<h5 id="53-桶排序">5.3 桶排序</h5>

<ul>
  <li>工作原理：（通过映射函数）将（相同范围内的）数据分到同一桶里，每个桶再分别排序（用其它排序算法或递归用桶排序）。</li>
  <li>适用于待排序数据值域较大、但分布较均匀的情况。</li>
  <li>桶排序是计数排序的升级版。利用了函数的映射关系，高效与否的关键在于映射函数的确定。为了更高效：
    <ol>
      <li>在额外空间充足的情况下，尽量增大桶的数量；</li>
      <li>使用的映射函数能将输入的 <code class="highlighter-rouge">N</code> 个数据均匀的分配到 <code class="highlighter-rouge">K</code> 个桶中；</li>
    </ol>
  </li>
  <li>算法步骤：
    <ol>
      <li><code class="highlighter-rouge">BucketSize</code>：每个桶的容量；</li>
      <li>把数据依次映射到对应的桶里；</li>
      <li>对每个非空桶排序，可用其它排序方法，也可递归用桶排序；</li>
      <li>从非空桶里把排好序的数据，放回原来的序列中。</li>
    </ol>
  </li>
  <li><code class="highlighter-rouge">n+k  n^2^   n+k</code>；<code class="highlighter-rouge"> O(k)</code>，需额外的内存空间；</li>
  <li>如果用稳定的内层排序（由于每块元素不多，一般用插入排序），且插入桶中时不改变元素间的相对顺序，此时稳定。</li>
</ul>

<p><img src="assets/bucket_sort1.png" alt="img" style="zoom:35%;" /><img src="assets/bucket_sort.gif" alt="图片" style="zoom:40%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static List&lt;Integer&gt; bucketSort(List&lt;Integer&gt; arr, int buketSize) {
	int n = arr.length;
	if (n &lt; 2 || buketSize == 0) return arr;
	int[] extremum = getMinAndMax(arr);
	int min = extremum[0];
	int max = extremum[1];
	// 桶个数，向下取整
	int bucketCnt = (int)Math.floor((max-min) / buketSize) + 1;
	
	List&lt;List&lt;Integer&gt; &gt; buckets = new ArrayList&lt;&gt;();
	for (int i = 0; i &lt; bucketCnt; i++) {
		buckets.add(new ArrayList&lt;Integer&gt;()); // 创建桶
	}
	for (Integer el : arr) {
		int j = (el - min)/bucketSize; // idx
		buckets.get(j).add(el);	// 放进桶里
	}
	
	List&lt;Integer&gt; re = new ArrayList&lt;&gt;();
	// int index = 0;
	for (int i = 0; i &lt; buckets.size(); i++) {
		List&lt;Integer&gt; bkt = buckets.get(i);
		if (bkt.size &gt; 1) {
			insertSort(bkt); // 桶内插入排序
		}
		for (Integer k : bkt) {
			re.add(k); // 将排好序的数据，放回原来的序列中
			// index++;
		}
	}
	return re;
}
</code></pre></div></div>

<h4 id="6-外部排序">6. 外部排序</h4>

<p><strong>外归并排序</strong>（External merge sort）：读入一些能放在内存内的数据量，在内存中排序后输出为一个顺串（即内部数据有序的临时文件），处理完所有的数据后再进行归并。如，要对900 MB 的数据进行排序，但机器上只有100 MB的可用内存时，按如下操作：</p>

<ol>
  <li>读入100 MB的数据至内存中，用某种内部排序（如<a href="#快速排序">快速排序</a>、<a href="#堆排序">堆排序</a>、<a href="#归并排序">归并排序</a>等）在内存中完成排序。将排序完成的数据写入磁盘。</li>
  <li>临时文件不用完全载入主存，读入每个临时文件（9个顺串）的前10 MB（ = 100 MB / (9块 + 1)）的数据放入内存中的输入缓冲区；100MB内存剩余的10 MB作为输出缓冲区。</li>
  <li>用 <a href="#第K个元素">PriorityQueue 优先队列实现最小堆（类似合并 K 个升序链表）</a>，执行九路归并算法，将结果输出到输出缓冲区。满了后将数据写出至目标文件，清空缓冲区。</li>
  <li>一旦9个输入缓冲区中的一个变空，就从关联的文件再读入10M数据，直到读完。</li>
</ol>

<h5 id="经典例题-5">经典例题</h5>

<ul>
  <li>第k大：一亿条数据选出其中1000个最大的；
    <ul>
      <li>外部排序 + 堆排序；</li>
    </ul>
  </li>
  <li>内存 1000M、文件 1G、10个出现次数最多的网址；</li>
</ul>

<h3 id="二分查找">二分查找</h3>

<p>基本思想：减而治之（减治）思想，逐渐（减半）缩小问题规模。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Arrays.sort(nums);
int index = Arrays.binarySearch(nums, [0, nums.length,] target); // 必须有序
</code></pre></div></div>

<h5 id="应用场景">应用场景</h5>

<ol>
  <li>有序数组中查找 <code class="highlighter-rouge">target</code> 的下标；用于折半插入排序、二叉查找树等；
    <ul>
      <li>计算满足约束条件 <code class="highlighter-rouge">f(x) == target</code> 时自变量、下标 <code class="highlighter-rouge">x</code> 的值，<code class="highlighter-rouge">x</code>取值范围即搜索区间：</li>
    </ul>
  </li>
  <li>找左、右边界的下标；</li>
  <li>对时间复杂度要求 <code class="highlighter-rouge">logN</code>；</li>
</ol>

<p><img src="assets/left_bound.jpeg" alt="找左边界示意图" style="zoom: 25%;" /></p>

<h5 id="经典例题-6">经典例题</h5>

<ul>
  <li>
    <p><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a>【】</p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在非递减数组中查找元素的第一个和最后一个位置</a></p>

    <ul>
      <li><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a>：找左边界，找不到则插入：如 <code class="highlighter-rouge">nums = [2,3,5,7]</code> 中搜索 <code class="highlighter-rouge">target = 4</code>，搜索左边界的二分算法返回 <code class="highlighter-rouge">2</code>；左边界也可理解为：【】
        <ol>
          <li><code class="highlighter-rouge">nums</code> 中大于等于 <code class="highlighter-rouge">target</code> 的最小元素索引；</li>
          <li><code class="highlighter-rouge">target</code> 应在 <code class="highlighter-rouge">nums</code> 中插入的索引位置；</li>
          <li><code class="highlighter-rouge">nums</code> 中小于 <code class="highlighter-rouge">target</code> 的元素个数。</li>
        </ol>
      </li>
      <li><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中统计一个数字出现的次数</a>：<code class="highlighter-rouge">repeatTime = lastPos - firstPos + 1;</code></li>
    </ul>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a>：</p>

    <ul>
      <li>中位数的定义：
        <ol>
          <li>当 <code class="highlighter-rouge">m1 + m2</code> 是奇数时，是合并数组的第 <code class="highlighter-rouge">(m1 + m2)/2 + 1</code>个元素；</li>
          <li>当 <code class="highlighter-rouge">m1 + m2</code> 是偶数时，是第 <code class="highlighter-rouge">(m1 + m2)/2</code>和第<code class="highlighter-rouge"> (m1 + m2)/2 + 1</code> 个元素的平均值（/2.0）。</li>
        </ol>
      </li>
      <li>中位数对应的两下标之和是已知的 <code class="highlighter-rouge">k = (m1 + m2)/2</code>；</li>
      <li><del>合并，根据奇偶计算，O(m, n)；</del></li>
      <li>不合并，用双指针 + 二分查找的减治思想：<code class="highlighter-rouge">log(m1 + m2)</code>；
        <ul>
          <li>二分查找虚拟合并的数组中第 <code class="highlighter-rouge">k</code> 小的元素：
            <ol>
              <li>分别找出两链表第 <code class="highlighter-rouge">k/2</code> 大的数，对比，小的表明该数组的前 <code class="highlighter-rouge">k/2</code> 个数字都不是第 <code class="highlighter-rouge">k</code> 小数字，可舍弃；</li>
              <li>每次将<code class="highlighter-rouge">k</code>自减<code class="highlighter-rouge">(j-i) + 1</code>长度，指向较小值的指针后移<code class="highlighter-rouge">j + 1</code>位，直到到达中位数的位置（k=1时，返回两数组较小的一个）。如果一个指针已到达数组末尾，则中位数一定在另一数组。</li>
            </ol>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><img src="assets/median-of-two-sorted-arrays1.gif" alt="图片" style="zoom: 52%;" /><img src="assets/median-of-two-sorted-arrays2.gif" alt="图片" style="zoom: 55%;" /></p>

<ul>
  <li>
    <p><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指 Offer 11. 旋转数组的最小数字</a>：把数组最开始的若干个元素搬到末尾，<code class="highlighter-rouge">target</code> &gt; 前面的数字。<code class="highlighter-rouge">[l, r)</code></p>

    <p><img src="assets/whirl_min_binary.png" alt="fig3" style="zoom:20%;" /></p>
  </li>
</ul>

<h5 id="二分查找框架">二分查找框架</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// leftBound()
// searchFistPos()
int binarySearch(int[] nums, int target) {
	int n = nums.length;
    if (n &lt;= 0) return -1;
    int left = 0;
    int right = n-1; // 查找区间为[left, right]，left = right + 1 时搜索区间为空，故while条件为l &lt;= r。推荐。
    // int right = n; // 查找区间为[left, right)，left = right 时搜索区间为空，故while条件为l &lt; r

	// 终止条件是查找区间为[]时，表示在区间里只剩下一个元素时仍需继续查找
    while (left &lt;= right) {
    	// 防溢出，int signed 4byte 32bit ~2^31-1 ~21亿，取left = right = 2^31-2
        int mid = left + (right - left) / 2;
        int num = nums[mid];
        // 若中间值小于目标值
        if (num &lt; target) {
        	// 则左边界向右收缩，搜索区间变为[mid + 1, right]
            left = mid + 1;
        } else if (num &gt; target) {
        	// 右边界向左收缩
            right = mid - 1;
            
            // [left, right)，当 nums[mid] 被检测后，下一步应去 mid 的左侧[left, mid)或右侧区间[mid + 1, right)搜索
            // left = mid + 1; right = mid;
            
        } else if (num == target) {
            // 0.当 nums[mid] == target 时立即返回
            return mid;
            // 1.找左边界时，当中间值和目标值相等时，右边界也需向左收缩，最终达到left锁定左边界的目的。
    		right = mid - 1;
    		// 2.找右边界时，收缩左侧边界
    		left = mid + 1;
        }
    }
    // 0.二分查找，未找到
    return -1;
    
    // 1.找左边界时，检查 left 是否越界、是否未找到目标值（未找到时left == right+1，查找区间为[]）
    if (left &gt;= n || nums[left] != target) return -1;
    return left;
    
    // 2.找右边界时，检查 right 是否越界
    if (right &lt; 0 || nums[right] != target) return -1;
    return right;
}
</code></pre></div></div>

<h3 id="分治与递归">分治与递归</h3>

<h5 id="分治">分治</h5>

<p>分治（Divide and Conquer）：问题分而治之；</p>

<ol>
  <li>分解 ：将（复杂的）原问题分解为结构相同（相似、重叠）的子问题；</li>
  <li>解决（触底）：分解到某个容易求解的边界后，进行递归求解；</li>
  <li>合并（回溯）：将子问题的解合并成原问题的解。</li>
</ol>

<h5 id="递归">递归</h5>

<p>递归 VS 迭代：都是循环中的一种。</p>

<ul>
  <li>
    <p>迭代：函数内某段代码实现循环，与普通循环的区别：将本次循环的输出作为下次循环的输入；循环代码中参与运算的变量同时是保存结果的变量，作为下一次循环的初始值。</p>

    <ol>
      <li>向下调整<strong>堆</strong>，父子节点交换后，子节点成为新的父节点；</li>
      <li>二分查找中用 <code class="highlighter-rouge">mid</code> 更新查找区间 <code class="highlighter-rouge">[left, right]</code>；</li>
      <li>动态规划，状态转移方程中通过做选择从当前状态转移到下一个状态；如，斐波那契数列；</li>
    </ol>
  </li>
  <li>
    <p>递归（Recursion）：重复<strong>调用函数自身</strong>实现循环。还指重复将问题分解为同类的子问题而解决问题的方法。</p>
    <ol>
      <li>递推：把复杂问题的求解<strong>递推</strong>到简单问题的求解；
        <ul>
          <li>画出<strong>递归树</strong>，向下生长直到最简单情况，分析算法的复杂度、寻找算法低效的原因。</li>
        </ul>
      </li>
      <li>递归出口：必须有一个明确的递归结束条件；</li>
      <li>回归：当获得最简单的情况后，逐层返回，依次得到复杂的解。</li>
    </ol>
  </li>
</ul>

<p>缺点是：递归层数过多时，会造成<strong>栈溢出</strong>。</p>

<p>打印递归树：</p>

<p><img src="assets/recursion.jpg" alt="img" style="zoom:50%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 打印缩进和i、j来debug递归
int count = 0;
void printIndent(int n) {
    while (n-- &gt; 0)) {
        System.out.print("\t");
    }
}

int dp(string&amp; ring, int i, string&amp; key, int j) {
    // printIndent(count++);
    // printf("i = %d, j = %d\n", i, j);

    if (j == key.size()) {
        // printIndent(--count);
        // printf("return 0\n");
        return 0;
    }
    
    int res = INT_MAX;
    for (int k : charToIndex[key[j]]) {
        res = min(res, dp(ring, j, key, i + 1));
    }
    
    // printIndent(--count);
    // printf("return %d\n", res);
    return res;
}
</code></pre></div></div>

<h5 id="经典例题-7">经典例题</h5>

<ul>
  <li>二叉树
    <ul>
      <li><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树</a></li>
    </ul>
  </li>
  <li>菲波那切数列</li>
  <li>阶乘</li>
  <li>快速排序</li>
  <li>二分查找</li>
  <li>汉诺塔</li>
</ul>

<h3 id="动态规划">动态规划</h3>

<p>核心思想：如何聪明地<strong>穷举求最值</strong>。本质上是穷举「状态」，做「选择」找最优解。</p>

<h5 id="动态规划三要素">动态规划三要素</h5>

<ol>
  <li>重复子问题：在计算的过程中，有一些问题会重复计算，必须记住结果；若没有重复子问题，可用「分治法」求解。</li>
  <li>最优子结构：子问题间必须互相独立、可同时最优，不能互相影响。如要总分最高，则子问题为语文、数学等分别最高。如果语文、数学成绩互相制约、影响，不能同时达到最高，子问题并不独立，无法同时最优。</li>
  <li>状态转移方程：
    <ol>
      <li>明确 <strong>base case</strong>：直接从<del>最底下、</del>最简单、问题规模最小<del>、已知结果的</del>，开始往上推，直到想要的答案。如 <code class="highlighter-rouge">f(1)</code> 和 <code class="highlighter-rouge">f(2) </code> 推出 <code class="highlighter-rouge">f(20)</code>。</li>
      <li>明确<strong>状态</strong>：记录解决问题到了哪一步，通常是原问题和子问题中随自变量变化的（题目中的）因变量，状态一般作为 <code class="highlighter-rouge">dp</code> 数组的下标/key ；如目标金额 <code class="highlighter-rouge">n</code>。</li>
      <li>做选择：导致状态产生变化的行为，通过<strong>选择</strong>从一个状态转移到另一个状态。如，选择了一枚 1、2、5 元的硬币，从而目标金额 <code class="highlighter-rouge">n</code> 减少了对应的 1、2、5 元。</li>
      <li>定义 <code class="highlighter-rouge">dp</code> 数组/函数的含义：一般 { key / 参数， value / 函数返回值 } = { 状态，题目要求计算的量/做选择的（最少）次数}。如 { 目标金额 <code class="highlighter-rouge">n</code>，凑出 <code class="highlighter-rouge">n</code> 所需的最少硬币数量 / 至少需 <code class="highlighter-rouge">dp[n]</code> 枚硬币凑出}。</li>
      <li><strong>状态转移方程</strong>：对最后一步，可由已知的<strong>状态</strong>，通过<strong>选择</strong>所有情况（1、2、5元），<strong>转移</strong>到目标状态：
        <ul>
          <li>还差1元，dp[n] = dp[n - <strong>1</strong>] + 1;</li>
          <li>还差2元，dp[n] = dp[n - <strong>2</strong>] + 1;</li>
          <li>还差5元，dp[n] = dp[n - <strong>5</strong>] + 1;</li>
        </ul>
      </li>
      <li>循环迭代：一般都脱离了递归，由<strong>循环迭代</strong>计算，自底向上进行递推求解。</li>
      <li>优化递归树，消除<strong>重叠子问题</strong>：通过<strong>递归树</strong>找到<strong>被重复计算的子问题节点</strong>，寻找算法低效的原因。
        <ol>
          <li>通过<strong>剪枝</strong>，消除巨量冗余（重叠子问题），极大减少了子问题的个数。</li>
          <li>分析递归算法的时间复杂度：子问题个数（即递归图中节点总数） X 解决一个子问题需要的时间。
            <ul>
              <li>降低时间复杂度：用空间换时间。</li>
            </ul>
          </li>
          <li>降低空间复杂度：如果每次状态转移只需 DP table 中的一部分，可尝试缩小 DP table 的大小，只记录必要的数据。
            <h5 id="子序列">子序列</h5>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<blockquote>
  <p>子序列！=子串</p>
</blockquote>

<ul>
  <li>
    <p>双字符串动态规划</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a>：
        <ul>
          <li>定义：<code class="highlighter-rouge">dp[i][j]</code> 的含义是 <code class="highlighter-rouge">s1[0..i-1]</code> 和 <code class="highlighter-rouge">s2[0..j-1]</code> 的 LCS 长度；</li>
          <li>目标：<code class="highlighter-rouge">s1[0..m-1]</code> 和 <code class="highlighter-rouge">s2[0..n-1]</code> 的 lcs 长度，即 <code class="highlighter-rouge">dp[m][n]</code>；</li>
          <li><code class="highlighter-rouge">base case</code>: <code class="highlighter-rouge">dp[0][..] = dp[..][0] = 0 </code>；</li>
          <li><a href="https://leetcode.cn/problems/qJnOS7/">剑指 Offer II 095. 最长公共子序列</a>【】</li>
        </ul>
      </li>
      <li><a href="https://leetcode.cn/problems/edit-distance/">72. 最小编辑距离</a>：将 <code class="highlighter-rouge">word1</code> 转成 <code class="highlighter-rouge">word2</code> 所使用的最少操作数 。【】
        <ul>
          <li>定义 <code class="highlighter-rouge">dp</code> 数组：<code class="highlighter-rouge">dp[i-1][j-1]</code> 存储 <code class="highlighter-rouge">s1[0..i]</code> 和 <code class="highlighter-rouge">s2[0..j]</code> 的最小编辑距离。<code class="highlighter-rouge">dp</code> 数组索引至少是 0，所以索引会偏移一位。</li>
        </ul>
      </li>
    </ul>

    <p><img src="assets/lcs.png" alt="img" style="zoom:40%;" /><img src="assets/delete.gif" alt="img" style="zoom:25%;" /></p>

    <p><img src="assets/insert.gif" alt="img" style="zoom:25%;" /><img src="assets/replace.gif" alt="img" style="zoom:25%;" /></p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a>：区间 DP <del>与划分型 DP</del>，在子串 <code class="highlighter-rouge">s[i,j]</code> 中，最长回文子序列的长度为 <code class="highlighter-rouge">dp[i][j]</code>；上一个可能的状态如下图；</p>
  </li>
</ul>

<p><img src="assets/palin_dp.jpg" alt="img" style="zoom: 25%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a>、<a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a>【】
    <ul>
      <li><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>：<code class="highlighter-rouge">dp[i] = Math.max(dp[i], dp[j] + 1)</code></li>
    </ul>
  </li>
</ul>

<h5 id="经典例题-8">经典例题</h5>

<ul>
  <li>
    <p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a>：</p>

    <ul>
      <li>递归：简单，注意 <code class="highlighter-rouge">0、1、2</code> 的情况，但大量的重复计算会导致内存溢出；</li>
      <li><del>带「备忘录」、哈希表的递归算法，「自顶向下」进行递归求解。</del></li>
      <li>由动态规划的 <code class="highlighter-rouge">dp</code> 数组通过消除递归得到迭代（递推）解法：re0、re1交替前进，注意最值取模；</li>
    </ul>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/climbing-stairs/">剑指 Offer 10- II. 青蛙跳台阶、爬楼梯问题</a>：重复子问题【】</p>

    <ul>
      <li>状态：</li>
      <li>（最后一次）选择：还差跳 1 或 2 阶；</li>
      <li>dp 数组：{当前阶数，做的选择数、跳到 n 级台阶的方法个数}；</li>
      <li>状态转移方程：<code class="highlighter-rouge">dp[n] = dp[n-1]*1 + dp[n-2]*1;</code></li>
      <li>本质可理解为斐波那契数列：爬到第 <code class="highlighter-rouge">n</code> 级台阶的方法个数等于爬到 <code class="highlighter-rouge">n - 1</code> 的方法个数和爬到 <code class="highlighter-rouge">n - 2</code> 的方法个数之和。</li>
    </ul>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a>、<a href="https://leetcode.cn/problems/gaM7Ch/">剑指 Offer II 103. 最少的硬币数目</a>：见 <a href="#动态规划算法框架">动态规划算法框架</a>，最优子结构、如何列出状态转移方程【】</p>
  </li>
  <li>
    <p>分割问题：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a>：【】</p>

    <ul>
      <li>先对集合求和，得出 <code class="highlighter-rouge">sum</code>，把问题转化为<strong>背包问题</strong>：背包容量为 <code class="highlighter-rouge">sum / 2</code> 和 <code class="highlighter-rouge">N</code> 个物品，每个物品的重量为 <code class="highlighter-rouge">nums[i]</code>。</li>
      <li><code class="highlighter-rouge">dp</code> 数组的定义：<code class="highlighter-rouge">dp[i][j] = x</code> 表示，对于前 <code class="highlighter-rouge">i</code> 个物品，当前背包的容量为 <code class="highlighter-rouge">j</code> 时，若 <code class="highlighter-rouge">x</code> 为 <code class="highlighter-rouge">true</code>，则说明可恰好将背包装满，若 <code class="highlighter-rouge">x</code> 为 <code class="highlighter-rouge">false</code>，则说明不能恰好将背包装满。</li>
      <li><a href="https://labuladong.github.io/article/wx.html?wx=RXfnhSpVBmVneQjDSUSAVQ">0-1 背包问题</a>：每个物体只有两种可能的状态（取与不取），对应二进制中的 0 和 1【】</li>
      <li><a href="https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/">2279. 装满石头的背包的最大数量</a>【】</li>
    </ul>

    <p><img src="assets/coin_change.jpg" alt="img" style="zoom: 25%;" /></p>
  </li>
  <li>
    <p>各种玩小游戏</p>
  </li>
  <li>
    <p>二维动态规划：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a>、<a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a>：<code class="highlighter-rouge">dp[i][k][0 or 1]</code> 表示从第 i 天的这笔交易中获取的最大利润，0 和 1 代表是否持有股票， <code class="highlighter-rouge">0 &lt;= i &lt; n, 1 &lt;= k &lt;= K</code>，k 为交易次数（大 K 为交易数上限）。</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/maximum-difference-between-increasing-elements/">2016. 增量元素间的最大差值</a>【】</li>
    </ul>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>特化到 k = 1 买入或卖出一次的情况：
状态转移方程：max(今天选择 rest, 今天选择 sell);
  
今天未持有股票，对于昨天来说，有两种可能，从中求最大利润：
1、昨天未持有，今天选择 rest 休息，仍未持有；
2、昨天持有，今天选择 sell，未持有股票。
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
  
今天持有股票，有两种可能，从中求最大利润：
1、昨天就持有股票，今天选择 rest，今天仍持有股票；
2、昨天本没有持有，但今天选择 buy，持有了股票。
dp[i][1] = max(dp[i-1][1], -prices[i]); // 即前一天没有持有股票时、使dp[i-1][0]=0，今天选择买入则利润为-prices[i]
  
base case：
dp[0][0] = 0;
dp[0][1] = -prices[i]; // Integer.MIN_VALUE;负数表示买入
</code></pre></div>    </div>
  </li>
</ul>

<h5 id="动态规划算法框架">动态规划算法框架</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 一、递归（可看做动态规划函数），推荐
int[] dp;
// 返回要凑出金额 amount 至少需要的硬币数
int coinDp(int[] coins, int amount) {
    if (amount &lt; 0) return -1;
    // base case
    if (amount == 0) return 0;
    // 查备忘录，防止重复计算
    if (dp[amount] != dp.length) {
    	return dp[amount];
    }
    
    int res = Integer.MAX_VALUE;
    // 遍历当前状态的所有取值,1、2、5
    for (int coin : coins) {
        // 计算子问题的结果
        int subProblem = coinChange(coins, amount - coin); // amount - coin表示扣除当前面额，还需凑的金额
        // 子问题无解则跳过
        if (subProblem == -1) continue;
        // 在子问题中选择最优解，加1表示当前这枚硬币，面额可能为1、2、5
        res = Math.min(res, subProblem + 1);
    }
    // 未正好凑出金额amount，则返回-1，把计算结果存入备忘录
    dp[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
    return dp[amount];
}

int coinChange(int[] coins, int amount) { // coins表示硬币面额，可取1、2、5
	dp = new int[amount + 1];
	// dp 数组全都初始化为特殊值
	Arrays.fill(dp, amount + 1);
	return dp(coins, amount);
}

// 二、动态规划数组
int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    // dp 数组全都初始化为特殊值，如 amount + 1，数组大小也为 amount + 1，因凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元），永远不可能为 amount + 1;
    // 若初始化为 Integer.MAX_VALUE 的话，dp[i-coin] + 1 会导致整型溢出。
    Arrays.fill(dp, amount + 1);
    
    dp[0] = 0;
    // 遍历所有状态
    for (int i = 0; i &lt; dp.length; i++) {
        // 遍历当前状态的所有取值，1、2、5求所有选择的最小值
        for (int coin : coins) {
            // dp下界溢出，子问题无解，跳过
            if (i - coin &lt; 0) {
                continue;
            }
            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
</code></pre></div></div>

<h3 id="bfs-框架">BFS 框架</h3>

<h5 id="常见场景">常见场景</h5>

<ul>
  <li>本质是在一幅「图或书」中，找到从起点 <code class="highlighter-rouge">start</code> 到终点 <code class="highlighter-rouge">target</code> 的最短距离；</li>
  <li>遍历图（或树）</li>
</ul>

<h5 id="经典例题-9">经典例题</h5>

<ul>
  <li><a href="#最短路径 Dijkstra 算法">最短路径 Dijkstra 算法模板</a>：就是改造版 BFS 算法 + 类似 dp table 的数组。</li>
  <li><a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁的最少步数</a></li>
</ul>

<h5 id="bfs-算法框架">BFS 算法框架</h5>

<p><img src="assets/binary_bfs.jpeg" alt="img" style="zoom: 28%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// BFS 遍历树：计算从起点 start 到终点 target 的最近距离
int BFSTree(Node start, Node target) {
	int step = 0; // 记录扩散的步数
	if (start == null) {
    	return step;
    }
	// 核心数据结构
    Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();
    // 图避免走回头路，一般的二叉树结构没有子节点到父节点的指针，不会走回头路
    Set&lt;Node&gt; visited = new HashSet&lt;&gt;(); 
    
    q.offer(start); // 将起点加入队列
    visited.add(start);

    while (!q.isEmpty()) {
        // 划重点：更新步数，记录层数
        step++;
        int sz = q.size();
        // 将当前队列中的所有节点向四周扩散，遍历一层，按层从左到右遍历树
        for (int i = 0; i &lt; sz; i++) {
            Node cur = q.poll();
            // 判断是否到达终点
            if (cur is target)
                return step;
            // 将 cur 的相邻节点加入队列
            for (Node x : cur.adj()) {
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
        }
    }
    return step;
}
</code></pre></div></div>

<h3 id="dfs-框架回溯">DFS 框架、回溯</h3>

<blockquote>
  <p>分类的稍微有点粗糙了，没有细分出回溯/分治来</p>
</blockquote>

<ul>
  <li>
    <p>回溯算法：实际上就是<strong>多叉决策树</strong>的 DFS 遍历，关键是在前序和后序位置做一些操作。本质是：走不通就回头。</p>
  </li>
  <li>
    <p>DFS 算法：本质上是一种<strong>暴力穷举算法</strong>，为图论中的概念。回溯算法是在遍历树枝，DFS 算法是在遍历节点。</p>
  </li>
</ul>

<h5 id="常见场景-1">常见场景</h5>

<ol>
  <li>遍历图（或树）；
    <ul>
      <li>基于树的 DFS：需要记住递归写前序中序后序遍历二叉树的模板；</li>
      <li>二叉查找树（BST）；</li>
    </ul>
  </li>
  <li>排列组合；</li>
  <li>找出图或树中符合题目要求的全部方案；
    <ul>
      <li>图中（有向无向皆可）的符合某种特征（如最长）的路径及长度；</li>
    </ul>
  </li>
</ol>

<h5 id="经典例题-10">经典例题</h5>

<ul>
  <li><a href="https://leetcode.cn/problems/permutations/">46. 全排列（元素无重不可复选）</a>：回溯框架；
    <ul>
      <li><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II（元素可重可复选）</a>【】</li>
    </ul>
  </li>
</ul>

<p><img src="assets/排列树.jpeg" alt="img" style="zoom: 25%;" /><img src="assets/full_permute.jpg" alt="img" style="zoom: 25%;" /></p>

<ul>
  <li>
    <p><a href="https://labuladong.github.io/algo/4/29/105/">组合/子集问题</a></p>

    <ul>
      <li>通过保证元素间的相对顺序不变来防止出现重复的子集。</li>
      <li>把根节点作为第 0 层，将每个节点和根节点间树枝上的元素作为该节点的值，那么第 <code class="highlighter-rouge">n</code> 层的所有节点就是大小为 <code class="highlighter-rouge">n</code> 的所有子集</li>
      <li><a href="https://leetcode.cn/problems/subsets/">78. 子集（元素无重不可复选）</a>【】</li>
    </ul>

    <p>组合/子集树：</p>

    <p><img src="assets/组合_子集树.jpeg" alt="img" style="zoom:24%;" /></p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a>：空间换时间【】</p>
  </li>
  <li>
    <p><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a>：将二维矩阵抽象成网状的图，每个节点和周围的四个节点连通，用 DFS 算法把遇到的岛屿「淹了」，避免维护 <code class="highlighter-rouge">visited</code> 数组。</p>

    <ul>
      <li><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a>【】</li>
    </ul>
  </li>
</ul>

<h5 id="回溯算法框架">回溯算法框架</h5>

<p>站在<strong>回溯树</strong>的一个节点上，只需思考 3 个问题：</p>

<ol>
  <li>
    <p>路径：已做出的选择；</p>
  </li>
  <li>
    <p>选择列表：当前可做的选择；</p>
  </li>
  <li>
    <p>结束条件：到达决策树底层，无法再做选择时。</p>
  </li>
</ol>

<p><img src="assets/tree_select.jpg" alt="img" style="zoom: 25%;" /><img src="assets/多叉回溯树.jpg" alt="img" style="zoom: 25%;" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;List&lt;Integer&gt; &gt; res = new LinkedList&lt;&gt;();

// 排列
public List&lt;List&lt;Integer&gt; &gt; permute(int[] nums) {
	// 一个排列，记录路径
	LinkedList&lt;Integer&gt; track = new LinedList&lt;&gt;();
	// 标记已走过路径中的元素，避免重复使用
	backtrack(nums, track, used);
	return res;
}

// 回溯
private void backtrack(int[] nums, 路径track, 选择列表) {
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        # 做选择
        将该选择从选择列表移除
    	路径.add(该选择) # 记录路径

        // 核心是递归
        backtrack(路径, 选择列表)

        # 可重复做选择的情况，撤销选择
        路径.remove(选择)
		将该选择再加入选择列表
	
	// 组合
        for (int i = start; i &lt; nums.size(); i++) {
        // 做选择
        track.push_back(nums[i]);
        // 回溯
        backtrack(nums, i + 1, track);
        // 撤销选择
        track.pop_back();
    }
}
</code></pre></div></div>

<h3 id="贪心">贪心</h3>

<p>贪心思路：每一步总是选取最优的操作，只看眼前，不考虑以后可能造成的影响。</p>

<p>每道题都不一样，没有通用解法。在有<strong>最优子结构</strong>的问题中尤为有效。</p>

<p>与动态规划的不同：在于对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，用于对当前进行选择，有回退功能。</p>

<ul>
  <li><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></li>
  <li>数学图像解法：进入站点 <code class="highlighter-rouge">i</code> 可加 <code class="highlighter-rouge">gas[i]</code> 的油（绿色），离开站点会损耗 <code class="highlighter-rouge">cost[i]</code> 的油（红色），那么可把站点和与其相连的路看做一个整体，将 <code class="highlighter-rouge">change[i] = gas[i] - cost[i]</code> 作为经过站点 <code class="highlighter-rouge">i</code> 的油量变化值（橙色）。</li>
  <li>判断环形数组中是否能找到一个起点 <code class="highlighter-rouge">start</code>，使从此开始的<strong>累加和</strong>一直&gt;= 0。累加和的最低点最有可能作为起点。若<code class="highlighter-rouge">sum(gas[i] - cost[i]) &lt; 0</code>，即<code class="highlighter-rouge">sum(gas[...]) &lt; sum(cost[...])</code>，总油量小于总消耗，无法环游所有站点，无解；否则原点即为所求。</li>
</ul>

<p><img src="assets/gas_station.jpeg" alt="img" style="zoom:25%;" />  <img src="assets/gas_station3.jpeg" alt="img" style="zoom: 25%;" /></p>

<ul>
  <li>
    <p><del>贪心解法</del>：如果从 <code class="highlighter-rouge">i</code> 出发无法走到 <code class="highlighter-rouge">j</code>，那么 <code class="highlighter-rouge">i</code> 及 <code class="highlighter-rouge">i, j</code> 间的所有站点都不可能作为起点。</p>
  </li>
  <li><a href="#KMP 字符串~~模式~~匹配算法">KMP 字符串匹配算法</a></li>
  <li><a href="#最小生成树 Kruskal 算法">最小生成树 Kruskal 算法</a></li>
  <li><a href="#树">哈夫曼编码</a></li>
</ul>

<h3 id="位运算">位运算</h3>

<ul>
  <li><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a>：异或<code class="highlighter-rouge">^</code>【】</li>
</ul>

<p><img src="assets/8720h.gif" alt="img" style="zoom: 33%;" /></p>

<ul>
  <li><a href="https://leetcode.cn/problems/missing-number/">268. 丢失的数字</a> 【】
    <ol>
      <li>异或法</li>
      <li>求和法</li>
    </ol>
  </li>
</ul>

<h3 id="缓存淘汰算法">缓存淘汰算法</h3>

<h4 id="lru-算法">LRU 算法</h4>

<p>Least Recently Used，按访问顺序、优先删除最久未使用的数据。</p>

<p>核心数据结构：哈希链表 <code class="highlighter-rouge">LinkedHashMap</code>（<strong>双向链表</strong>和哈希表的结合体）</p>

<ul>
  <li>链表的有序性使元素维持插入顺序；每次默认从链表尾部添加元素，显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。
    <ul>
      <li>双向链表：删除链表节点要得到前驱节点的指针，而双向链表支持直接查找前驱， O(1)。</li>
    </ul>
  </li>
  <li>
    <p>哈希映射的快速访问能力、可在 <code class="highlighter-rouge">O(1)</code> 时间访问链表的任意元素。定位到链表中的节点，从而取得对应 <code class="highlighter-rouge">val</code>、插入和删除。</p>
  </li>
  <li><a href="https://leetcode.cn/problems/lru-cache/">146. 设计LRU 缓存的数据结构并实现 get()、put()</a></li>
</ul>

<p><img src="assets/linked_hashmap.jpg" alt="img" style="zoom: 35%;" /><img src="assets/90896.gif" alt="img" style="zoom:43%;" /></p>

<h4 id="lfu-算法">LFU 算法</h4>

<p>按访问频率来淘汰，用一个 <code class="highlighter-rouge">HashMap</code> 存储访问频率。</p>

<ul>
  <li><a href="https://leetcode.cn/problems/OrIXps/">剑指 Offer II 031. 最近最少使用缓存</a>【】</li>
</ul>
