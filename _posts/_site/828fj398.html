<blockquote>
  <p>摘要：Java高级之JVM虚拟机，包括类加载机制，创建对象，内存分配机制，GC垃圾回收，JVM调优等。</p>
</blockquote>

<!-- more -->

<h2 id="jvm-虚拟机">JVM 虚拟机</h2>

<h3 id="main-方法的执行步骤">main() 方法的执行步骤</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Student stu = new Student("Tom");
stu.sayName();
</code></pre></div></div>

<p><img src="assets/stack_heap_method_area.jpg" alt="img" style="zoom:70%;" /></p>

<p>1）字节码执行机制：</p>

<ul>
  <li>编译 App.java 得到 App.class。</li>
</ul>

<p>2）类加载机制：</p>

<ol>
  <li><strong>加载 App 类</strong>：系统启动一个 JVM 进程，从 classpath 路径中查找 App.class，将 App 的类信息加载到方法区；</li>
  <li>找到 App 类中的主程序入口，执行 <strong>main()</strong>；</li>
  <li>检查是否已<strong>加载 Student 类</strong>：（在常量池中）定位<strong>类的符号引用</strong>；</li>
  <li>若无则加载 Student 类：加载类信息到方法区。</li>
</ol>

<p>3）new 创建 student 对象：</p>

<ol>
  <li>在局部变量表创建变量 <code class="highlighter-rouge">stu</code>，字面量<code class="highlighter-rouge">"Tom"</code>放在方法区；</li>
  <li><strong>内存分配机制（GC）</strong>：在（堆中）为 Student 对象分配内存，并将对象引用赋给变量 stu；</li>
  <li>构造器<strong>初始化</strong> Student 对象，（有<strong>指向方法区中 Student 类的类型信息</strong>的引用）；</li>
  <li>根据 stu 引用找到 Student 对象，获取 <code class="highlighter-rouge">sayName()</code> 的字节码地址，执行 <code class="highlighter-rouge">sayName()</code>。</li>
</ol>

<h3 id="字节码执行机制">字节码执行机制</h3>

<p>字节码：JVM 可理解的代码（即扩展名为 .class 的文件）。</p>

<h5 id="编译与解释共存">编译与解释共存</h5>

<ol>
  <li>既有编译型语言的特征，也有解释型语言的特征：先编译生成字节码文件，编译后不直接运行，而是通过解释运行。</li>
  <li>JIT （just-in-time compilation） 即时编译器： 属于运行时编译。完成第一次编译后，将（热点代码的）字节码对应的机器码保存下来，下次可直接用。</li>
</ol>

<p>JVM VS 传统解释型语言：</p>

<ol>
  <li>保留优点：可移植；</li>
  <li>一定程度上解决缺点：执行效率低。</li>
</ol>

<p><img src="assets/class_file_compile_explain.png" alt="在这里插入图片描述" style="zoom: 45%;" /></p>

<h5 id="java-程序运行过程">Java 程序运行过程</h5>

<ul>
  <li><code class="highlighter-rouge">-&gt;源文件(.java）</code></li>
  <li><strong>编译</strong>：<code class="highlighter-rouge">-&gt;Javac 编译器-&gt;Java字节码文件（.class）</code></li>
  <li><code class="highlighter-rouge">-&gt;JVM-&gt;（特定系统可执行的二进制）机器码</code>
    <ul>
      <li><code class="highlighter-rouge">-&gt;Class Loader 加载.class文件</code></li>
      <li><strong>解释</strong>：<code class="highlighter-rouge">-&gt;Execution Engine 通过解释器逐行解释执行，执行速度相对较慢</code></li>
      <li><code class="highlighter-rouge">-&gt;Runtime Data Area（运行时数据区，即常说的JVM内存）</code></li>
    </ul>
  </li>
</ul>

<h3 id="类加载机制">类加载机制</h3>

<p>ClassLoader：用来加载 Class，负责将 Class 的字节码形式转换成内存形式的 Class 对象。</p>

<h5 id="类加载步骤">类加载步骤</h5>

<p>根据（常量池中的）动态链接定位<strong>类的符号引用</strong>，检查当前类是否已被加载：</p>
<ol>
  <li>已被加载的类直接返回；</li>
  <li>否则尝试加载类。</li>
</ol>

<p><strong>加莲厌准姐初</strong></p>

<p><img src="assets/class_load_step.png" alt="img" /></p>

<ul>
  <li>加载：
    <ol>
      <li>根据类名查找 .class 文件，将 class 文件加载到内存；</li>
      <li>将静态存储结构转换成（方法区中的）运行时数据结构；</li>
      <li>在（堆）内存中生成类的 Class 类对象，作为方法区数据的访问入口；</li>
    </ol>
  </li>
  <li>连接：
    <ol>
      <li>验证：确保文件格式、字节码结构等符合 JVM 安全规范；</li>
      <li>准备：为 static 变量（在堆中）分配内存，并设置0值；</li>
      <li>解析：将（常量池内的）符号引用替换为直接引用；</li>
    </ol>
  </li>
  <li>初始化：执行构造器，初始化实例成员变量和真正初始化 static 成员变量。</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static int i =3 ;
//第一次初始化后i的值为0，
//第二次初始化后值才为3.
</code></pre></div></div>

<ul>
  <li>
    <p>使用：一旦某个类的 Class 对象被载入内存，.class文件就被用来创建这个类的所有（实例）对象。</p>
  </li>
  <li>
    <p>卸载：GC将无用类从内存中卸载。</p>
  </li>
</ul>

<h5 id="双亲委派模型">双亲委派模型</h5>

<p>工作过程：类加载器收到类加载请求后，</p>

<ol>
  <li>首先判断当前类是否被加载过，已被加载的类会直接返回；</li>
  <li>
    <p>若未被加载（加载未知类时）：</p>

    <ul>
      <li>自底向上委派：首先委派给父类加载器，递归执行1；</li>
      <li>自顶向下查找：当父类加载器无法处理时，才由自己来处理；</li>
    </ul>
  </li>
  <li>如果都没有加载此类，则抛出 ClassNotFoundException 异常。</li>
</ol>

<p>检查顺序：<code class="highlighter-rouge">CustomClassLoader -&gt; AppClassLoader -&gt; ExtensionClassLoader -&gt; BootstrapClassLoader</code></p>

<p>不同层次的类加载器有不同优先级：</p>

<ul>
  <li>=&gt;可避免重复加载类；</li>
  <li>=&gt;保证核心 API 不被修改。</li>
</ul>

<h5 id="tomcat-与双亲委派模型">Tomcat 与双亲委派模型</h5>

<ul>
  <li>不能用默认的类加载机制：
    <ol>
      <li>一个web容器可能部署两个应用程序，可能会依赖同一个第三方类库的不同版本；默认的 ClassLoader 无法加载相同类库的不同版本。</li>
      <li>同一个web容器中相同的类库相同的版本可共享；符合双亲委派。</li>
      <li>web容器自己依赖的类库（tomcat lib目录下），不能与应用程序的类库混淆；同第一条。</li>
      <li><del>web容器要支持jsp文件的热加载。</del></li>
    </ol>
  </li>
  <li>Tomcat 未完全违反双亲委派机制，核心的 Java 加载仍遵从双亲委派：
    <ul>
      <li>Tomcat 中各个web应用自己的类加载器（WebAppClassLoader）会优先加载，打破了双亲委派机制，加载不到时再交给 commonClassLoader 走双亲委托 。</li>
    </ul>
  </li>
  <li>Tomcat 独特的类加载机制：
    <ul>
      <li>Bootstrap 引导类加载器：加载 JVM 启动所需的类，以及标准扩展类（位于jre/lib/ext下）；</li>
      <li>System 系统类加载器：加载 Tomcat 启动的类，如 bootstrap.jar，<del>通常在 catalina.bat 或catalina.sh中指定。位于CATALINA_HOME/bin下。</del></li>
      <li>Common 通用类加载器：加载 Tomcat 依赖包、应用通用的一些类，在CATALINA_HOME/lib下，如：servlet-api.jar。</li>
      <li>webapp 应用类加载器：每个应用在部署后，都会创建一个唯一的类加载器。加载 <code class="highlighter-rouge">WEB-INF/classes</code>下应用自定义的的类和 <code class="highlighter-rouge">WEB-INF/lib</code>下的jar应用依赖包中的类。</li>
    </ul>
  </li>
</ul>

<p><img src="assets/tomcat_parent.png" alt="img" style="zoom:45%;" /></p>

<p>详解：<a href="https://cloud.tencent.com/developer/article/1862861">Tomcat - 都说Tomcat违背了双亲委派机制，到底对不对？</a>、<del><a href="https://www.cnblogs.com/aspirant/p/8991830.html">图解Tomcat类加载机制(阿里面试题)</a></del></p>

<h5 id="常用类加载器">常用类加载器</h5>

<p>ClassLoader：用来动态加载（按需加载）.class 字节码文件到 JVM 内存（=&gt; 内存形式的 Class 对象）</p>

<ol>
  <li>Bootstrap ClassLoader：最顶层的启动类加载器，由 C++实现，随 JVM 启动，负责加载 JDK 中的核心类库（<code class="highlighter-rouge">%JAVA_HOME%/lib</code>目录下的 jar 包和类）、构造其它 ClassLoader；</li>
  <li>Extension ClassLoader：负责加载 JVM 扩展类库（ <code class="highlighter-rouge">%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，通常以 javax 开头）；</li>
  <li>Application ClassLoader：面向用户的加载器，负责加载当前 classpath 路径下的 jar 包和类。</li>
  <li>UserDefinedClassLoader：</li>
</ol>

<p>JVM搜索类时判断两个class是相同的，要同时满足：</p>
<ol>
  <li>两个类名相同（同一份class字节码）；</li>
  <li>由同一个类加载器加载。</li>
</ol>

<p>对于<code class="highlighter-rouge">equals()、isinstanceof()</code>等方法来判断对象相等或所属关系都是需要基于同一个ClassLoader。</p>

<h5 id="通过类创建对象">通过类创建对象</h5>

<p><strong>类的实例化/创建对象的顺序：</strong></p>

<ul>
  <li>先静态、先父后子；</li>
  <li>按在代码中出现的顺序依次执行；</li>
</ul>

<p>按需加载类：</p>

<ol>
  <li>初始化父类静态成员变量、静态初始化块/静态代码块（只执行一次）：static成员变量和static语句块的执行顺序同代码中的顺序一致；</li>
  <li>子类静态成员、静态初始化块；</li>
</ol>

<p>创建对象：</p>

<ol>
  <li>初始化对象父类的实例成员变量，执行实例初始化块；</li>
  <li>父类构造器；</li>
  <li>初始化子类实例成员变量，执行实例初始化块；</li>
  <li>子类构造器；</li>
  <li>普通代码块；</li>
</ol>

<p><strong>创建对象的步骤</strong>：</p>

<ol>
  <li>类加载：JVM遇到一条 new 指令时，执行类加载，完成后可确定所需内存大小；</li>
  <li>（为新对象在堆中）分配内存（若内存不够则先执行<a href="#回收策略">GC</a>）；</li>
  <li>将成员变量初始化为0值；</li>
  <li><strong>设置对象头</strong>；</li>
  <li><strong>执行 init 方法</strong>：初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址（引用）赋值给（vm栈中的）变量。</li>
</ol>

<p><strong>对象在堆内存的存储布局</strong>：</p>

<ol>
  <li>对象头：
    <ul>
      <li>MarkWord：存储哈希码、分代年龄、（锁状态标志位、）线程持有的（轻/重量级）锁、偏向锁线程ID等信息。</li>
      <li>存储类型指针：指向类的元数据指针，确定对象是属于哪个类的实例。数组长度。</li>
    </ul>
  </li>
  <li>
    <p>实例数据：存储代码中所定义的各种类型的字段信息。</p>
  </li>
  <li>对齐填充：起占位作用。HotSpot 要求对象的起始地址必须是8的整数倍。。</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String str = new String("hello");
// 变量str放在VM栈上的局部变量表中
// 用new创建出来的String对象放在堆中
// 而"hello"这个字面量放在方法区的运行时常量池
</code></pre></div></div>

<h3 id="jvm-内存分配机制">JVM 内存分配机制</h3>

<p><img src="assets/JVM内存分配.png" style="zoom: 50%;" /></p>

<p>自动内存管理：最核心的是堆内存中对象的分配与回收。</p>

<h4 id="运行时数据区">运行时数据区</h4>

<p>每个进程分配一块 JVM 运行时数据区（RunTime Data Area）/ 内存空间，分为两种类型：</p>

<ol>
  <li>线程私有：生命周期与线程相同，依赖用户线程（而创建/销毁）；包括程序计数器、虚拟机栈、本地方法栈；</li>
  <li>所有线程共享：生命周期与 JVM 相同，随 JVM 的启动/关闭（而创建/销毁）；包括堆、方法区。</li>
</ol>

<p>栈负责执行方法（运行代码），存放局部变量；堆负责存储数据（对象等）。</p>

<h5 id="pc-程序计数器">PC 程序计数器</h5>

<p>表示当前线程（所执行字节码）的行号指示器，由字节码执行引擎负责修改；字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制：</p>

<ul>
  <li>Java 方法中：存储的是（下一条）字节码指令（在方法区）的地址。记录当前线程执行的位置，保证线程切换回来后能恢复到正确的执行位置。</li>
  <li>native 方法中：undefined。</li>
</ul>

<p>唯一没有OOM（内存溢出）和 StackOverflowError 的内存区域。</p>

<h5 id="虚拟机栈">虚拟机栈</h5>

<p>是描述 Java 方法执行的内存模型；每个 Java 方法在执行时会创建一个栈帧，方法从开始调用到执行完成，就是栈帧从入栈到出栈的过程。用于存储：</p>

<ol>
  <li>局部变量表：存放编译期可知的数据类型（如方法参数和局部变量）：
    <ul>
      <li>对于基本数据类型的变量，直接存值；
        <ul>
          <li>对于引用类型的变量，存的是指向对象的引用。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>操作数栈：压栈和出栈操作，弹出数据、执行运算、结果压栈；</li>
  <li>动态链接：指向运行时常量池的（当前）方法（的）引用；部分方法在编译期无法确定，只能在程序运行期间将调用方法的<strong>符号引用</strong>转换为直接引用。</li>
  <li>方法出口（返回地址）等。</li>
</ol>

<p>易出的错误：</p>

<ul>
  <li>StackOverFlowError（VM栈的内存大小不允许动态扩展）：栈帧中的局部变量过多时（常出现在递归、循环调用中）=&gt; 线程请求栈的深度<code class="highlighter-rouge">&gt;</code>当前VM栈的最大深度；</li>
  <li>OutOfMemoryError（VM栈的内存大小允许动态扩展）：堆中没有空闲内存，且GC也无法提供更多内存 =&gt; 无法申请到内存时抛出；</li>
</ul>

<h5 id="本地方法栈">本地方法栈</h5>

<p>为VM用到的 Native 方法服务，其它与VM栈一致。在 HotSpot VM 中和 Java 虚拟机栈合二为一。</p>

<h5 id="堆">堆</h5>

<p>存储对象本身（由 new 和构造器创建）及数组本身，但引用在VM栈的局部变量表中；是 JVM 所管理的内存中最大的一块，在 JVM 中只有一个堆，GC 主要管理的对象；</p>

<ul>
  <li>内存空间/物理上可不连续，但逻辑上应连续；</li>
  <li>JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中；
    <ul>
      <li>字符串常量池：保存 String 对象实例本身，供运行时常量池引用；</li>
      <li>静态变量</li>
    </ul>
  </li>
  <li>分为：
    <ul>
      <li>新生代：Eden 伊甸区、Surviveor From（S0）、Surviveor To（S1）；</li>
      <li>老年代</li>
    </ul>
  </li>
  <li>JDK1.8 前，HotSopt 虚拟机的方法区又被称为永久代；</li>
</ul>

<p><img src="assets/heap_structure.png" alt="img" style="zoom: 67%;" /></p>

<p>易出的错误：</p>

<ul>
  <li>OutOfMemoryError: GC Overhead Limit Exceeded:：GC上限超出，GC 时间长，但只回收了很少的堆内存；</li>
  <li>OutOfMemoryError: Java heap space：堆内存不足以存放新创建的对象；</li>
</ul>

<h4 id="本地内存">本地内存</h4>

<p>（JDK1.7 及以前）HotSpot 用永久代（PermGen）实现方法区，习惯上把方法区称为永久代：</p>

<ul>
  <li>运行时常量池：
    <ul>
      <li>字符串常量池：JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中；</li>
      <li>剩余部分。</li>
    </ul>
  </li>
</ul>

<p>JDK1.8：取消永久代，用 Metaspace 元空间实现方法区；实际位于本地内存中。</p>

<p><img src="assets/method_area.png" alt="img" style="zoom:50%;" /></p>

<h5 id="方法区">方法区</h5>

<p>《深入理解 Java 虚拟机》书中，方法区（Method Area）用于存储已被虚拟机加载的：</p>

<ol>
  <li>类信息；</li>
  <li>常量；</li>
  <li>静态变量；</li>
  <li>即时编译器编译后的代码（缓存）等。</li>
</ol>

<p>方法区用于存储虚拟机加载的字节码文件。</p>

<p>（根据 <code class="highlighter-rouge">jclasslib Bytecode viewer</code> 反编译插件解析的）.class 字节码文件包括：</p>

<ol>
  <li>一般信息：
    <ol>
      <li>魔数：字节码文件的标志，确定此文件能否被虚拟机接收，是一个固定值 <code class="highlighter-rouge">0XCAFEBABE</code>；</li>
      <li>主版本号（如表示 JDK1.8）和次版本号；</li>
      <li>访问标志（修饰符）：用于识别类或接口层次的访问信息，包括：是类还是接口，是否为 public 或 abstract 类型，是否声明为 final 等；</li>
      <li>本类索引、父类索引：用于确定当前类和父类的全限定名；指向常量池。</li>
    </ol>
  </li>
  <li>静态常量池（表）=&gt;加载到运行时常量池；主要存放两类常量：
    <ul>
      <li>字面量：
        <ul>
          <li>文本字符串 <code class="highlighter-rouge">"hello"</code>=&gt;加载进字符串常量池；JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中；</li>
          <li><code class="highlighter-rouge">final</code> 常量值、基本数据类型的值15等；</li>
        </ul>
      </li>
      <li>和（类的）符号引用：1. 类和接口的全限定名、2. 字段名和描述符、3. 方法名和描述符。
        <ul>
          <li>类加载时，部分符号引用会替换为直接引用，如类的静态方法、私有方法，构造方法，父类方法（因为这些方法不能被重写），而其他方法在第一次调用时才转变。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>接口（索引集合）：用来描述类实现的接口；指向常量池。</li>
  <li>字段（表集合）：（接口或类中声明的）<strong>静态变量</strong>和实例变量（方法内声明的参数和局部变量在局部变量表中）。=&gt; JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中。</li>
  <li>方法（表集合）：描述方法的定义部分，包括访问修饰符、返回类型、方法名等。</li>
  <li>属性（表集合）：方法的代码实现 =&gt; JIT 即时编译器编译后的代码（缓存）。</li>
</ol>

<p>HotSpot 把 GC 分代收集扩展至方法区, 即用堆的永久代来实现方法区；</p>

<p>对方法区内存回收的主要目标是：对常量池的回收和对类的卸载。</p>

<p>易出的错误：</p>

<ul>
  <li>OutOfMemoryError</li>
</ul>

<h5 id="直接内存堆外内存">直接内存/堆外内存</h5>

<p>由OS管理；JDK 1.4 引入的 <strong>NIO</strong> 提供了基于Channel与 Buffer的IO方式，可用 Native 函数库直接分配堆外内存, 用 DirectByteBuffer 对象作为这块内存的引用进行操作, 避免了在 Java堆和 Native 堆中来回复制数据。</p>

<h3 id="gc-垃圾回收">GC 垃圾回收</h3>

<h5 id="引用类型">引用类型</h5>

<ol>
  <li>强引用：当内存不足时，JVM 宁可出现 OOM 也不回收，和 GC Roots 断绝关系时才回收（如显式地将引用置为 <code class="highlighter-rouge">null</code>）；常用于普通的对象引用关系，如 <code class="highlighter-rouge">String s = new String("Const")</code>；</li>
  <li><strong>软引用</strong>：当内存不足时回收，如果回收后仍内存不足，抛出内存溢出异常；由 <code class="highlighter-rouge">SoftReference</code> 类创建；用于维护一些可有可无的对象，常用于高速缓存中，如 mybatis、浏览器的后退按钮；</li>
  <li>弱引用：下一次GC时回收，由 <code class="highlighter-rouge">WeakReference</code> 类创建；</li>
  <li>虚引用：跟没有一样，形同虚设。</li>
</ol>

<h5 id="如何判断可被回收--回收时机">如何判断可被回收 / 回收时机</h5>

<p>1）废弃常量（被运行时常量池回收）：没有被任何对象引用。</p>

<p>2）无用类（被方法区卸载/回收）：需同时满足</p>

<ol>
  <li>类的所有实例都已被回收；</li>
  <li>加载类的 ClassLoader 已被回收；</li>
  <li>类对应的 Class 对象没有任何引用，无法通过反射访问该类的方法。</li>
</ol>

<p>3）已死亡对象（被堆回收）：</p>

<ul>
  <li>没被引用的/超过作用域的对象；</li>
  <li>（强）引用被置为null（变为弱引用），在下一次GC回收；</li>
</ul>

<p>方法：</p>

<ul>
  <li><del>引用计数器法</del>：一个对象没有任何关联引用时回收；无法解决<strong>对象循环引用</strong>；</li>
  <li>可达性分析法：将GC Roots对象作为起始的存活对象集，向下<strong>搜索</strong>走过的路径（<strong>引用链</strong>/可达路径），
    <ol>
      <li>把能被该集合引用的对象递归加入到集合中（移动到S0）；</li>
      <li>不能被引用（即对象到GC Roots没有任何引用链/该对象是不可达的）；二次标记后还没成功逃脱，只能被回收。</li>
    </ol>
  </li>
</ul>

<p>可作为GC Roots的对象：</p>
<ol>
  <li>虚拟机栈（局部变量表）中引用的对象，如方法参数、局部变量、临时变量等；</li>
  <li>本地方法栈中 <code class="highlighter-rouge">JNI</code> 引用的对象；</li>
  <li>（堆中）类的静态变量引用的对象；</li>
  <li>（方法区中）<a href="#方法区">运行时常量池</a>引用的对象。</li>
  <li>JVM 内部的引用，如基本数据类型的 Class 对象，系统类加载器等。</li>
</ol>

<h5 id="回收算法">回收算法</h5>

<ol>
  <li>堆内存不规整 =&gt; Mark-Sweep（标记-清除）算法：维护<strong>空闲列表</strong>，记录可用内存，标记结束后统一回收；易产生内存碎片；</li>
  <li>Copying（复制）算法：将可用内存按容量划分为大小相等的两块，当一块内存用完后，将存活的对象移动到另一块，交换指针，清理已用内存；可用内存减为原来的一半，如果存活对象很多，效率会降低；</li>
  <li>堆内存规整（没有内存碎片） =&gt; Mark-Compact（标记-整理）算法：指针碰撞，将存活对象都向一端移动，清除边界外的；
    <h5 id="分代回收策略">分代回收策略</h5>
  </li>
</ol>

<p>核心思想是根据<strong>对象存活的生命周期</strong>将内存划分为若干个区域。JDK1.8 后：</p>

<p><img src="assets/generation_gc.png" alt="img" style="zoom: 67%;" /></p>

<ol>
  <li>新生代：复制算法，分为一块较大的 Eden 伊甸空间和两块较小的 <code class="highlighter-rouge">From Survivor0</code> 和 <code class="highlighter-rouge">To Survivor1</code> 空间（8：1：1）；
    <ul>
      <li>对象优先分配在 Eden；</li>
      <li>Eden 满，触发一次 <code class="highlighter-rouge">Minor/Young 新生代 GC</code>，将存活对象移动到 <code class="highlighter-rouge">S0</code>，年龄默认为1；</li>
      <li>S0 满，触发第二次<code class="highlighter-rouge">Minor/Young GC</code>，将存活对象移动到 <code class="highlighter-rouge">S1</code>，年龄+1；</li>
    </ul>
  </li>
  <li>老年代：标记-清除或标记-整理算法
    <ul>
      <li>长期存活的对象（<code class="highlighter-rouge">S1</code>中年龄增加到一定阈值如 15）或 <code class="highlighter-rouge">S1</code> 被填满，会被移动到老年代；</li>
      <li>大对象（需大量连续存储空间，最常见的是大数组）直接分配到老年代；</li>
      <li>老年代满触发<code class="highlighter-rouge">Full GC</code> ，清理新生代、老年代、方法区，仍无法存储对象则抛出OOM。
        <ul>
          <li>一般 Full GC 等价于  <code class="highlighter-rouge">Major/Old 老年代 GC</code>，对老年代 GC。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>元空间（永久代）不在GC范围内。</li>
</ol>

<h5 id="常见的垃圾回收器">常见的垃圾回收器</h5>

<ol>
  <li>Serial 串行收集器：单线程，工作时必须暂停其他所有的工作线程，直到它收集结束。新生代用复制算法，老年代用标记-整理算法。简单高效。</li>
  <li>ParNew 收集器：Serial 收集器的多线程版本。</li>
  <li>Parallel Scavenge 并行收集器：注重吞吐量（高效率的利用 CPU）。</li>
  <li>CMS 垃圾收集器：并发，以获取最短回收停顿时间为目标；
    <ol>
      <li>初始标记：暂停其他线程，标记与GC roots直接关联的对象；</li>
      <li>并发标记：可达性分析过程；</li>
      <li>重新标记/并发预处理：查找执行并发标记阶段从年轻代晋升到老年代的对象，重新标记，暂停虚拟机，扫描CMS堆中剩余对象；</li>
      <li>并发清除：清理垃圾对象；</li>
      <li>并发重置：重置CMS收集器的数据结构。</li>
    </ol>
  </li>
  <li>G1 垃圾收集器：面向多CPU及大容量内存的服务器，相比于 CMS 的改进：
    <ul>
      <li>把堆划分成多个大小相等的独立区域（Region），可单独进行垃圾回收；</li>
      <li>基于标记-整理算法，不产生内存碎片；</li>
      <li>精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li>
      <li>步骤：
        <ol>
          <li>初始标记</li>
          <li>并发标记</li>
          <li>最终标记：对并发标记过程中，用户线程修改的对象再次标记一下。</li>
          <li>筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间制定回收计划并回收。</li>
        </ol>
      </li>
    </ul>
  </li>
</ol>

<h5 id="内存参数设置和内存调优">内存参数设置和内存调优</h5>

<p>在 JVM 的启动参数中加入：</p>

<ul>
  <li><code class="highlighter-rouge">-Xms/-Xmx</code>：设置堆的最小/最大容量；
    <ul>
      <li>在线上生产环境，二者设置相同的内存容量，避免在 GC 后调整堆大小带来的压力；</li>
      <li>等价于<code class="highlighter-rouge">-XX:InitialHeapSize/-XX:MaxHeapSize</code>；</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">-Xmn</code>：新生代大小；扣除新生代剩下的就是老年代大小；
    <ul>
      <li>等价于<code class="highlighter-rouge">-XX:MaxNewSize</code>；</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">-Xss</code>：线程栈大小；</li>
  <li><code class="highlighter-rouge">-XX:NewSize/MaxNewSize</code>：新生代最小/最大值；</li>
  <li><code class="highlighter-rouge">-XX:MetaspaceSize/-XX:MaxMetaspaceSize</code>：指定元空间大小和最大值（超过最大值时，将进行死亡类及类加载器的垃圾回收），默认为21M和-1（即没有限制）。
    <ul>
      <li>JDK1.8 前用<code class="highlighter-rouge">-XX:PermSize/MaxPermSize</code>。</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">-XX:SurvivorRatio</code>：新生代 Eden 区 / Survivor 区，默认为 8，即 8<strong>:</strong>1<strong>:</strong>1。</li>
</ul>

<p>命令行启动时按如下格式设置：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java -jar -Xms1G -Xmx1G -Xmn512M -Xss1M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M app.jar
</code></pre></div></div>

<h5 id="查看-gc-日志">查看 GC 日志</h5>

<ul>
  <li><a href="https://www.cnblogs.com/chiangchou/p/jvm-2.html#_label3_1">2、查看GC日志</a></li>
</ul>

<h3 id="jvm-调优">JVM 调优</h3>

<h5 id="jvm-内存溢出">JVM 内存溢出</h5>

<ul>
  <li>内存溢出（OutOfMemory）：申请不到；指程序在申请内存时，没有足够的内存空间供其使用。</li>
  <li>内存泄露（Memory Leak）：释放不了；指程序在申请内存后，无法释放已申请的内存空间；最终将导致内存溢出。</li>
</ul>

<p>内存溢出的原因：</p>

<ol>
  <li>内存泄露导致堆、栈内存不断增大；</li>
  <li>加载过多 jar、class 文件；</li>
  <li>操作过多对象（如死循环 / 循环产生重复的对象实例）导致堆内存已满；</li>
  <li>nio 直接操作内存，内存过大；</li>
  <li>参数设置内存过小。</li>
  <li>OutOfMemoryError: GC Overhead Limit Exceeded:：GC上限超出，GC 时间长，但只回收了很少的堆内存；</li>
  <li>OutOfMemoryError: Java heap space：堆内存不足以存放新创建的对象；</li>
</ol>

<h5 id="故障定位">故障定位</h5>

<p>OOM 分析思路：</p>

<ul>
  <li>加入启动参数 dump 出堆转储快照：
    <ul>
      <li><code class="highlighter-rouge">-XX:+HeapDumpOnOutOfMemoryError</code>：发生 OOM 时，dump 一份内存快照文件，输出出错时的堆内信息，用于排查问题。</li>
      <li><code class="highlighter-rouge">-XX:+HeapDumpPath=/usr/local/app/oom</code></li>
    </ul>
  </li>
  <li>通过内存映射工具分析快照，重点是确认内存中的对象是否是必要的，即到底是出现了内存泄漏还是内存溢出。
    <ul>
      <li>如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的应用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息，及 GC Roots 引用链的信息，就可较准确的定位出泄漏代码的位置；</li>
      <li>如果不存在内存泄漏，即内存中的对象确实都还必须存活着，应检查虚拟机的堆参数（-Xms 与 -Xms)，与机器物理内存对比看是否还可调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
    </ul>
  </li>
</ul>

<h5 id="性能调优工具">性能调优工具</h5>

<p>目的：减少GC（STW）。</p>

<p>一、JDK 调优命令：</p>

<ol>
  <li>jps（JVM Process Status）：类似 UNIX 的 ps 命令。查看所有 Java 进程的启动类、传入参数和 JVM 参数等信息；</li>
  <li>jstat（JVM Statistics Monitoring Tool）：用于收集 HotSpot 虚拟机各方面的运行数据；</li>
  <li>jinfo（Configuration Info for Java）：显示虚拟机配置信息；</li>
  <li>jmap（Memory Map for Java）：生成堆转储快照；</li>
  <li>jhat（JVM Heap Dump Browser）：用于分析 heapdump 文件，建立一个 HTTP/HTML 服务器，让用户可在浏览器上查看分析结果；</li>
  <li>jstack（Stack Trace for Java）：生成虚拟机当前时刻的线程快照（当前虚拟机内每一条线程正在执行的方法堆栈的集合）。</li>
</ol>

<p>二、Linux 命令行：</p>

<ol>
  <li>top 命令</li>
  <li>vmstat 命令</li>
  <li>pidstat 命令</li>
</ol>

<p>三、可视化工具：</p>

<ol>
  <li>Java VisualVM（jvisualvm）：提供运行监视和故障处理；</li>
  <li>阿里巴巴 <a href="https://github.com/macrozheng/mall-learning/blob/master/docs/reference/arthas_start.md">Arthas</a> Java 诊断；</li>
</ol>

<h3 id="java-内存模型jmm与并发">Java 内存模型（JMM）与并发</h3>
