<blockquote>
  <p>摘要：计算机网络属于计算机基础，包括四/七层模型，网络层 IP 协议，传输层 TCP/UDP、三次握手、四次挥手，应用层 HTTP/HTTPS、请求报文和响应报文、状态码、HTTP 缓存机制，Session等。</p>

  <p>用浏览器访问网页的过程（重点是DNS 解析）将所有知识串联到一起。</p>
</blockquote>

<!-- more -->

<h3 id="基本概念">基本概念</h3>

<ol>
  <li>带宽（bandwidth） ：表示在单位时间内，从网络中的某一点到另一点所能通过的“<strong>最高</strong>数据率”。常用来表示网络的通信线路传送数据的能力。单位是 b/s 比特每秒。</li>
  <li>吞吐量（throughput ）：表示在单位时间内，通过某个网络（或信道、接口）的数据量。用于测量实际上到底有多少数据量能通过网络。受网络带宽或额定速率的限制。</li>
</ol>

<h3 id="tcpip-四五层模型-vs-osi-七层模型">TCP/IP 四（五）层模型 VS OSI 七层模型</h3>

<p><img src="assets/TCP_IP_4层_7层模型.png" alt="TCP/IP 4层模型" style="zoom:70%;" /><img src="assets/协议栈.png" style="zoom:35%;" /></p>

<ol>
  <li>网络接口层：
    <ol>
      <li>物理层：最底层，利用传输介质实现（相邻两台物理机/计算机节点间的）比特流传送。网卡/物理硬件（负责收发网线中的信号）、中继器和集线器在这层工作。</li>
      <li>数据链路层：将网络层交下来的 IP 数据报组装成帧，可靠的传输到相邻节点（/目标机）的网络层。网卡<strong>驱动</strong>程序（负责控制网卡/硬件）、交换机、网桥。</li>
    </ol>
  </li>
  <li>网络层：路由和寻址。将网络地址翻译成对应的物理地址，通过路由选择算法为 IP 数据报/分组选择（通过通信子网的）最佳路径。路由器；IP 协议。</li>
  <li>传输层：为两台主机进程间的（逻辑）通信提供通用的数据传输服务，传送应用层报文。网关；负责收发数据的 TCP 和 UDP 协议。</li>
  <li>应用层：浏览器通过调用 Socket 库来委托协议栈工作；
    <ol>
      <li>会话层：用于管理（建立和保持、维护、重连）应用程序间的会话，身份验证等；</li>
      <li>表示层：用于数据处理（编码解码、加密解密、压缩解压缩等）；</li>
      <li>应用层：用于定义网络通信规则（协议），为计算机用户提供服务。报文；HTTP 协议。</li>
    </ol>
  </li>
</ol>

<p><img src="assets/扒皮模型.png" style="zoom:38%;" /><img src="assets/IP数据包.png" style="zoom:36%;" /></p>

<p><strong>为什么分层</strong>：</p>

<ol>
  <li>封装</li>
  <li>解耦</li>
</ol>

<h3 id="一网络接口层">一、网络接口层</h3>

<p>CRC（Cyclic Redundancy Check）循环冗余检验：为了保证数据传输的可靠性，广泛使用的一种检错技术。</p>

<h3 id="二网络层">二、网络层</h3>

<p>常见协议：</p>

<ol>
  <li><code class="highlighter-rouge">IP</code> 协议：控制网络包收发。</li>
  <li><code class="highlighter-rouge">ICMP</code> 控制报文协议：用于告知网络包传送过程中产生的错误及各种控制信息。</li>
  <li><code class="highlighter-rouge">OPSF</code> 路由选择协议：用于 IP 数据包（在路由器间）的路由选择。</li>
  <li><code class="highlighter-rouge">ARP</code> 地址解析协议：路由器与服务器通信时，用于物理地址寻址，负责将 IP 地址转换为 <code class="highlighter-rouge">MAC</code> 物理地址。每台主机中都有一张 ARP 缓存表，记录主机的 IP 地址和 MAC 地址间的对应关系；
    <ol>
      <li>在 ARP 缓存中查询 IP 地址，未命中则发送（包含待查询 IP 地址的）ARP 广播请求，等待回应；</li>
      <li>收到广播的主机检查自己的 IP，符合条件的将（含有自己 <code class="highlighter-rouge">MAC</code> 地址的） ARP 包返回给广播的主机；</li>
      <li>得到 ARP 回应后，将 IP 地址与路由的下一跳 <code class="highlighter-rouge">MAC</code> 地址写入 ARP 缓存表；以路由下一跳的地址填充目的 <code class="highlighter-rouge">MAC</code> 地址，以数据帧形式转发；</li>
    </ol>
  </li>
  <li><code class="highlighter-rouge">RARP</code> 逆地址解析协议：逆向从 IP 地址反查域名。</li>
</ol>

<p>地址：</p>

<ol>
  <li><code class="highlighter-rouge">MAC</code>：只负责某一区间（主机、路由器、主机）的通信传输；</li>
  <li><code class="highlighter-rouge">IP</code> 地址：负责将数据包发给最终目的地地址；分类号 + 网络号 + 主机号。
    <ul>
      <li>为什么要分离网络号和主机号：两台计算机的网络地址，用于判断是否处于同一广播域内。如果网络地址相同，表明接受方在本网络内，可把数据包直接发送到目标主机。如路由器寻址。
        <ol>
          <li>网络地址（号）：主机位全为0，网段的第一个地址，表示属于互联网的哪一个网络。本机 IP 地址 0.0.0.0。</li>
          <li>主机地址（号）：表示属于网络中的哪一台主机。</li>
        </ol>
      </li>
      <li>子网掩码：网络位 + 主机位
        <ol>
          <li>用 IP 地址与子网掩码<strong>按位与</strong>，用于区分网络位和主机位；</li>
          <li>将一个大的 IP 地址划分为若干子网络；</li>
          <li>检测两个 IP 地址是否属于同一子网；</li>
          <li>减少 IP 地址浪费；</li>
        </ol>
      </li>
      <li>网关地址：路由器的地址；</li>
      <li>广播地址：主机位全为1的，网络的最后一个地址；
        <ul>
          <li>255.255.255.255 ：受限的广播地址，只能用于本地网络；</li>
        </ul>
      </li>
      <li>回送（<del>环回</del>）地址：127.0.0.0/8，表示本机地址；
        <h3 id="三传输层">三、传输层</h3>
      </li>
    </ul>
  </li>
</ol>

<h5 id="tcp-vs-udp">TCP VS UDP</h5>

<ol>
  <li><code class="highlighter-rouge">TCP</code> 传输控制协议：提供<strong>面向</strong>连接的、可靠的数据传输服务；只能点对点通信。
    <ul>
      <li>用于传输对<strong>准确性</strong>要求高的数据，如浏览器与服务器间的 HTTP 通信、文件传输、收发邮件、远程登录等。速度较慢，负载较高，采用虚电路。</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">UDP</code> 用户数据报协议：提供<strong>无连接</strong>的数据传输服务，不保证可靠性；支持点对点、多播和广播。
    <ul>
      <li>用于即时通信，如语音、视频、直播等。</li>
    </ul>
  </li>
</ol>

<h5 id="tcp-三次握手">TCP 三次握手</h5>

<p><img src="assets/三次握手和四次挥手.png" alt="img" style="zoom: 40%;" /></p>

<p>目的：保证客户端和服务端（浏览器和服务器）建立可靠的通信信道。主要作用是为了确认双方的接收和发送能力是否正常、指定自己的初始化序列号、为后面的可靠性传送做准备。</p>

<p>实质上就是连接服务器指定的端口，建立 TCP 连接，并同步客户端和服务端的序列号和确认号，交换 TCP 窗口大小信息。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  		报文标志位    确认号      序列号
B-to-S:	SYN		  (			   seq = x )
S-to-B:	SYN + ACK ( ACK = x+1, seq = y )
B-to-S:	ACK		  ( ACK = y+1, [seq = x+1] )
</code></pre></div></div>

<p>刚开始客户端处于 <code class="highlighter-rouge">Closed</code> 的状态，服务端处于 <code class="highlighter-rouge">Listen</code> 状态。Socket 编程中，客户端执行 <code class="highlighter-rouge">connect()</code> 时，将触发三次握手。</p>

<p>Socket：从传输层上抽象出的一个抽象层，本质是接口。</p>

<ol>
  <li>客户端向服务端：发送 <code class="highlighter-rouge">SYN</code> 报文/数据包，<strong>请求建立连接</strong>，初始序列号 <code class="highlighter-rouge">seq</code> 设置为 <code class="highlighter-rouge">x</code>。
    <ul>
      <li>告诉服务端要发送请求，客户端进入 <code class="highlighter-rouge">SYN_SENT</code> 状态，等待服务端确认。</li>
    </ul>
  </li>
  <li>服务端（<strong>准备好建立连接</strong>后）向客户端：发送 <code class="highlighter-rouge">SYN + ACK</code> 报文，<strong>请求确认连接</strong>，确认号 <code class="highlighter-rouge">ACK</code> 设为 （第一次握手时，客户端发送过来的）序列号 <code class="highlighter-rouge">x + 1</code>，服务端初始化序列号 <code class="highlighter-rouge">seq</code> 设为 <code class="highlighter-rouge">y</code>。其中 <code class="highlighter-rouge">ACK</code> 报文用来应答，<code class="highlighter-rouge">SYN</code> 报文用来同步。
    <ul>
      <li>告诉客户端准备接收数据，然后进入 <code class="highlighter-rouge">SYN_RECV</code> 状态。</li>
    </ul>
  </li>
  <li>客户端（收到<strong>请求确认连接报文</strong>后<del>知道服务器已做好建立连接的准备</del>）：发送 <code class="highlighter-rouge">ACK</code> 报文，确认号 <code class="highlighter-rouge">ACK</code> 设为 （第二次握手时，服务器发送过来的）序列号 <code class="highlighter-rouge">y + 1</code>，确认连接。
    <ul>
      <li>告诉服务端准备接收数据，客户端和服务端都进入 <code class="highlighter-rouge">ESTABLISHED</code> 状态，双方建立连接。</li>
      <li><code class="highlighter-rouge">ACK</code> 报文段可携带数据（序列号 <code class="highlighter-rouge">seq</code> 设置为 <code class="highlighter-rouge">x + 1</code>），不携带则不消耗序列号。</li>
    </ul>
  </li>
</ol>

<p>两次不可以：两次握手只能保证客户端可正常给服务端发送数据，只有经过第三次握手，双方才能确认自己与对方的发送与接收是正常的。</p>

<ol>
  <li>第一次握手：客户端发送数据包，服务端收到了。服务端能确认：客户端的发送能力、服务端的接收能力是正常的；</li>
  <li>第二次握手：服务端发送数据包，客户端收到了。 客户端能确认：服务端的接收、发送能力，客户端的发送、接收能力是正常的。不过此时，服务器并不能确认<strong>客户端的接收能力</strong>是否正常；</li>
  <li>只有经过第三次握手：客户端发送数据包，服务端收到了。 这样服务端就能确认：<strong>客户端的接收</strong>、发送能力正常，服务器自己的发送、接收能力也正常。</li>
</ol>

<p>若只有两次握手：已失效的连接请求报文突然又传送到了服务端，从而产生错误。</p>

<ol>
  <li>如第一次握手时，客户端发出的连接请求报文延误、丢失，而未收到来自第二次握手的确认报文；</li>
  <li>于是客户端再重传一次连接请求，第二个到达了服务端，客户端收到了确认，二者建立了连接。数据传输完毕后，释放了连接；</li>
  <li>此时，第一个丢失的连接请求报文段到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，因为不采用三次握手，所以二者直接建立连接；服务器并不能确认<strong>客户端的接收能力</strong>是否正常；</li>
  <li>客户端已关闭连接，会忽略服务端发来的确认，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。</li>
</ol>

<h5 id="数据传输">数据传输</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  		标志位 确认号  	序列号
B-to-S:	ACK ( ACK = y+1, seq = x+1 )
S-to-B:	ACK ( ACK = x+2 		   )
</code></pre></div></div>

<h5 id="tcp-四次挥手">TCP 四次挥手</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  	报文标志位 确认号	   序列号
B-to-S:	FIN ( 			 seq = x )
S-to-B:	ACK	( ACK = x+1 		 )
S-to-B:	FIN ( 			 seq = y )
B-to-S:	ACK ( ACK = y+1			 )
</code></pre></div></div>

<p>当 TCP 连接超过一定时间或不再使用时（数据传送完毕、传输完一个网页的全部资源、收到全部内容后），触发四次挥手。</p>

<ol>
  <li>客户端向服务端：发送 <code class="highlighter-rouge">FIN</code> 连接释放报文段，表示请求报文发送完了，准备关闭 TCP 连接，并停止发送数据。
    <ul>
      <li>客户端进入 <code class="highlighter-rouge">FIN_WAIT1</code>（终止等待1）状态，等待服务端确认。</li>
    </ul>
  </li>
  <li>服务端收到 <code class="highlighter-rouge">FIN</code> 后，向客户端发送 <code class="highlighter-rouge">ACK</code> 报文：<code class="highlighter-rouge">ACK</code> 确认号设置为（第一次挥手时）客户端发送过来的序列号 <code class="highlighter-rouge">x + 1</code>，表示<strong>已收到</strong>客户端的关闭连接请求。
    <ul>
      <li>此时服务端进入 <code class="highlighter-rouge">CLOSE_WAIT</code> <strong>半关闭</strong>状态，即客户端已没有要发送的数据，但服务端若发送数据，则客户端仍要接收；</li>
      <li>客户端收到服务端的确认后，进入 <code class="highlighter-rouge">FIN_WAIT2</code>（终止等待2）状态，等待服务端发出的连接释放报文段。</li>
    </ul>
  </li>
  <li>服务端响应报文<strong>发送完</strong>后，请求关闭/断开与客户端的连接，（和客户端的第一次挥手一样），发出 <code class="highlighter-rouge">FIN</code> 连接释放报文，指定一个序列号 <code class="highlighter-rouge">y</code>。告诉客户端响应报文发送完了，同意关闭请求。
    <ul>
      <li>此时服务端进入 <code class="highlighter-rouge">LAST_ACK</code> （最后确认）状态，等待客户端的确认。</li>
    </ul>
  </li>
  <li>客户端收到 <code class="highlighter-rouge">FIN</code> 连接释放报文段后，发送 <code class="highlighter-rouge">ACK</code> 确认作为应答，将 <code class="highlighter-rouge">ACK</code> 确认号设置为收到的服务端序列号 <code class="highlighter-rouge">y + 1</code>；告诉服务器响应报文接受完了。
    <ul>
      <li>此时客户端进入 <code class="highlighter-rouge">TIME_WAIT</code> 状态。</li>
      <li>服务端收到 <code class="highlighter-rouge">ACK</code> 报文后，关闭连接，进入 <code class="highlighter-rouge">CLOSED</code> 状态；</li>
      <li>客户端等待一定时间未收到回复，则正常关闭，进入 <code class="highlighter-rouge">CLOSED</code> 状态。</li>
    </ul>
  </li>
</ol>

<p><strong>挥手为什么需要四次</strong>？</p>

<p>四次由 TCP 的<strong>半关闭</strong>（half-close）造成的。即，TCP 提供了一种能力，连接的一端在<strong>结束发送</strong>后、还能接收来自另一端的数据。第二次挥手后。</p>

<p>关闭连接时，当服务端收到 <code class="highlighter-rouge">FIN</code> 报文时，可能响应报文并没有发送完，并不会立即关闭 <code class="highlighter-rouge">SOCKET</code> 连接，所以只能先回复一个 <code class="highlighter-rouge">ACK</code> 报文，告诉客户端收到了发的 <code class="highlighter-rouge">FIN</code> 报文。只有等到服务端所有的报文都发送完了，才发送 <code class="highlighter-rouge">FIN</code> 报文，故需四次挥手。</p>

<h5 id="tcp-如何保证可靠传输">TCP 如何保证可靠传输</h5>

<p>在不可靠服务的基础上实现可靠的信息传输。</p>

<ol>
  <li>校验和：如果收到段的检验和有错，TCP 将丢弃此报文段。</li>
  <li>序列号：为发送的包/数据块编号，接收方对数据包排序，去重，再传送给应用层。</li>
  <li>确认应答/ARQ 自动重传请求协议：每发完一个分组就停止发送，收到对方确认后再发下一个；ACK 报文中有对应的确认序列号，告诉发送方接收了哪些数据、下一次数据从哪里传。</li>
  <li>（最关键）<strong>超时重传</strong>：当 TCP 发出一个报文段后，启动定时器，等待目的端确认收到；超时后仍未收到确认，则重发此报文段。</li>
  <li>三次握手四次挥手，用来建立和关闭连接；</li>
  <li>流量控制：利用滑动窗口（接收方发送的确认报文中的窗口字段用来控制发送方窗口大小）实现流量控制，控制发送速率，解决丢包重传。</li>
  <li>拥塞控制：当网络拥塞时减少数据发送。</li>
</ol>

<h3 id="四应用层">四、应用层</h3>

<h4 id="应用层协议">应用层协议</h4>

<p>运行于 TCP 协议上的：</p>

<ol>
  <li><code class="highlighter-rouge">HTTP</code> 超文本传输协议：用于浏览器与服务器间的通信（传输数据）。基于 TCP 协议，先（3 次握手）建立 TCP 连接，再发送 HTTP 请求。功能包括：事务处理、缓存控制、标记媒体类型等。</li>
  <li><code class="highlighter-rouge">FTP</code> 文件传输协议：基于 TCP 实现可靠传输，好处是可屏蔽操作系统和文件存储方式。</li>
  <li><code class="highlighter-rouge">SMTP</code> 邮件发送协议；</li>
  <li><code class="highlighter-rouge">POP3/IMAP</code> 邮件接收协议。</li>
  <li><code class="highlighter-rouge">Telnet</code> 远程登录协议：缺点是所有数据以明文发送；</li>
  <li><code class="highlighter-rouge">SSH</code> <strong>安全网络传输</strong>协议：是目前较可靠、专为远程登录会话和其他网络服务提供安全性的协议。解决了 Telnet 不安全的问题，可有效防止远程管理过程中的信息泄露问题。</li>
</ol>

<p>运行于 UDP 协议上的 ：</p>

<ol>
  <li><a href="#DNS 域名解析"><code class="highlighter-rouge">DNS</code> 域名解析协议</a>；</li>
  <li><code class="highlighter-rouge">DHCP</code> 动态主机<strong>配置</strong>协议：用于内部网（路由器？）或网络服务供应商自动分配 IP 地址给用户。</li>
</ol>

<h4 id="http">HTTP</h4>

<h5 id="http10-vs-http11">HTTP/1.0 VS HTTP/1.1</h5>

<ol>
  <li>连接方式：<code class="highlighter-rouge">HTTP/1.0</code> 默认用短连接；<code class="highlighter-rouge">HTTP/1.1</code> 默认长连接（成功建立后保持连接不关闭），开启 <code class="highlighter-rouge">Keep-Alive</code>，请求头设置 ``Connection: Keep-Alive<code class="highlighter-rouge"> </code>。</li>
  <li>状态（响应）码：<code class="highlighter-rouge">HTTP/1.1</code>新加入大量状态码，如 <code class="highlighter-rouge">100、206、409、410</code> 等。</li>
  <li><strong>缓存处理</strong> :  <code class="highlighter-rouge">HTTP/1.0</code> 中主要用请求 <code class="highlighter-rouge">header</code> 中的 <code class="highlighter-rouge">If-Modified-Since/Expires</code> 作为缓存判断标准；<code class="highlighter-rouge">HTTP/1.1</code> 引入了更多的缓存控制策略，如 <code class="highlighter-rouge">Entity tag，If-Unmodified-Since, If-Match/If-None-Match</code> 等。<a href="#HTTP 缓存机制">HTTP 缓存机制</a></li>
  <li><strong>带宽优化</strong>：<code class="highlighter-rouge">HTTP/1.0</code> 传送整个对象，浪费带宽；<code class="highlighter-rouge">HTTP/1.1</code> 在请求头引入了 <code class="highlighter-rouge">range</code> 头域，允许只请求资源的某个部分（返回码 <code class="highlighter-rouge">206</code>），充分利用带宽，还支持断点续传。</li>
  <li><code class="highlighter-rouge">HTTP/1.1</code> 在请求头中新增 <code class="highlighter-rouge">Host</code> 字段。</li>
</ol>

<h5 id="http20">HTTP2.0</h5>

<h5 id="http-vs-https-协议">HTTP VS HTTPS 协议</h5>

<p>都是 <code class="highlighter-rouge">TCP</code> 作为底层协议。</p>

<ol>
  <li><strong>端口号</strong>：<code class="highlighter-rouge">HTTP</code> 默认是 80，<code class="highlighter-rouge">HTTPS</code> 默认是 443。</li>
  <li><strong>URL 前缀</strong>：http://；https://。</li>
  <li>安全性和资源消耗： <code class="highlighter-rouge">HTTP</code> 传输内容是明文，客户端和服务器端都无法验证对方的身份。<code class="highlighter-rouge">HTTPS</code> 运行在 <code class="highlighter-rouge">SSL/TLS</code> 之上，传输内容经过<strong>对称加密</strong>，密钥用服务器的证书进行<strong>非对称加密</strong>。安全性高，但耗费更多资源。</li>
</ol>

<p><strong>https 加密的过程</strong></p>

<ul>
  <li>
    <p>对称加密：加密和解密用同一个密钥，<strong>最大的问题是</strong>如何安全地将密钥发给对方；</p>
  </li>
  <li>
    <p>非对称加密：用一对公钥和私钥。<strong>发送方</strong>用对方的公钥加密，对方用自己的私钥解密。</p>
  </li>
</ul>

<h4 id="http-request-请求报文">HTTP Request 请求报文</h4>

<blockquote>
  <p>客户端请求消息</p>
</blockquote>

<p><img src="assets/myBqd6H.jpg" alt="myBqd6H.jpg" style="zoom: 60%;" /></p>

<ol>
  <li>
    <p>请求行（request line）：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET	 /search?lan=zh-CN&amp;name=tom  HTTP/1.1
</code></pre></div>    </div>

    <ol>
      <li>8种请求方法：
        <ul>
          <li><code class="highlighter-rouge">HTTP/1.0</code>：<code class="highlighter-rouge">GET</code> 、<code class="highlighter-rouge">POST</code>、<code class="highlighter-rouge">HEAD</code> 方法；</li>
          <li><code class="highlighter-rouge">HTTP/1.1</code>：<code class="highlighter-rouge">PUT、DELETE、CONNECT、OPTIONS、TRACE</code> 方法。</li>
        </ul>
      </li>
      <li>URL 地址：指定/定位资源地址，也可传递 <code class="highlighter-rouge">GET</code> 方法的请求参数；</li>
      <li>协议名及版本号：<code class="highlighter-rouge">HTTP/1.0、HTTP/1.1、HTTPS</code>。</li>
    </ol>
  </li>
  <li>请求头（header）：报文头的字段及取值（“属性名 : 属性值”），通知服务器关于客户端请求的附属信息。 <code class="highlighter-rouge">HttpServletRequest</code> 服务端用于读取请求报文头的 API。
    <ol>
      <li><code class="highlighter-rouge">Accept: text/plain, image/jpeg</code> 客户端可识别的内容类型列表；告诉服务端，客户端接受什么类型的响应。一个或多个 <code class="highlighter-rouge">MIME</code> 类型的值；</li>
      <li>Referer 表示这个请求是从哪个URL过来的；</li>
      <li><code class="highlighter-rouge">User-Agent:</code> （产生请求的）浏览器类型，兼容性及定制化需求；</li>
      <li><code class="highlighter-rouge">Host: localhost:8088</code> 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机；</li>
      <li><code class="highlighter-rouge">Content-Type 和 Content-Length</code> 与请求体相关；</li>
      <li><code class="highlighter-rouge">Connection: Keep-Alive</code> 即持久连接，一个连接可发多个请求；</li>
      <li><code class="highlighter-rouge">Cache-Control: no-cache</code> 让请求返回的响应内容不要在客户端缓存；</li>
      <li><code class="highlighter-rouge">Cookie: JSESSIONID=xxx</code></li>
      <li>缓存处理 :  <code class="highlighter-rouge">HTTP/1.0</code> 中主要用请求 <code class="highlighter-rouge">header</code> 中的 <code class="highlighter-rouge">If-Modified-Since/Expires</code> 作为缓存判断标准；<code class="highlighter-rouge">HTTP/1.1</code> 引入了更多的缓存控制策略，如 <code class="highlighter-rouge">Entity tag，If-Unmodified-Since, If-Match/If-None-Match</code> 等。</li>
    </ol>
  </li>
  <li>请求体（Request body、请求数据、报文体）：在 <code class="highlighter-rouge">POST</code> 方法中使用，可包含多个请求参数。适用于需客户填写表单的场合，存放表单的键值对。</li>
</ol>

<h5 id="get-请求-vs-post-请求">GET 请求 VS POST 请求</h5>

<ol>
  <li><del>情景</del>：<code class="highlighter-rouge">GET</code> 当客户端点击网页上的链接、在浏览器的地址栏输入网址、要从服务器中读取文档时。</li>
  <li>用法：<code class="highlighter-rouge">GET</code> 要求服务器将 URL 定位的资源放在响应报文的数据部分，回送给客户端。<code class="highlighter-rouge">HEAD</code>类似 <code class="highlighter-rouge">GET</code>，只不过服务端接收到 <code class="highlighter-rouge">HEAD</code> 请求后只返回响应头，而不会发送响应内容，适合只需查看某个页面的状态时。</li>
  <li>参数：
    <ol>
      <li>参数限制：<code class="highlighter-rouge">GET</code> 一般不含请求体，请求参数（以地址的形式）通过 URL 传递，有长度、大小限制，只接受 ASCII 字符；<code class="highlighter-rouge">POST</code> 将请求参数（以 <code class="highlighter-rouge">key-value</code> 的形式）封装在请求体中，没有限制，可传输大量数据。</li>
      <li>安全性/可见性：<code class="highlighter-rouge">GET</code> 的参数所有人可见，不安全，不适合传送私密数据、敏感信息。</li>
      <li>历史记录：<code class="highlighter-rouge">GET</code> 请求参数会被完整保留在浏览器历史记录里，URL 地址可被收藏，而 <code class="highlighter-rouge">POST</code> 中的参数不会被保留。</li>
      <li>回退：<code class="highlighter-rouge">GET</code> 请求在浏览器回退时是无害的，而 <code class="highlighter-rouge">POST</code> 会再次提交请求。</li>
    </ol>
  </li>
  <li>编码类型：<code class="highlighter-rouge">GET</code> 请求只能进行 URL 编码，而 <code class="highlighter-rouge">POST</code> 支持多种编码方式。</li>
  <li>TCP 数据包：<code class="highlighter-rouge">GET</code> 请求发送一个 TCP 数据包； <code class="highlighter-rouge">POST</code> 发送两个。
    <ul>
      <li>对于 <code class="highlighter-rouge">GET</code> 请求，浏览器会把 http header 和 data 一起发送出去，服务器响应 200（返回数据）；</li>
      <li>而对于 <code class="highlighter-rouge">POST</code> ，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。</li>
    </ul>
  </li>
  <li>缓存：<code class="highlighter-rouge">GET </code>会被浏览器主动 cache，而 <code class="highlighter-rouge">POST</code> 不会，除非手动设置。</li>
</ol>

<h4 id="http-response-响应报文">HTTP Response 响应报文</h4>

<blockquote>
  <p>服务端响应消息</p>
</blockquote>

<p><img src="assets/jR36KBb.jpg" alt="jR36KBb.jpg" style="zoom:80%;" /></p>

<ol>
  <li>状态行：
    <ol>
      <li>协议名及版本；</li>
      <li>状态码及状态描述；</li>
    </ol>
  </li>
  <li>消息报头（响应头）：由多个键值对组成；
    <ol>
      <li><code class="highlighter-rouge">Content-Type</code>：<code class="highlighter-rouge">application/json</code>。</li>
      <li><code class="highlighter-rouge">Cache-Control: max-age=3600</code> 服务端告诉客户端如何控制响应内容的缓存。缓存3600秒。</li>
      <li><code class="highlighter-rouge">Location: https://github.com</code> 让客户端再发一个请求到重定向的 URL，状态码为 <code class="highlighter-rouge">303</code>。</li>
      <li><code class="highlighter-rouge">Set-Cookie: UserID=Jack; Max-Age=3600; Version=1</code> 服务端可设置客户端的 Cookie。</li>
    </ol>
  </li>
  <li>响应体（响应正文）</li>
</ol>

<h5 id="状态码">状态码</h5>

<p>服务端发生错误时，返回给前端的响应信息必须包含 HTTP 状态码、errorCode、 errorMessage、用户提示信息四部分。涉及对象分别是浏览器、前端开发、错误排查人员、用户。</p>

<ul>
  <li>浏览器接受并显示网页前；</li>
  <li>在<strong>服务器响应消息</strong>的<strong>状态行</strong>中；</li>
</ul>

<p>状态码：</p>
<ol>
  <li><code class="highlighter-rouge">1XX</code>：接收的请求正在处理。</li>
  <li><code class="highlighter-rouge">2XX</code>：请求正常处理完毕。
    <ul>
      <li><code class="highlighter-rouge">200 (OK</code>：请求成功，表明该请求被成功完成，所请求的资源已发送到客户端。一般用于 GET 或 POST；</li>
      <li><code class="highlighter-rouge">206 (Partial Content)</code>：范围请求；</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">3XX</code>：重定向，需附加操作以完成请求；让客户端再发起一个请求以完成整个处理。
    <ul>
      <li><del><code class="highlighter-rouge">301</code>：永久重定向，表示旧地址的资源已被永久移除（不可访问了）；</del></li>
      <li><code class="highlighter-rouge">302</code>：临时重定向，表示旧地址的资源还在（仍可访问），只是临时跳转到新地址，搜索引擎会抓取新地址的内容而保存旧网址；SEO 302 好于 301；</li>
      <li><code class="highlighter-rouge">303 (See Other)</code>：重定向到其它页面，目标 URL 在响应报文头的 Location 属性；</li>
      <li><code class="highlighter-rouge">304 (Not Modified)</code>：资源（自上次取得后）并未修改，直接用本地的缓存；</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">4XX</code>：客户端错误。
    <ul>
      <li><code class="highlighter-rouge">400 (Bad Request)</code>：客户端请求有语法错误，不能被服务器所理解；</li>
      <li><code class="highlighter-rouge">401 (Unauthorized)</code>：请求未经授权，必须和 <code class="highlighter-rouge">WWW-Authenticate</code> 头域一起使用；常见于用户未登录的情况；</li>
      <li><code class="highlighter-rouge">403 (Forbidden)</code>：服务器拒绝请求，禁止访问资源。常见于机密信息或复制其它登录用户链接访问服务器的情况；</li>
      <li><code class="highlighter-rouge">404 (NotFound)</code>：服务器无法取得所请求的网页，请求资源不存在。如输入错误的URL；</li>
      <li><code class="highlighter-rouge">409 (Conflict)</code>：请求与当前资源的规定冲突；</li>
      <li><code class="highlighter-rouge">410 (Gone)</code>：资源已被永久转移，且没有任何已知的转发地址；</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">5XX</code>：服务器端错误。
    <ul>
      <li><code class="highlighter-rouge">500 (Internal Server Error)</code>：服务器发生不可预期的错误，通过服务端日志查看抛出的异常；</li>
      <li><code class="highlighter-rouge">501 (Internal Server Error)</code>：内部服务器错误；</li>
      <li><code class="highlighter-rouge">503 (Server Unavailable)</code>：服务器当前不能处理客户端的请求，一段时间后可能恢复正常；</li>
      <li>路由出错，HTTP 版本不支持等；</li>
    </ul>
  </li>
</ol>

<h4 id="http-缓存机制">HTTP 缓存机制</h4>

<blockquote>
  <p>HTTP性能优化</p>
</blockquote>

<h5 id="缓存策略">缓存策略</h5>

<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，当 web 缓存发现请求的资源已被存储，会拦截请求，返回该资源的拷贝，而不会去资源服务器重新下载。</p>

<p>HTTP 缓存主要是通过请求和响应报文头（<code class="highlighter-rouge">Expires、Cache-Control、Last-Modified、Etag</code> 字段）来控制缓存策略。</p>

<p>优点：优秀的缓存策略可缩短网页请求资源的距离，减少延迟，节省网络流量；由于缓存文件可重复利用，降低网络负荷，提高客户端响应。</p>

<p>根据是否需重新向服务器发起请求分为两种：强制缓存和对比缓存。</p>

<ol>
  <li>强制缓存先向<strong>浏览器的缓存数据库</strong>请求数据，如果缓存命中且未失效，则直接返回数据，不需再和服务器发生交互；而对比缓存不管是否命中，都需与服务端发生交互。</li>
  <li>强制缓存优先级高于对比缓存，即，当执行强制缓存的规则时，如果缓存命中，直接使用缓存，不再执行对比缓存规则。</li>
</ol>

<h5 id="强制缓存">强制缓存</h5>

<p><img src="assets/force_cache.jpg" style="zoom:90%;" /></p>

<p>响应 header 中两个字段来<strong>标明失效规则</strong>：</p>

<ul>
  <li><code class="highlighter-rouge">Expires</code>：<strong>HTTP/1.0</strong>，服务端返回的缓存到期时间，即下一次请求时，请求时间小于此时间，则直接使用缓存数据。
    <ul>
      <li>到期时间由<strong>服务端</strong>生成，如果客户端跟服务器时间不一致，会导致缓存命中的误差。故浏览器默认使用 <code class="highlighter-rouge">HTTP/1.1</code>，即：</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">Cache-Control</code>： <strong>HTTP/1.1</strong>，用于指定缓存规则；
    <ol>
      <li><code class="highlighter-rouge">max-age</code>：用来设置资源可被缓存多长时间，缓存的内容将在 xxx 秒后失效，单位为秒；</li>
      <li><del><code class="highlighter-rouge">s-maxage</code>：同 <code class="highlighter-rouge">max-age</code>，不过只针对代理服务器缓存；</del></li>
      <li><code class="highlighter-rouge">public</code>：任何缓存区（客户端和代理服务器）都可缓存响应；</li>
      <li><code class="highlighter-rouge">private</code>：只能被客户端，而不能被代理服务器缓存；</li>
      <li><code class="highlighter-rouge">no-cache</code>：用对比缓存来验证缓存数据；</li>
      <li><code class="highlighter-rouge">no-store</code>：禁止一切缓存（这才是响应资源不被缓存的意思）；所有内容都不缓存，强制缓存、对比缓存都不会触发。</li>
    </ol>
  </li>
</ul>

<h5 id="对比缓存">对比缓存</h5>

<p><img src="assets/compare_cache.jpg" style="zoom:100%;" /></p>

<p>每次请求都需让服务器验证缓存数据是否过期（缓存响应的有效性），从而决定浏览器是否可以使用缓存。</p>

<ol>
  <li>向缓存数据库请求缓存数据的标识；</li>
  <li>浏览器第一次请求数据时（缓存未命中）：服务器（在响应请求中）将缓存标识/规则（<code class="highlighter-rouge">Etag</code> 标识或 <code class="highlighter-rouge">Last-Modified</code> 最后修改时间）与数据一起返回给浏览器，返回状态码 <code class="highlighter-rouge">200</code>，浏览器将二者备份至缓存数据库中。</li>
  <li>浏览器再次请求数据时：将缓存标识（作为 <code class="highlighter-rouge">If-None-Match</code> 或 <code class="highlighter-rouge">If-Modified-Since</code>）发送给服务器进行判断，比较<strong>服务器资源</strong>的 <code class="highlighter-rouge">Etag </code>是否与 <code class="highlighter-rouge">If-None-Match</code> 相同 、或 <code class="highlighter-rouge">Last-Modified</code> 是否小于（早于）等于 <code class="highlighter-rouge">If-Modified-Since</code>：
    <ol>
      <li>相同、早于等于，则比较成功，返回 <code class="highlighter-rouge">304 (Not Modified)</code> 状态码，表示资源（自上次取得后）并未修改/未失效（缓存命中），浏览器可直接使用本地缓存；</li>
      <li>不同、晚于，则比较失败，则说明资源修改过了（缓存未命中），浏览器不能再继续使用此缓存，需（如同第一次请求数据时一样）重新完整响应。</li>
    </ol>
  </li>
</ol>

<h3 id="分布式-session-和-cookie">分布式 Session 和 Cookie</h3>

<blockquote>
  <p>见分布式</p>
</blockquote>

<h3 id="浏览器访问网页的过程">浏览器访问网页的过程</h3>

<h5 id="url-解析">URL 解析</h5>

<p>Q1：URL 统一资源定位符：用于定位互联网上资源，俗称网址。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;协议&gt;://&lt;域主机&gt;.&lt;Web 服务器域名&gt;:&lt;端口&gt;/&lt;资源路径地址&gt;/&lt;文件名&gt;?
scheme://host.domain:port/path/filename?&lt;参数&gt;
</code></pre></div></div>

<ol>
  <li><code class="highlighter-rouge">scheme</code>：因特网服务的类型。常见的协议有 http、https、ftp、file。</li>
  <li><code class="highlighter-rouge">host</code>：域主机（http 的默认主机是 www）；</li>
  <li><code class="highlighter-rouge">domain</code>：因特网/Web 服务器<strong>域名</strong>，主机地址，如 w3school.com.cn；</li>
  <li><code class="highlighter-rouge">port</code>：主机上的端口号（http 的默认端口号是 80）；</li>
  <li><code class="highlighter-rouge">path</code>：服务器上的资源路径地址（如果省略，则文档必须位于网站的根目录中）；</li>
  <li><code class="highlighter-rouge">filename</code>：文档/资源名；</li>
</ol>

<h5 id="dns-域名解析">DNS 域名解析</h5>

<p><code class="highlighter-rouge">DNS</code> 域名解析（应用层？）：通过网址/域名查找服务器的 IP 地址，基于（网络层的）路由和 <code class="highlighter-rouge">IP</code> 寻址）、（传输层的）UDP 协议；</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>域名 		  服务器外网IP地址  端口
baidu.com	220.114.23.56 	80
</code></pre></div></div>

<p><img src="assets/DNS域名解析拓扑图.jpg" alt="img" style="zoom:60%;" /></p>

<ol>
  <li>客户机（本机）DNS 解析：
    <ol>
      <li><code class="highlighter-rouge">Q2</code>：浏览器查询<strong>DNS 解析缓存</strong>（域名和 IP 地址映射关系，有时间和大小双重限制），命中则直接返回，未命中（没有找到记录或记录已过期）；</li>
      <li><del>路由器缓存；</del></li>
      <li><code class="highlighter-rouge">Q3</code>：查询本地 <code class="highlighter-rouge">HOSTS</code> 文件（本机操作系统缓存）；</li>
    </ol>
  </li>
  <li><code class="highlighter-rouge">Q4</code>：浏览器向本地 DNS 服务器（正式）发送解析请求（递归查询）：
    <ol>
      <li><strong>本地 DNS 服务器</strong>：TCP/IP 参数中设置的首选 DNS 服务器，一般是运营商区域 DNS 服务器，由ISP（Internet Service Provider，互联网服务提供商，如电信/移动宽带、大型互联网公司提供的）的 DNS 服务器、根据 <code class="highlighter-rouge">DHCP</code> 动态主机设置协议自动分配 IP 地址；</li>
      <li><code class="highlighter-rouge">Q5</code>：查询本地区域资源配置：如果域名在区域中（命中），则返回解析结果，有权威性；如果不在区域中，</li>
      <li><code class="highlighter-rouge">Q6</code>：查询<strong>本地 DNS （解析结果）缓存</strong>：命中直接返回解析结果，没有权威性；
        <ul>
          <li>TTL（Time To Live）参数：设置本地 DNS 服务器对于域名的缓存（最长）时间，过期失效后将删除这条记录。如，阿里云解析默认的 TTL 是10分钟。</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>本地 DNS 服务器有两种配置：
    <ol>
      <li>配置直接转发 DNS，<strong>递归查询</strong> DNS；每一级与本地 DNS 查询一样；一般是先向根域服务器查询（<code class="highlighter-rouge">Q7</code>），再由根域名服务器一级级（<code class="highlighter-rouge">Q8 -&gt; Q10 -&gt; Q12</code>）向下查询，最后将得到的查询结果逐级（<code class="highlighter-rouge">A12 -&gt; A10 -&gt; A8 -&gt; A7</code>）返回给本地 DNS 服务器，再返回给浏览器。</li>
      <li>不配置转发 DNS，通过<strong>根提示</strong>进行<strong>迭代查询</strong>：根 DNS 服务器不是自己向其他 DNS 服务器进行查询，而是返回能解析该域名的其他 DNS 服务器的 IP 地址，本地 DNS 服务器再继续向这些 DNS 服务器迭代查询，直到得到结果：
        <ol>
          <li><code class="highlighter-rouge">Q7</code>：本地 DNS 服务器根据根提示，向根 DNS 服务器发起 DNS 解析请求；
            <ul>
              <li><code class="highlighter-rouge">Q8</code>：根 DNS 服务器查询（负责管理目标域名的） <code class="highlighter-rouge">.com</code> 顶级域名对应的（DNS 服务器的）IP 地址，返回给本地 DNS 服务器；</li>
            </ul>
          </li>
          <li><code class="highlighter-rouge">Q9</code>：本地 DNS 服务器向 <code class="highlighter-rouge">.com</code> 顶级域名 DNS 服务器发起 DNS 解析请求；
            <ul>
              <li><code class="highlighter-rouge">Q10</code>：<code class="highlighter-rouge">.com</code> 顶级域名 DNS 服务器查询（负责管理目标域名的） <code class="highlighter-rouge">baidu.com</code> 子域名对应的（DNS 服务器的）IP 地址，返回给本地 DNS 服务器；</li>
            </ul>
          </li>
          <li><code class="highlighter-rouge">Q11、Q12</code>：不断迭代（如二级域名），直到获得目标域名对应的 IP 地址，返回给本地 DNS 服务器；</li>
          <li><code class="highlighter-rouge">A11</code>：将域名解析的结果（以域名和 IP 地址键值对的形式）写入本地 DNS 解析缓存表，并设置 TTL；</li>
        </ol>
      </li>
      <li>将域名解析的结果返回给浏览器，更新浏览器 DNS 缓存；</li>
    </ol>
  </li>
  <li><code class="highlighter-rouge">Q13</code>：浏览器根据 IP 地址生成 HTTP 请求，发送给服务器。</li>
</ol>

<h5 id="dns-负载均衡">DNS 负载均衡</h5>

<p>如果配备了 DNS 负载均衡：一个域名可能对应多个 IP 地址；</p>

<ol>
  <li>DNS 解析获得的 IP 地址是负载均衡服务器的 IP 地址；</li>
  <li>负载均衡服务器根据设定的分配算法和规则（如根据每台机器的负载量，离用户地理位置的距离等），选择一台后端的（真实） Web 服务器 IP 地址并返回；</li>
</ol>

<p>DNS 缓存污染/投毒（DNS cache pollution/poisoning）：指一些刻意制造的域名服务器数据包， 把域名指往不正确的 IP 地址。是常见的黑客攻击手段，也是防火长城的主要手段之一。</p>

<h5 id="三次握手建立-tcp-连接">三次握手建立 TCP 连接</h5>

<p>（传输层）发起 <code class="highlighter-rouge">TCP</code> 请求：浏览器（选择一个大于1024的本机端口（<code class="highlighter-rouge">8080</code>？）向目标 IP 地址的 <code class="highlighter-rouge">80</code> 端口）发起 TCP 连接请求，经过<a href="TCP 三次握手">三次握手</a>建立 TCP 连接；Cookie 会随请求发送给服务器。</p>

<h5 id="http-缓存机制-1">HTTP 缓存机制</h5>

<p><a href="#HTTP 缓存机制">HTTP 缓存机制</a></p>

<ol>
  <li>强制缓存：向浏览器的缓存数据库判断缓存是否失效；</li>
  <li>对比缓存：将缓存标识发送给服务器，判断缓存是否过期，从而决定浏览器是否使用缓存（缓存策略）；</li>
</ol>

<h5 id="发送-http-请求">发送 HTTP 请求</h5>

<p>应用层：建立 TCP 连接后，浏览器生成 HTTP 请求报文（请求行、请求头、请求体），发给服务器；</p>

<p><del>浏览器按照 HTTP 协议的格式<a href="#TCP/IP 四（五）层模型 VS OSI 七层模型">组装数据</a>，最终将数据按照 TCP/IP 协议的方式发送给服务器；</del></p>

<ol>
  <li><del>TCP 将 HTTP 请求报文分割成报文段，并可靠地传给对方；</del></li>
  <li><del>在网络层使用 IP 协议：搜索对方地址，中转并传送；</del>
    <ol>
      <li><del>OSPF 路由选择协议，IP数据包在路由器间传递；</del></li>
    </ol>
  </li>
  <li><del>服务器接收报文段并重组 HTTP 请求报文，解析并进行相应的处理；</del></li>
</ol>

<h5 id="服务器处理请求并返回-http-响应报文">服务器处理请求并返回 HTTP 响应报文</h5>

<p>将请求转发到 Nginx 负载均衡（反向代理）服务器：将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理；</p>

<ol>
  <li>负载均衡服务器与选择的 Web 服务器建立 TCP 连接，转发浏览器的请求；</li>
  <li>Web 服务器收到请求后，调用自身服务（如 Spring Boot 应用等）处理请求，生成 HTTP 响应报文（响应行、响应头、响应体），（通过使用 TCP/IP 协议）返回给负载均衡服务器；</li>
  <li><del>将网页传递给 <code class="highlighter-rouge">filters</code> 链处理，</del>再返回给浏览器。</li>
</ol>

<h5 id="四次挥手断开-tcp-连接">四次挥手断开 TCP 连接</h5>

<p>当 TCP 连接超过一定时间或不再使用时（数据传送完毕、传输完一个网页的全部资源、收到全部内容后），<a href="#TCP 四次挥手">四次挥手</a>断开（与服务器间的） TCP 连接。</p>

<h5 id="浏览器解析渲染网页">浏览器解析渲染网页</h5>

<p><img src="assets/浏览器解析渲染网页.png" alt="img" style="zoom:80%;" /></p>

<ol>
  <li>浏览器解析网页内容：根据响应头的 <code class="highlighter-rouge">Content-Type</code> 字段的值判断数据类型，如文字、图像、声音、视频等;
    <ol>
      <li>解析 <code class="highlighter-rouge">HTML</code> 标签生成 <code class="highlighter-rouge">DOM</code> 树；</li>
      <li>解析 <code class="highlighter-rouge">CSS</code> 代码生成 <code class="highlighter-rouge">CSS</code> 规则树；</li>
      <li>调用 <code class="highlighter-rouge">JavaScript</code> 执行引擎执行 JS 代码；</li>
    </ol>
  </li>
  <li>结合 <code class="highlighter-rouge">DOM</code> 树和 <code class="highlighter-rouge">CSS</code> 规则树，生成渲染树，；</li>
  <li>根据渲染树<strong>计算</strong>每个节点的布局信息（元素在网页中的位置和尺寸）；</li>
  <li>根据计算好的信息<strong>绘制</strong>（渲染）网页；</li>
  <li>页面引用了其他未加载的 image、css、js 文件等静态内容，从提供静态资源的服务器加载；
    <ul>
      <li>CDN 内容分发网络：是依靠部署在各地的边缘服务器，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度。</li>
    </ul>
  </li>
</ol>

<h3 id="跨域">跨域</h3>

<p>跨域：指不同域名间相互访问。浏览器不能执行其他网站的脚本，是由同源策略（对于JavaScript所定义的安全限制策略）造成的。</p>

<h5 id="什么情况会跨域">什么情况会跨域</h5>

<ol>
  <li>同一协议， 如http或https；</li>
  <li>同一IP地址，如127.0.0.1；</li>
  <li>同一端口，如8080；</li>
</ol>

<p>以上三个条件任一条件不同就会产生跨域问题。</p>

<h5 id="解决方案">解决方案</h5>

<p><strong>前端解决方案</strong></p>

<ol>
  <li>使用JSONP方式实现跨域调用；</li>
  <li>使用NodeJS服务器作为服务代理，前端发起请求到NodeJS服务器， 代理转发请求到后端服务器；</li>
</ol>

<p><strong>后端解决方案</strong></p>

<ol>
  <li>nginx反向代理解决跨域；</li>
  <li>服务端设置Response Header(响应头部)的 <code class="highlighter-rouge">Access-Control-Allow-Origin</code>；</li>
  <li>在需跨域访问的类和方法中设置允许跨域访问（如Spring中使用<code class="highlighter-rouge">@CrossOrigin</code>注解）；</li>
  <li>继承使用Spring Web的<code class="highlighter-rouge">CorsFilter</code>（适用于Spring MVC、Spring Boot）；</li>
  <li>实现WebMvcConfigurer接口（适用于Spring Boot）；</li>
</ol>

<p><a href="https://cloud.tencent.com/developer/article/1668879">Java 解决跨域问题</a></p>
