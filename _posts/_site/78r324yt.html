<blockquote>
  <p>摘要：Java高级之集合框架/容器类，包括List、Set、Quene、Map。</p>
</blockquote>

<!-- more -->

<h2 id="集合框架容器类">集合框架（容器类）</h2>

<p>所有集合类都位于 java.util 包下，用于表示和操作对象集合，包含大量集合接口及其实现类和操作算法。</p>

<p>集合类 VS 数组：</p>
<ul>
  <li>数组元素既可是基本类型的值，也可是对象的引用；</li>
  <li>而集合只能保存对象的引用。对象本身存放在堆上或方法区里，但基本数据类型在栈上分配内存，随时被收回。但通过自动包装类可把基本类型转为对象类型，存放在集合中。</li>
</ul>

<h3 id="collection-接口及分类">Collection 接口及分类</h3>

<p>重写toString()来打印内容，否则默认打印地址</p>

<p>一、List 接口</p>

<ol>
  <li>ArrayList 类：</li>
  <li>LinkedList 类：
    <ul>
      <li>void addFirst(E e) / addLast(E e)</li>
      <li>E getFirst() / E getLast()</li>
      <li>E removeFirst() / E removeLast()</li>
      <li><del>Stack：是一个对象栈，先进后出</del></li>
    </ul>
  </li>
</ol>

<p>二、Set 接口</p>

<ol>
  <li>HashSet 类：实现了Set接口；基于HashMap实现但有键无值，元素值可以是 null；调用 add()方法（本质是调用HashMap的put()方法，且判断返回值为true？以确保不重复）向 Set 中添加元素；用成员对象计算 hashcode 值，若与已有 hashcode 相同，则用equals()方法判断两对象是否相等，若二者不等则加入成功；
    <ul>
      <li>
        <ul>
          <li>LinkedHashSet类：有序不重复无索引，基于LinkHashMap有键无值，能按添加元素的顺序遍历</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>TreeSet 类：实现了 Set 和 SortedSet 接口；对8个包装类、Character、String从大到小排序；自动升序排序（顺序）不重复；基于红黑树(自平衡的排序二叉树)，能按添加元素的顺序遍历，可定制排序方式</li>
</ol>

<p>三、Quene 接口：阻塞式队列（ArrayBlockingQuene）和非阻塞式队列(PriorityQuene，内存允许，可追加元素)。</p>

<ul>
  <li>PriorityQueue: Object[] 数组来实现二叉堆；手撕算法典型题包括堆排序、求第K大的数、带权图的遍历等。</li>
  <li>ArrayQueue: Object[] 数组 + 双指针</li>
</ul>

<p>四、Map 接口</p>

<ol>
  <li>HashMap 类：实现了Map接口；非线程安全；允许key和value为null，但作为键只能有一个，作为值可有多个；调用 put()向 map 中添加元素；用key计算 hashcode</li>
</ol>

<p>底层是 数组和链表（链表散列/链表数组）。HashMap 通过 key 的 hashCode （经过扰动函数处理后）得到 hash 值。如果当前位置存在元素，判断该元素与要存入元素的 hash 值及 key 是否相同，如果相同直接覆盖，不相同（哈希冲突）通过拉链法（附到链表数组的对应链表中）解决冲突。</p>

<ul>
  <li>LinkedHashMap：JDK1.8 后在解决哈希冲突时先进行数组扩容</li>
  <li>ConcurrentHashMap：线程安全，类似HashMap，唯一区别是其中的核心数据如 value及链表都是 volatile 修饰的，保证了获取时的可见性。采用分段锁技术，其中 Segment 继承于 ReentrantLock。不像 HashTable 那样put/get 都要做同步处理。</li>
</ul>

<ol>
  <li>
    <p>HashTable 类：<strong>线程安全</strong>，内部的方法基本都经过synchronized 修饰；数组+链表组成的，数组是 Hashtable 的主体，链表主要为了解决哈希冲突；<strong>基本被淘汰不用</strong>；不允许有 null 键和 null 值，否则会抛出 NullPointerException</p>
  </li>
  <li>
    <p>TreeMap 类：红黑树（自平衡的排序二叉树），实现SortMap接口-&gt;根据Key<strong>自动排序</strong>；</p>
  </li>
</ol>

<p>ArrayList, LinkedList, HashSet，TreeSet，HashMap, TreeMap 都是线程不安全的。</p>

<p>List接口继承自Collection接口：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface List&lt;E&gt; extends Collection&lt;E&gt; {
}
</code></pre></div></div>

<p>List中没有而ArrayList中独有的方法不能被List对象使用，即多态。</p>

<p>用多态方式调用方法时：
先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p>

<h3 id="list-vs-set-vs-queue-vs-map">List VS Set VS Queue VS Map</h3>

<ol>
  <li>List：有序可重复，允许多个null对象，可用iterator遍历或get(index)随机访问特定元素</li>
  <li>Set：无序不可重复，最多只能有一个null对象，只可用iterator遍历</li>
  <li>Queue：有序可重复，用于排队</li>
  <li>Map：无序可重复，键值对</li>
</ol>

<h3 id="list">List</h3>

<h5 id="arraylist-vs-linkedlist">ArrayList VS LinkedList</h5>

<ul>
  <li>二者都不是线程安全的
    <ol>
      <li>底层实现方式：ArrayList基于动态数组；LinkedList基于双向链表（JDK1.6 后，通过getLast()（获取最后一个元素）源码可见为双向）</li>
      <li>按位查找：ArrayList用get(index)随机访问快；LinkedList指定位置 index 查找为O(n)，顺序访问快</li>
      <li>插入和删除：ArrayList 效率受元素位置影响，对尾部增删O(1)，指定位置 i 增删为O(n) ；LinkedList先查再增删，增删效率不受元素位置影响，均O(1)</li>
      <li>扩容：ArrayList扩容机制为新建数组并拷贝原数组；LinkedList基于双向链表，不需要扩容</li>
      <li>内存空间：从单个元素说，LinkedList空间开销大</li>
    </ol>
  </li>
</ul>

<h5 id="arraylist-常用方法">ArrayList 常用方法</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;String&gt; lists = new ArrayList&lt;&gt;(); // 经典代码，ArrayList几乎实现了List的所有接口
lists.add("hello");
lists.remove(0);
lists.set(1, "world");
lists.get(2);

</code></pre></div></div>

<h5 id="linkedlist-常用方法">LinkedList 常用方法</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 队列
LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;();

queue.addLast("hello");
queue.removeFirst();

// 栈
LinkedList&lt;Integer&gt; stack = new LinkedList&lt;&gt;();

stack.push("hello");//top index=0
stack.addFirst("world");
stack.pop();
</code></pre></div></div>

<p>遍历用iterator不能用for循环</p>

<h3 id="hashcode-vs-equals">hashCode() VS equals()</h3>

<p>hashCode() 用于确定本对象在哈希表中的索引位置（如内存地址 =&gt; 整数），大大减少equals()的调用次数，从而提高效率。如HashSet、HashMap及HashTable等散列集合。</p>
<ul>
  <li>定义在 Object 类中，意味着任何类（包括数组）都实现了此方法。</li>
  <li>是本地方法，即用 c/c++ 实现。</li>
</ul>

<ol>
  <li>两个对象相等（引用指向同一个对象） &lt;=&gt; A.equals(B)返回true =&gt; 两个对象 hashcode 相同</li>
  <li>两个对象 hashcode 相同 =&gt; A.equals(B)不一定返回true =&gt; 对象不一定相等（哈希算法，散列，冲突）</li>
  <li>两个对象 hashcode 不同 =&gt; 对象不等</li>
</ol>

<p>为什么重写 equals() 时必须重写 hashCode()?
目的在于，在A.equals(B)返回true的情况下，A, B 的hashCode()要返回相同的值；
如果没有重写，则两个对象无论如何都不会相等（即使它们指向相同的数据）。</p>

<h3 id="set">Set</h3>

<p>Set如何去重/判断已有此对象：</p>
<ol>
  <li>hashCode()得到哈希值（相当于内存地址）</li>
  <li>若hashcode相等则用equals()比较内容重新确定是否存在该元素，若存在则加入失败</li>
</ol>

<p>Set为何无序：
基于哈希表存储
数组 + 链表 + 红黑树 + 哈希算法</p>

<p>哈希算法：</p>
<ul>
  <li>链址法：CRUD性能都很好</li>
</ul>

<p>TreeSet引用类型排序</p>
<ol>
  <li>类重写比较器规则接口Comparable；重写compareTo()或compare()方法</li>
  <li>直接为集合设置比较器Comparable对象，重写比较方法，二者都有时用集合
```
Set sets = new HashSet&lt;&gt;(); // 经典代码</li>
</ol>

<p>//1.
class Employee implements Comparatable<Employee>
{
  @Override
  publicint compareTo(Employee o) {
    if(this.age &gt; o.age) {
      return 1;
    } else if(this.age &lt; o.age) {
      return -1;
    } else {
      return 0;
    }
    //return this.age - o.age; // 差序算法
  }
}</Employee></p>

<p>TreeSet<String> sets = new TreeSet&lt;&gt;();</String></p>

<p>//2.
Set<Employee> e1 = new TreeSet&lt;&gt;(new Comparator<Employee>() {
  @Override
  public int compare(Employee o1, Employee o2) {
    return o1.getAge() - o2.getAge();
  }
});</Employee></Employee></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

### Map

##### HashMap VS HashTable

1. NULL：HashMap允许key和value为null，但 null 作为键只能有一个，null 作为值可有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException
2. 线程安全：HashMap 是非线程安全的；HashTable 是线程安全的

##### HashMap VS HashTree

##### HashMap VS HashSet

##### Map 常用API

```Java
Map&lt;String, Integer&gt; maps = new HashMap&lt;&gt;();

maps.put("Java", 12);
maps.put(null, null);

Integer v = maps.get("Java");

maps.remove("Java");

maps.clear();

maps.containsKey("Java");
maps.containsValue(10);

Set&lt;String&gt; keys = maps.keySet();
for(String key : keys) {
  System.out.println(key);
}

Collection&lt;Integer&gt; values = maps.values();

maps.putAll(maps2);

bool b = Double.compare(d1,d2);
</code></pre></div></div>

<h3 id="遍历集合">遍历集合</h3>

<pre><code class="language-Java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put("Java", "hello");
map.put(null, null);

// 1. for-each循环，效率最高
// keySet集合迭代，打印键值对
for(String key : map.keySet()) {
    System.out.println(key + " : "+ maps.get(key));
}
// 打印值集合
for(String value : map.values()) {
    System.out.println(value);
}
// entrySet集合迭代
// 键值对整体作为Map.Entry&lt;String, String&gt;实体类型，Map转为Set集合
Set&lt;Map.Entry&lt;String, String&gt; &gt; entries = map.entrySet();
for(Map.Entry&lt;String, String&gt; entry : entries) {
  String key = entry.getKey();
  String value = entry.getValue();
}


// 2. 迭代器
// 定义：提供一种方法访问容器对象各个元素，而又不需暴露该对象的内部细节。实质是实现了用于遍历容器的hasNext()和next()方法
// map不同于set和list，不是继承自Collection接口，没有实现Collection的Iterator 方法，自身没有迭代器来遍历元素。
Collection objs = new HashSet&lt;String&gt;();
// 获取集合对应的迭代器
Iterator&lt;String&gt; it = objs.iterator();
while(it.hasNext()) {
    // it.next()方法返回的数据类型是Object，因此需强制类型转换
    String obj = (String) it.next();
    System.out.println(obj);
    if (obj.equals("C语言")) {
        // 从集合中删除上一次next()返回的元素
        it.remove();
    }
    // 对book变量赋值，不会改变集合元素本身
    obj = "C语言";
}
System.out.println(objs);
        
// 3.lambda表达式 JDK1.8后
objs.forEach(s -&gt; {
  System.out.println(s);
});

maps.forEach((K, V) -&gt; {
  System.out.println(k + "=&gt;" + v);
});

// 4. For-Each : JDK1.5+，Java 5 后推出，专门为集合遍历设计
int[] numbers = { 43, 32, 53, 54, 75, 7, 10 };
// for-each语句
for (int item : numbers) {
    System.out.println("Count is:" + item);
}
</code></pre>

<ul>
  <li>continue 语句只能用在 while 语句、for 语句或者 foreach 语句的循环体中</li>
</ul>

<h3 id="collections工具类">Collections工具类</h3>

<p>都是静态方法</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//常用方法:
List&lt;String&gt; names = new ArrayList&lt;&gt;();

Collections.addAll(names, "Tom")
Collections.shuffle(names);// 对List乱序
Collections.sort(names); //对 List排序

//排序：
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面

//查找,替换
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须有序
int max(Collection coll)//返回最大元素。 int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定元素代替指定list中的所有元素
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素
</code></pre></div></div>

<h3 id="可变参数">可变参数</h3>
<p>数据类型…参数列表
在方法内部本质是一个数组
只允许一个可变参数，放在最后</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum(1, 2, 4);
sum(new int[] {1, 2, 4});
</code></pre></div></div>

<h3 id="fail-fast-vs-fail-safe">fail-fast VS fail-safe</h3>

