<blockquote>
  <p>摘要：排序算法总结和比较。</p>
</blockquote>

<!-- more -->

<h2 id="0-内置排序函数">0. 内置排序函数</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// STL&lt;algorithm&gt; 
sort(array);

// js 合并为一个？
function cmp(a, b){return a-b};
arr.sort(cmp);
</code></pre></div></div>

<h2 id="1-插入排序">1. 插入排序</h2>

<h3 id="11-直接插入"><del>1.1 直接插入</del></h3>

<ul>
  <li>基本思想：从后往前查找待插入位置，比待插入元素大的<strong>逐个后移</strong> 哨兵</li>
  <li>最易理解</li>
  <li>性能：
    <ul>
      <li>n（有序）	n^2^ 	n^2^（逆序）</li>
      <li>O(1)</li>
      <li>稳定：一趟排序后，元素放到最终位置</li>
    </ul>
  </li>
</ul>

<h3 id="12-折半插入">==1.2 折半插入==</h3>

<ul>
  <li>
    <p>二分查找，<strong>统一后移</strong>，移动次数不变</p>
  </li>
  <li>
    <p>性能：</p>

    <ul>
      <li>n^2^</li>
      <li>O(1)</li>
      <li>稳定</li>
    </ul>
  </li>
</ul>

<h3 id="13-希尔排序">1.3 希尔排序</h3>

<ul>
  <li>间隔步长倍数位置分为一组，组内直接插入排序；步长d[i]：n/2 -&gt; 1（步长为1的希尔排序即直接插入排序）</li>
  <li>缩小增量
    <h2 id="2-交换排序">2. 交换排序</h2>
  </li>
</ul>

<h3 id="21-冒泡排序">==2.1 冒泡排序==</h3>

<ul>
  <li>基本思想：从后往前，两两排序（逆序则交换）作为一趟冒泡。</li>
  <li>flag 作为一趟冒泡是否发生交换的标志</li>
  <li>性能：
    <ul>
      <li>n	n^2^	n^2^</li>
      <li>O(1)</li>
      <li>稳定：一趟冒泡后，元素放到最终位置
        <h3 id="22-快速排序">==2.2 快速排序==</h3>
      </li>
    </ul>
  </li>
  <li>基本思想：划分（分治法），对左右两部分<strong>递归</strong>快速排序</li>
  <li>平均性能最优 划分最平衡 平均情况最接近最坏情况</li>
  <li>性能：
    <ul>
      <li>n^2^ 	nlgn 	n^2^ （划分不对称）</li>
      <li>递归工作栈：lgn 	n	lgn</li>
      <li>一趟排序后，元素放在最终位置</li>
      <li>提高：
        <ol>
          <li>子序列规模较小时用直接插入</li>
          <li>划分尽量对称</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h2 id="3-选择排序">3. 选择排序</h2>

<h3 id="31-简单选择排序">==3.1 简单选择排序==</h3>
<ul>
  <li>基本思想：一趟排序查找最小（最合适）的元素</li>
  <li>代码最简单</li>
  <li>性能：
    <ul>
      <li>n^2^</li>
      <li>O(1)
        <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 3.1 简单选择排序
// 传向量地址
</span><span class="kt">void</span> <span class="nf">selectSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vt</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// n-1 趟
</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">vt</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>  <span class="n">mini</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
    <span class="c1">// 下一个位置开始
</span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">vt</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 由小到大
</span>        <span class="k">if</span><span class="p">(</span><span class="n">vt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vt</span><span class="p">[</span><span class="n">mini</span><span class="p">])</span>
            <span class="n">mini</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 最小值为当前元素时不移动
</span>    <span class="c1">// 算法笔记说这样提高的效率并不高，可省略
</span>    <span class="k">if</span><span class="p">(</span><span class="n">mini</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">vt</span><span class="p">[</span><span class="n">mini</span><span class="p">],</span> <span class="n">vt</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="32-堆排序">3.2 堆排序</h3>

<ul>
  <li>大根堆：
    <ol>
      <li>完全二叉树；</li>
      <li>任意结点 &gt;= 其子结点和右兄弟结点；</li>
    </ol>
  </li>
  <li>基本思想：
    <ul>
      <li><strong>建堆</strong>：对以 len/2 为根的子树<strong>调整堆</strong>， len/2 -&gt; 1（向前遍历）；</li>
      <li><strong>向下调整堆</strong>（使该子树成为堆）：看子树的根结点是否 &gt;= 左右子结点中的较大值，否则与之交换；交换后可能破坏下一级堆的结构，用<strong>循环</strong>反复比较交换子树结点，直到以该结点为根的子树成为堆为止；</li>
      <li><strong>排序</strong>：初始<strong>建堆</strong>，从堆底开始，循环<strong>弹出堆顶</strong>和<strong>调整堆</strong>，直至剩下一个元素为止。</li>
      <li><strong>弹出（删除）堆顶</strong>：输出堆顶元素，堆顶和堆底交换；</li>
      <li><strong>插入堆顶</strong>：放在堆底，<strong>向上调整</strong>；</li>
    </ul>
  </li>
  <li>性能：
    <ul>
      <li>nlgn</li>
      <li>O(1)</li>
    </ul>
  </li>
</ul>

<h2 id="4-2-路归并排序">4. （2-路）归并排序</h2>

<ul>
  <li>基本思想：将序列看作长度为1的n个有序表，两两归并，直到合并成1个长度为n的有序表。</li>
  <li>A 的左右两段分别有序，双指针，辅助数组B=A</li>
  <li>性能：
    <ul>
      <li>nlgn</li>
      <li>O(n)</li>
      <li>稳定</li>
    </ul>
  </li>
</ul>

<h2 id="5-基数排序">5. 基数排序</h2>

<ul>
  <li>基本思想：统一正整数长度，从最低位开始，对每一位数字排序。</li>
  <li>多关键字排序</li>
  <li>稳定</li>
</ul>
