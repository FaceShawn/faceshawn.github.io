<blockquote>
  <p>摘要：前端基础，包括HTML、CSS、JavaScript等。</p>
</blockquote>

<!-- more -->

<h2 id="前端知识结构">前端知识结构</h2>

<p>HTML：视图层 内容</p>

<p>CSS：表现层 布局</p>

<p>JavaScript：<del>内容层</del> 行为</p>

<p>JQuery：</p>

<h2 id="html">HTML</h2>

<ul>
  <li>HTML 是一种<strong>标记语言</strong>（不是编程语言） 是一套<strong>标记标签</strong></li>
  <li>HTML 文档由<strong>嵌套的 HTML 元素</strong>构成</li>
  <li>元素 = 开始标签（属性、样式等）+ 内嵌内容 + 结束标签  <br /></li>
  <li>版本：HTML4.0.1（1999） HTML5（2014）</li>
  <li>==HTML Data- 属性==</li>
</ul>

<h3 id="兼容">兼容</h3>

<ul>
  <li><code class="highlighter-rouge">&lt;br&gt;</code> <code class="highlighter-rouge">&lt;br/&gt;</code> <code class="highlighter-rouge">&lt;br /&gt;</code>
    <ul>
      <li>HTML5兼容XHTML写法，三种等价。</li>
      <li><code class="highlighter-rouge">&lt;br&gt;</code> 是<strong>HTML</strong>写法。因为HTML是<strong>SGML</strong>的子集，允许没有结束标签，而换行符元素正好不需要<strong>内嵌内容</strong>。</li>
      <li><code class="highlighter-rouge">&lt;br/&gt;</code>  是<strong>XHTML1.1</strong>的写法，也是<strong>XML</strong>写法。因为XHTML是XML的子集，在XML中，标签必须要有结束标签，必须写成<code class="highlighter-rouge">&lt;br&gt;&lt;/br&gt;</code>（HTML解析中被理解为2个<code class="highlighter-rouge">&lt;br&gt;</code>）或简写成<code class="highlighter-rouge">&lt;br/&gt;</code>。</li>
      <li>
        <ul class="task-list">
          <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" /><code class="highlighter-rouge">&lt;br /&gt;</code> 是<strong>XHTML</strong>为兼容<strong>HTML</strong>的写法，也是<strong>XML</strong>写法。
            <ul>
              <li>较少的代码量：在HTML解析中会理解成有”/”的属性的<code class="highlighter-rouge">&lt;br&gt;</code>标签</li>
              <li>规范严谨：在XML解析中会理解成<code class="highlighter-rouge">&lt;br&gt;&lt;/br&gt;</code>的简写</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="元素和标签">元素和标签</h3>

<ul>
  <li>
    <p><code class="highlighter-rouge">&lt;!DOCTYPE &gt; </code> 告知浏览器文档类型</p>

    <ul>
      <li><code class="highlighter-rouge">&lt;head&gt;</code>
        <ul>
          <li>
            <p><code class="highlighter-rouge">&lt;meta&gt;</code> 元数据</p>

            <ul>
              <li>
                <p><code class="highlighter-rouge">http-equiv</code>属性 ：用于模拟一个 http 响应头</p>

                <ol>
                  <li>content-type：字符编码</li>
                  <li>default-style：预定义样式表（ content 属性的值必须匹配同一文档中的一个 link 元素上的 title 属性的值，或者必须匹配同一文档中的一个 style 元素上的 title 属性的值）</li>
                  <li>Set-Cookie：设定 cookie 有效时间。</li>
                  <li>Pragma（cache模式）：禁止浏览器从本地计算机的缓存中访问页面内容。</li>
                  <li>Expires：缓存过期时间</li>
                  <li>X-UA-Compatible：指定网页的兼容性设置</li>
                  <li>viewpoint：针对移动网页优化页面
                    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1, maximum-scale=1"</span><span class="nt">&gt;</span>
</code></pre></div>                    </div>
                  </li>
                  <li>refresh：URL</li>
                </ol>

                <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 每30秒刷新一次 --&gt;</span>
<span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"refresh"</span> <span class="na">content=</span><span class="s">"30"</span><span class="nt">&gt;</span>
</code></pre></div>                </div>
              </li>
              <li><code class="highlighter-rouge">charset</code> 属性：设置字符编码，H5
                <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTML4.01： <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"content-type"</span> <span class="na">content=</span><span class="s">"text/html; charset=gbk"</span><span class="nt">&gt;</span>
HTML5： <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
</code></pre></div>                </div>
              </li>
              <li><code class="highlighter-rouge">name</code> 属性（<code class="highlighter-rouge">keywords，description，author </code> ）  SEO</li>
              <li><code class="highlighter-rouge">content</code> 辅助属性：定义与 http-equiv 或 name 属性相关的内容</li>
              <li><code class="highlighter-rouge">scheme</code> 辅助属性：定义 content 的格式</li>
            </ul>
          </li>
          <li><code class="highlighter-rouge"> &lt;title&gt;, &lt;style&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt;, &lt;base&gt;</code></li>
          <li><code class="highlighter-rouge">&lt;link&gt;</code>
            <ul>
              <li><code class="highlighter-rouge">&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;</code></li>
              <li><code class="highlighter-rouge">&lt;link rel="shortcut icon" href="图片url"&gt;</code></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">&lt;body&gt;</code>
        <ul>
          <li><strong>块级元素</strong>：元素在一块内从上到下<strong>垂直排列</strong>；元素独占一行，默认填满父元素的宽度；宽高的内外边距均可设置；主要做容器容纳其它元素。
            <ul>
              <li><code class="highlighter-rouge">&lt;div&gt;</code>
                <ul>
                  <li>文档布局</li>
                  <li>大的内容块设置样式</li>
                </ul>
              </li>
              <li><code class="highlighter-rouge">&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;，&lt;tr&gt;, &lt;form&gt;， &lt;hr&gt;</code></li>
              <li>元素样式的<code class="highlighter-rouge">display:block;</code></li>
            </ul>
          </li>
          <li><strong>行内（内联）元素</strong>：元素在一行内水平排列；高度由元素的内容决定，宽高（<code class="highlighter-rouge">line-height</code> ）的上下内外边距不可设置；只能容纳<strong>文本</strong>或者其他内联元素。
            <ul>
              <li><code class="highlighter-rouge">&lt;a&gt;, &lt;img&gt;, &lt;br /&gt;, &lt;label&gt;, &lt;span&gt;，&lt;input&gt;</code></li>
              <li>文本/格式化标签
                <ul>
                  <li><code class="highlighter-rouge">&lt;b&gt;</code> <code class="highlighter-rouge">&lt;strong&gt;</code></li>
                  <li><code class="highlighter-rouge">&lt;i&gt;</code> <code class="highlighter-rouge">&lt;em&gt;</code></li>
                  <li><code class="highlighter-rouge">&lt;abbr&gt;</code> 定义缩写</li>
                </ul>
              </li>
              <li>元素样式的<code class="highlighter-rouge">display : inline</code></li>
              <li>设置<code class="highlighter-rouge">float:left/right</code> 后，display属性会变为block，且拥有浮动特性。行内元素去除了之间的莫名空白。</li>
              <li><code class="highlighter-rouge">position:absolute</code> 与<code class="highlighter-rouge">position:fixed</code> 都会使行内元素变为块级元素。</li>
            </ul>
          </li>
          <li>可通过修改<code class="highlighter-rouge">display</code>属性切换
            <ul>
              <li>none：不显示该元素</li>
              <li>inline-block：转换为行内块级元素 <code class="highlighter-rouge">input</code>默认设置</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">&lt;!DOCTYPE&gt;</code></p>

    <ul>
      <li><strong>HTML4.0.1</strong> 基于 SGML，所以引用 DTD （文档类型声明）。三种声明：Strict（<code class="highlighter-rouge">html:4s</code> ）、Transitional（<code class="highlighter-rouge">html:xt</code> 过渡型） 和 Frameset。</li>
      <li><strong>HTML5</strong> <code class="highlighter-rouge">!</code> <code class="highlighter-rouge">html:5</code>  <code class="highlighter-rouge"><span class="cp">&lt;!DOCTYPE html&gt;</span> </code> 告知浏览器文档类型为 HTML5。</li>
    </ul>
  </li>
  <li>字符编码
    <ul>
      <li>ASCII：1位<strong>传输奇偶控制</strong></li>
      <li>HTML5：Unicode 标准（UTF-8 字符集）</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">&lt;a&gt;</code>
    <ul>
      <li>无法通过修改父级标签来改变子级标签特性</li>
      <li>用 CSS 改变样式点击后的样式</li>
      <li>target=”_blank” 属性 在新窗口打开</li>
      <li>始终将正斜杠添加到子文件夹：因为服务器会添加正斜杠到地址，然后创建一个新的请求，总共产生两次 HTTP 请求</li>
    </ul>
  </li>
</ul>

<h3 id="布局">布局</h3>

<h3 id="表单">表单</h3>

<h3 id="事件">事件</h3>

<h4 id="用法">用法</h4>

<ol>
  <li><del>触发 HTML 事件执行 JS</del></li>
</ol>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1</span> <span class="na">id=</span><span class="s">"myTitle"</span><span class="nt">&gt;</span>我是标题~<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">"button"</span> <span class="na">onclick=</span><span class="s">myFun()</span><span class="nt">&gt;</span>标题变色<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;script&gt;</span>
	<span class="kd">function</span> <span class="nx">myFun</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'myTitle'</span><span class="p">).</span><span class="nx">style</span><span class="p">.</span><span class="nx">color</span><span class="o">=</span><span class="s1">'red'</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<ol>
  <li>通过 DOM 向 HTML 元素分配事件</li>
</ol>

<pre><code class="language-HTML">&lt;h1 id="myDate"&gt;日期显灵！&lt;/h1&gt;
&lt;button type="button" id="myBtn"&gt;显示日期&lt;/button&gt;
&lt;script&gt;
    document.getElementById("myBtn").onclick = function() {
        document.getElementById("myDate").innerHTML = Date();
    }
&lt;/script&gt;
</code></pre>

<h4 id="分类">分类</h4>

<ul>
  <li>onload 和 unonload：浏览器信息，处理 cookie</li>
  <li>onchange：元素改变时，如输入字段验证</li>
  <li>onmouseover 和 onmouseout：鼠标移入</li>
  <li>==onmousedown、onmouseup、onclick==</li>
  <li>onkeydown：按下键盘</li>
  <li>==onfocus：获取焦点==</li>
</ul>

<h3 id="监听事件">监听事件</h3>

<ul>
  <li>addEventListener()：向指定元素添加<strong>事件句柄</strong></li>
</ul>

<h3 id="seo">SEO</h3>

<ul>
  <li>Search Engine Optimization（搜索引擎最佳化）</li>
  <li>影响标签
    <ul>
      <li><code class="highlighter-rouge">&lt;title&gt;</code></li>
      <li><code class="highlighter-rouge">&lt;meta&gt;</code></li>
      <li><code class="highlighter-rouge">&lt;h1&gt;</code></li>
      <li><code class="highlighter-rouge">&lt;img alt="" &gt;</code></li>
    </ul>
  </li>
</ul>

<h2 id="html5">HTML5</h2>
<ul>
  <li>设计目的：为了在移动设备上支持多媒体。</li>
</ul>

<h3 id="新特性">新特性</h3>

<ol>
  <li>canvas 元素：画布容器</li>
  <li>多媒体元素： video，audio</li>
  <li>新的8个<strong>语义元素</strong>，都为块级元素，header, nav, section, article, aside,footer,  main,  figure；已移除标签（<code class="highlighter-rouge">&lt;font&gt;, &lt;center&gt;, &lt;strike&gt;</code>）和属性:（<code class="highlighter-rouge">color ， bgcolor</code>）</li>
  <li>新的表单输入控件，比如 color， calendar、date、time、email、url、search，range；datalist，keygen，output</li>
  <li>对<strong>本地离线存储</strong>的更好的支持</li>
  <li>缓存引用</li>
  <li>本地 SQL 数据</li>
  <li>Web 应用</li>
  <li>完全支持 CSS3，新选择器</li>
  <li>XHTMLHttpRequest 2</li>
</ol>

<h3 id="浏览器支持">浏览器支持</h3>

<ul>
  <li>IE8及更早不支持：<strong>shiv</strong>注释，解决HTML5的新元素不被IE6-8识别的问题。</li>
</ul>

<h2 id="css">CSS</h2>

<h3 id="插入方式">插入方式</h3>

<ul>
  <li>内联样式：在元素中使用 style 属性</li>
  <li>内部样式表：在 head 中使用 style 标签</li>
  <li>外部引用</li>
</ul>

<h3 id="属性">属性</h3>

<ul>
  <li>font-family 字体：文泉驿微米黑</li>
  <li>text-align 居中对齐</li>
  <li>
    <p>颜色</p>
  </li>
  <li>选择器：<code class="highlighter-rouge">#</code>， <code class="highlighter-rouge">[标签名]</code>  +<code class="highlighter-rouge">.</code></li>
  <li>==盒模型==</li>
</ul>

<h2 id="css3">CSS3</h2>

<h3 id="新特性-1">新特性</h3>

<ul>
  <li>新属性</li>
  <li>动画</li>
  <li>2D/3D 转换</li>
  <li>圆角</li>
  <li>阴影效果</li>
  <li>可下载的字体</li>
</ul>

<h2 id="dom">DOM</h2>

<ul>
  <li>
    <p>DOM 树</p>
  </li>
  <li>
    <p>DOM（Document  Object Model）（文档对象模型）， W3C 标准，描述<strong>处理网页内容</strong>（HTML）的方法和接口，将文档解析为<strong>结点对象</strong>组成的 DOM 树，用于改变文档内容</p>
  </li>
  <li>
    <p>BOM（浏览器对象模型），描述<strong>与浏览器进行交互</strong>的方法和接口</p>
  </li>
  <li>
    <p>查找 HTML 元素</p>

    <ol>
      <li>Id</li>
      <li>TagName</li>
      <li>ClassName</li>
    </ol>
  </li>
  <li>
    <p>修改 HTML 元素的内容和属性</p>

    <ul>
      <li>innerHTML</li>
    </ul>
  </li>
  <li>
    <p>修改 HTML 元素的样式</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>document.getElementById("p2").style.color="blue";
</code></pre></div>    </div>
  </li>
  <li>
    <p>增删 HTML 元素</p>
  </li>
</ul>

<h2 id="javascript">JavaScript</h2>

<ul>
  <li>轻量级<strong>解释型脚本语言</strong> 逐行执行 用于交互</li>
  <li>ECMAScript，描述了该语言的语法和基本对象 ES6</li>
</ul>

<h3 id="数据类型">数据类型</h3>

<ul>
  <li>分为字面量和变量，狭义指变量数据类型</li>
  <li><strong>动态语言</strong>：变量数据类型可变</li>
  <li>变量均为对象，可用 new + 对象 声明变量类型</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注意没括号</span>
<span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Number</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>typeof</p>
  </li>
  <li>undefined 与 null 区别
    <ol>
      <li>二者值相等， null == undefined</li>
      <li>类型不同</li>
      <li>null为空对象引用 用于比较大的对象释放内存时，清空变量</li>
    </ol>
  </li>
  <li>
    <p>Date</p>

    <ul>
      <li>( new Date() ).getTime() 时间戳</li>
    </ul>
  </li>
  <li>
    <p><strong>强制类型转换</strong></p>

    <ol>
      <li><code class="highlighter-rouge">Boolean(value)</code>—-转换成Boolean型：至少有一个字符的字符串、非0数字或对象时，返回true。<strong>空字符串、数字0、undefined或null</strong>，返回false。</li>
      <li><code class="highlighter-rouge">Number(value)</code>—-转换成整数或浮点数；</li>
      <li><code class="highlighter-rouge">String(value)</code>—-转换成字符串。</li>
      <li>(123).toString();</li>
    </ol>
  </li>
  <li><a href="https://juejin.im/post/5b2b0a6051882574de4f3d96">https://juejin.im/post/5b2b0a6051882574de4f3d96</a></li>
</ul>

<h3 id="运算符">运算符</h3>

<ul>
  <li>运算
    <ul>
      <li>+：加法和字符串连接 <code class="highlighter-rouge">3+"5"</code>–&gt;<code class="highlighter-rouge">35</code></li>
      <li>/：</li>
    </ul>
  </li>
  <li>比较
    <ul>
      <li>=== 数据类型和值绝对相等</li>
      <li>！== 值和类型至少一个不等</li>
    </ul>
  </li>
  <li>逻辑</li>
  <li>连等
    <ul>
      <li>a.x 的指针没有被创建，则声明并指向 null，此时指针地址已固定</li>
      <li>a 的指针已被创建，找到它</li>
      <li>从右到左，以上两指针分别指向 { n : 2 }</li>
    </ul>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 赋值结果</span>
<span class="nx">a</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="na">n</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">b</span> <span class="o">=&gt;</span> <span class="p">{</span>	<span class="na">n</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> 
    	<span class="na">x</span><span class="p">:</span> <span class="p">{</span> <span class="na">n</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span> 
     <span class="p">}</span>   
</code></pre></div></div>

<p><img src="assets/1848889943-551af9462713a_articlex.png" alt="åéå³ç³&quot;å¾" /></p>

<h3 id="作用域">作用域</h3>

<ul>
  <li>作用域是<strong>可访问变量</strong>，对象，函数的集合</li>
  <li>非严格模式下给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 没有用 var 声明，则为全局变量</span>
<span class="c1">// 自动作为 window 对象的属性，可删除</span>
<span class="nx">name</span> <span class="o">=</span> <span class="s2">"Harry"</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>严格模式：”use strict”</li>
  <li>重新声明变量，值不丢失</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">carname</span><span class="o">=</span><span class="s2">"Volvo"</span><span class="p">;</span> 
<span class="kd">var</span> <span class="nx">carname</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="语法">语法</h3>

<ul>
  <li>顺序</li>
  <li>条件</li>
  <li>循环
    <ul>
      <li>for/in 循环遍历<strong>对象</strong>的属性，会跳过未定义的元素；for 会输出 undefined</li>
      <li>continue 只能用于循环</li>
      <li>break 只能用于循环和 switch 中： 默认标签为当前代码块</li>
      <li>break 通过 label 标签引用可跳出任何代码块，可用于多层循环时控制外层循环</li>
    </ul>
  </li>
  <li>输出
    <ol>
      <li>window.alert(“”)</li>
      <li>innerHTML()  =</li>
      <li>console.log(“”) 和 console.info(“”)</li>
      <li>document.write(“”)</li>
    </ol>
  </li>
</ul>

<h3 id="数字">数字</h3>

<ul>
  <li>浮点数精度问题</li>
  <li>浮点数存储
    <ul>
      <li>使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数</li>
    </ul>
  </li>
</ul>

<p><img src="assets/687474703a2f2f617461322d696d672e636e2d68616e677a686f752e696d672d7075622e616c6979756e2d696e632e636f6d2f37323637613538623239383932633362373233653364366333663733393035612e706e67.png" alt="64 bit allocation" /></p>

<p><img src="assets/31601625-1f199ad0-b220-11e7-9d46-bb48a470bedf.png" alt="latex expression" /></p>

<ul>
  <li>
    <p>浮点数四则运算 浮点数无法精确表示</p>

    <ul>
      <li><a href="https://github.com/camsong/blog/issues/9">浮点数陷阱</a> Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);</li>
    </ul>
  </li>
  <li>
    <p>大数危机</p>

    <ul>
      <li><strong>[Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]</strong> 的整数都可以精确表示</li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">toPrecision</code> 是处理精度，精度是从左至右第一个不为0的数开始数起。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">toFixed</code> 是小数点后指定位数取整，从小数点开始数起。四舍五入结果不准确</p>
  </li>
</ul>

<h3 id="对象">对象</h3>

<ul>
  <li>JS 对象是变量（键值对）（对象属性和方法）的<strong>容器</strong></li>
  <li>类似 C 里的<strong>哈希表</strong> 和 PHP 里的<strong>关联数组</strong></li>
</ul>

<h3 id="数组">数组</h3>

<ul>
  <li>不支持名字索引数组，可以索引对象</li>
  <li>用名字索引数组会导致数组重定义为标准对象，数组的方法及属性都将失效</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 初始化</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">];</span>

<span class="c1">// 尾增</span>
<span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">55</span><span class="p">);</span>
<span class="c1">// 尾删</span>
<span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
<span class="c1">// 首删</span>
<span class="kd">var</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>

<span class="c1">// 替换，可作删除用</span>
<span class="nb">Array</span> <span class="nx">array</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">howmany</span><span class="p">,</span> <span class="p">[</span><span class="nx">item1</span><span class="p">,</span> <span class="p">.....,</span> <span class="nx">itemX</span><span class="p">]</span> <span class="p">);</span>

<span class="c1">// 按值查索引</span>
<span class="kd">var</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
<span class="c1">// 按区间[startIndex, endIndex)查</span>
<span class="nb">Array</span> <span class="nx">array</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">);</span>

<span class="c1">// 长度</span>
<span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

<span class="c1">// 排序</span>
<span class="c1">// 默认为按字母升序	</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">sort</span><span class="p">();</span>
<span class="c1">// 反序，可实现按字母降序</span>
<span class="nx">str</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span>
<span class="c1">// 按数字升序</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)(</span><span class="k">return</span> <span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">)</span> <span class="p">);</span>
</code></pre></div></div>

<h3 id="字符串">字符串</h3>

<ul>
  <li>转换为数字
    <ol>
      <li>parseInt( ) 方法：字母标点截断，基模式，<code class="highlighter-rouge">010</code>默认八进制</li>
      <li>parseFloat( ) 方法：没有基模式，默认十进制</li>
      <li>Number( ) 强制类型转换</li>
      <li>弱类型用运算符转换</li>
    </ol>
  </li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ '' // 等价于 String(X)
+X     // 等价于 Number(X),也可以写成 x-0
!!X    // 等价于 Boolean(X)

var str= '012.345 ';  
var x = str-0;  
x = x*1;
</code></pre></div></div>

<h3 id="正则表达式">正则表达式</h3>

<ul>
  <li>修饰符 表达式 元字符 量词</li>
  <li>最常用的两个方法：
    <ul>
      <li>search()：</li>
      <li>replace()：</li>
    </ul>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s2">"Visit Runoob!"</span><span class="p">;</span> 
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">search</span><span class="p">(</span><span class="sr">/runoob/i</span><span class="p">);</span>
<span class="c1">// 下标 n = 6</span>
<span class="kd">var</span> <span class="nx">txt</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/Runoob/</span><span class="p">,</span> <span class="s2">"Replace！"</span><span class="p">);</span>
<span class="c1">// 文本 txt = Visit Replace！</span>
</code></pre></div></div>

<h3 id="函数">函数</h3>

<ul>
  <li>函数提升：先调用后定义，实质是作用域的提升；用<strong>表达式定义</strong>的函数无法提升</li>
  <li>对象方法：对象的构造方法</li>
</ul>

<h4 id="函数定义">函数定义</h4>

<ul>
  <li>箭头函数
    <ul>
      <li>默认绑定外层 this 的值，this 和外层的 this 相同</li>
      <li>不能提升</li>
      <li>const 比 var 安全，因为函数表达式始终是一个常量</li>
    </ul>
  </li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1.表达式定义</span>
<span class="kd">function</span> <span class="nx">f</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{};</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">// 2.匿名函数：没有函数名</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">};</span>
<span class="c1">// 通过变量名调用匿名函数</span>
<span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">x</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="c1">// 3.也可以自调用</span>
<span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="s2">"Hello!!"</span><span class="p">;</span>
<span class="p">})();</span>

<span class="c1">// 4.Function() 构造函数</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">,</span> <span class="s2">"return a * b"</span><span class="p">);</span>

<span class="c1">// 5.箭头函数，ES6，f 作函数名</span>
<span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
<span class="c1">// 二者作用相同</span>
<span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span> <span class="p">};</span>
</code></pre></div></div>

<h4 id="函数参数">函数参数</h4>

<ul>
  <li>显示参数和隐式参数，ES6可设置默认参数</li>
  <li>内置 Arguments 对象：函数调用的参数数组</li>
  <li>通过<strong>值传递</strong>参数：隐式参数的改变在函数外是不可见的。</li>
  <li>通过<strong>对象传递</strong>参数：在函数内部修改对象的属性会修改其初始值。</li>
</ul>

<h4 id="函数调用">函数调用</h4>

<ul>
  <li>函数有 4 种调用方式，不同在于 <strong>this</strong> 的初始化。一般而言，<strong>this</strong> 指向函数执行时当前对象。
    <ol>
      <li>作为函数调用：<strong>this</strong> 指向全局对象；</li>
      <li>作为方法调用：<strong>this</strong> 绑定到所属对象；</li>
      <li>用构造（器）函数调用，创建一个新对象，继承构造函数的属性和方法：<strong>this</strong> 指向新创建的实例；</li>
      <li>作为函数方法调用，call() 和 apply()。this 显式函数绑定：call() 和 apply() 方法允许切换函数执行的上下文环境，可以将 this 指向任何对象。在严格模式下，this 是 undefined？
        <ul>
          <li>bind()</li>
          <li>apply() <code class="highlighter-rouge">a.say.apply(b)</code>;传参数数组</li>
          <li>call()：参数列表</li>
        </ul>
      </li>
      <li>在事件中，this 指向接收事件的元素。</li>
      <li>==指向正在执行的函数本身==</li>
    </ol>
  </li>
</ul>

<h4 id="回调函数">回调函数</h4>

<ul>
  <li>回调陷阱</li>
</ul>

<h4 id="计数器困境内嵌函数闭包">计数器困境、内嵌函数、闭包</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();
 
add();
add();
add();
 
// 受外层匿名自我调用函数的作用域保护，只能用 add() 修改
// 计数器 add.counter = 3
</code></pre></div></div>

<h3 id="内存管理-垃圾回收机制">内存管理 垃圾回收机制</h3>

<h4 id="深拷贝和浅拷贝的实现">深拷贝和浅拷贝的实现</h4>

<h3 id="性能优化">性能优化</h3>

<h3 id="json">JSON</h3>

<ul>
  <li>存储和传输数据的格式</li>
  <li>大括号保存对象</li>
  <li>方括号保存数组</li>
  <li>数组、对象可相互嵌套</li>
  <li>var obj = JSON.parse( jsonStringData );</li>
  <li>var jsonStringData  = JSON.stringify( obj );</li>
</ul>

<h3 id="表单-1">表单</h3>

<ul>
  <li>表单（自动）验证</li>
  <li>数据验证</li>
  <li>H5 约束验证
    <ul>
      <li>HTML 输入属性</li>
      <li>CSS 伪类选择器</li>
      <li>DOM 属性和方法</li>
    </ul>
  </li>
</ul>

<h3 id="错误和调试">错误和调试</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>try {
} catch(e) {
} throw {  
} finally {  
}
</code></pre></div></div>

<h3 id="es6">ES6</h3>

<ul>
  <li>类和模块化</li>
  <li>箭头函数</li>
  <li>promise</li>
</ul>

<h2 id="nodejs">Node.js</h2>

<ul>
  <li>运行在服务端的 JavaScript 事件驱动 I/O 基于 Google  的 V8 引擎</li>
</ul>

<p><a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">https://www.runoob.com/nodejs/nodejs-tutorial.html</a></p>

<h2 id="php">PHP</h2>

<h4 id="include-和-require">include() 和 require()</h4>

<table>
  <thead>
    <tr>
      <th>区别</th>
      <th>include()</th>
      <th>require() ~ include_once()</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>性能</td>
      <td>每次都读取一遍文件</td>
      <td>只处理一次（本质是替换）</td>
    </tr>
    <tr>
      <td>效率</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>加载失败</td>
      <td>warning 警告，但脚本继续执行（4.3.5 前）</td>
      <td>fatal error 错误，脚本停止执行</td>
    </tr>
    <tr>
      <td>位置</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="经典面试问题">经典面试问题</h2>

<ul>
  <li>JS
    <ol>
      <li>数据类型有哪些 undefined 与 null 区别</li>
      <li>对原型链的了解</li>
      <li>对跨域的了解</li>
      <li>call、apply、bind的区别</li>
      <li>介绍闭包</li>
      <li>深拷贝和浅拷贝的区别</li>
      <li>使用let、var和const创建变量有什么区别 介绍变量提升</li>
      <li>cookie、localStorage、sessionStorage区别</li>
    </ol>
  </li>
  <li>HTML
    <ol>
      <li>块级元素与内联元素的区别</li>
      <li><code class="highlighter-rouge">&lt;img&gt;</code>的<code class="highlighter-rouge">title</code>和<code class="highlighter-rouge">alt</code>有什么区别</li>
    </ol>
  </li>
  <li>CSS
    <ol>
      <li>水平垂直居中的几种方式</li>
      <li>清除浮动的几种方式</li>
      <li>display:none、visibile:hidden 区别</li>
    </ol>
  </li>
</ul>
