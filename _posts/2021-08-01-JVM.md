---
title: JVM
categories:
  - Java
tags:
location:
abbrlink: '828fj398'
permalink: '828fj398'
date: 2021-08-01 13:42:12
updated: 2021-08-01 13:42:12
---

> 摘要：Java高级之JVM虚拟机，包括类加载机制，创建对象，内存分配机制，GC垃圾回收，JVM调优等。

<!-- more -->

## JVM 虚拟机

### main() 方法的执行步骤

```
Student stu = new Student("Tom");
stu.sayName();
```

<img src="assets/stack_heap_method_area.jpg" alt="img" style="zoom:70%;" />

1）字节码执行机制：

- 编译 App.java 得到 App.class。

2）类加载机制：

1. **加载 App 类**：系统启动一个 JVM 进程，从 classpath 路径中查找 App.class，将 App 的类信息加载到方法区；
2. 找到 App 类中的主程序入口，执行 **main()**；
3. 检查是否已**加载 Student 类**：（在常量池中）定位**类的符号引用**；
4. 若无则加载 Student 类：加载类信息到方法区。

3）new 创建 student 对象：

1. 在局部变量表创建变量 `stu`，字面量`"Tom"`放在方法区；
2. **内存分配机制（GC）**：在（堆中）为 Student 对象分配内存，并将对象引用赋给变量 stu；
3. 构造器**初始化** Student 对象，（有**指向方法区中 Student 类的类型信息**的引用）；
4. 根据 stu 引用找到 Student 对象，获取 `sayName()` 的字节码地址，执行 `sayName()`。

### 字节码执行机制

字节码：JVM 可理解的代码（即扩展名为 .class 的文件）。

##### 编译与解释共存

1. 先编译，编译后不直接运行，而是通过解释运行。
2. JIT （just-in-time compilation） 即时编译器： 属于运行时编译。完成第一次编译后，将（热点代码的）字节码对应的机器码保存下来，下次可直接用。

JVM VS 传统解释型语言：

1. 保留优点：可移植；
2. 一定程度上解决缺点：执行效率低。

<img src="assets/class_file_compile_explain.png" alt="在这里插入图片描述" style="zoom: 45%;" />

##### Java 程序运行过程

- `->源文件(.java）`
- **编译**：`->Javac 编译器->Java字节码文件（.class）`
- `->JVM->（特定系统可执行的二进制）机器码`
  - `->Class Loader 加载.class文件`
  - **解释**：`->Execution Engine 通过解释器逐行解释执行，执行速度相对较慢`
  - `->Runtime Data Area（运行时数据区，即常说的JVM内存）`

### 类加载机制

ClassLoader：用来加载 Class，负责将 Class 的字节码形式转换成内存形式的 Class 对象。

##### 类加载步骤

根据（常量池中的）动态链接定位**类的符号引用**，检查当前类是否已被加载：
1. 已被加载的类直接返回；
2. 否则尝试加载类。

**加莲厌准姐初**

![img](assets/class_load_step.png)

- 加载：
  1. 根据类名查找 .class 文件，将 class 文件加载到内存；
  2. 将静态存储结构转换成（方法区中的）运行时数据结构；
  3. 在（堆）内存中生成类的 Class 类对象，作为方法区数据的访问入口；
- 连接：
  1. 验证：确保文件格式、字节码结构等符合 JVM 安全规范；
  2. 准备：为 static 变量（在堆中）分配内存，并设置0值；
  3. 解析：将（常量池内的）符号引用替换为直接引用；
- 初始化：执行构造器，初始化实例成员变量和真正初始化 static 成员变量。

```
public static int i =3 ;
//第一次初始化后i的值为0，
//第二次初始化后值才为3.
```

- 使用：一旦某个类的 Class 对象被载入内存，.class文件就被用来创建这个类的所有（实例）对象。

- 卸载：GC将无用类从内存中卸载。

##### 双亲委派模型

工作过程：类加载器收到类加载请求后，

1. 首先判断当前类是否被加载过，已被加载的类会直接返回；
2. 若未被加载（加载未知类时）：

   - 自底向上委派：首先委派给父类加载器，递归执行1；
   - 自顶向下查找：当父类加载器无法处理时，才由自己来处理；

3. 如果都没有加载此类，则抛出 ClassNotFoundException 异常。

检查顺序：`CustomClassLoader -> AppClassLoader -> ExtensionClassLoader -> BootstrapClassLoader`

不同层次的类加载器有不同优先级：

- =>可避免重复加载类；
- =>保证核心 API 不被修改。

##### Tomcat 与双亲委派模型

- 不能用默认的类加载机制：
  1. 一个web容器可能部署两个应用程序，可能会依赖同一个第三方类库的不同版本；默认的 ClassLoader 无法加载相同类库的不同版本。
  2. 同一个web容器中相同的类库相同的版本可共享；符合双亲委派。
  3. web容器自己依赖的类库（tomcat lib目录下），不能与应用程序的类库混淆；同第一条。
  4. ~~web容器要支持jsp文件的热加载。~~
- Tomcat 未完全违反双亲委派机制，核心的 Java 加载仍遵从双亲委派：
  - Tomcat 中各个web应用自己的类加载器（WebAppClassLoader）会优先加载，打破了双亲委派机制，加载不到时再交给 commonClassLoader 走双亲委托 。
- Tomcat 独特的类加载机制：
  - Bootstrap 引导类加载器：加载 JVM 启动所需的类，以及标准扩展类（位于jre/lib/ext下）；
  - System 系统类加载器：加载 Tomcat 启动的类，如 bootstrap.jar，~~通常在 catalina.bat 或catalina.sh中指定。位于CATALINA_HOME/bin下。~~
  - Common 通用类加载器：加载 Tomcat 依赖包、应用通用的一些类，在CATALINA_HOME/lib下，如：servlet-api.jar。
  - webapp 应用类加载器：每个应用在部署后，都会创建一个唯一的类加载器。加载 `WEB-INF/classes`下应用自定义的的类和 `WEB-INF/lib`下的jar应用依赖包中的类。

<img src="assets/tomcat_parent.png" alt="img" style="zoom:45%;" />

详解：[Tomcat - 都说Tomcat违背了双亲委派机制，到底对不对？](https://cloud.tencent.com/developer/article/1862861)、~~[图解Tomcat类加载机制(阿里面试题)](https://www.cnblogs.com/aspirant/p/8991830.html)~~

##### 常用类加载器

ClassLoader：用来动态加载（按需加载）.class 字节码文件到 JVM 内存（=> 内存形式的 Class 对象）

1. Bootstrap ClassLoader：最顶层的启动类加载器，由 C++实现，随 JVM 启动，负责加载 JDK 中的核心类库（`%JAVA_HOME%/lib`目录下的 jar 包和类）、构造其它 ClassLoader；
2. Extension ClassLoader：负责加载 JVM 扩展类库（ `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，通常以 javax 开头）；
3. Application ClassLoader：面向用户的加载器，负责加载当前 classpath 路径下的 jar 包和类。
4. UserDefinedClassLoader：

JVM搜索类时判断两个class是相同的，要同时满足：
1. 两个类名相同（同一份class字节码）；
2. 由同一个类加载器加载。

对于`equals()、isinstanceof()`等方法来判断对象相等或所属关系都是需要基于同一个ClassLoader。

##### 创建对象

类的实例化顺序：

- 先静态、先父后子。
- 按在代码中出现的顺序依次执行

加载类：

1. 父类静态成员变量、静态初始化块/静态代码块（只执行一次）
2. 子类静态成员、静态初始化块

创建对象：

1. 父类实例成员、实例初始化块
2. 父类构造器
3. 子类实例成员、实例初始化块
4. 子类构造器
5. 普通代码块

**创建对象的步骤**：

1. 类加载：JVM遇到一条 new 指令时，执行类加载，完成后可确定所需内存大小；
2. （为新对象在堆中）分配内存（若内存不够则先执行[GC](#回收策略)）；
3. 将成员变量初始化为0值；
4. **设置对象头**；
5. **执行 init 方法**：初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址（引用）赋值给（vm栈中的）变量。

**对象在堆内存的存储布局**：

1. 对象头：
   - MarkWord：存储哈希码、分代年龄、（锁状态标志位、）线程持有的（轻/重量级）锁、偏向锁线程ID等信息。
   - 存储类型指针：指向类的元数据指针，确定对象是属于哪个类的实例。数组长度。
2. 实例数据：存储代码中所定义的各种类型的字段信息。

3. 对齐填充：起占位作用。HotSpot 要求对象的起始地址必须是8的整数倍。。

```
String str = new String("hello");
// 变量str放在VM栈上的局部变量表中
// 用new创建出来的String对象放在堆中
// 而"hello"这个字面量放在方法区的运行时常量池
```

### JVM 内存分配机制

<img src="assets/JVM内存分配.png" style="zoom: 50%;" />

自动内存管理：最核心的是堆内存中对象的分配与回收。

#### 运行时数据区

每个进程分配一块 JVM 运行时数据区（RunTime Data Area）/ 内存空间，分为两种类型：

1. 线程私有：生命周期与线程相同，依赖用户线程（而创建/销毁）；包括程序计数器、虚拟机栈、本地方法栈；
2. 所有线程共享：生命周期与 JVM 相同，随 JVM 的启动/关闭（而创建/销毁）；包括堆、方法区。

栈负责执行方法（运行代码），存放局部变量；堆负责存储数据（对象等）。

##### PC 程序计数器

表示当前线程（所执行字节码）的行号指示器，由字节码执行引擎负责修改：

- Java 方法中：存储的是（下一条）字节码指令（在方法区）的地址；
- native 方法中：undefined。

唯一没有OOM（内存溢出）和 StackOverflowError 的内存区域。

##### 虚拟机栈

是描述 Java 方法执行的内存模型；每个 Java 方法在执行时会创建一个栈帧，方法从开始调用到执行完成，就是栈帧从入栈到出栈的过程。用于存储：

1. 局部变量表：存放编译期可知的数据类型（如方法参数和局部变量）：
  - 对于基本数据类型的变量，直接存值；
  - 对于引用类型的变量，存的是指向对象的引用。
2. 操作数栈：压栈和出栈操作，弹出数据、执行运算、结果压栈；
3. 动态链接：指向运行时常量池的（当前）方法（的）引用；部分方法在编译期无法确定，只能在程序运行期间将调用方法的**符号引用**转换为直接引用。
4. 方法出口（返回地址）等。

易出的错误：

- StackOverFlowError（VM栈的内存大小不允许动态扩展）：栈帧中的局部变量过多时（常出现在递归、循环调用中）=> 线程请求栈的深度`>`当前VM栈的最大深度；
- OutOfMemoryError（VM栈的内存大小允许动态扩展）：堆中没有空闲内存，且GC也无法提供更多内存 => 无法申请到内存时抛出；

##### 本地方法栈

为VM用到的 Native 方法服务，其它与VM栈一致。

##### 堆

存储对象本身（由 new 和构造器创建）及数组本身，但引用在VM栈的局部变量表中；是 JVM 所管理的内存中最大的一块，在 JVM 中只有一个堆，GC 主要管理的对象；

- 内存空间/物理上可不连续，但逻辑上应连续；
- JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中；
  - 字符串常量池：保存 String 对象实例本身，供运行时常量池引用；
  - 静态变量
- 分为：
  - 新生代：Eden 伊甸区、Surviveor From（S0）、Surviveor To（S1）；
  - 老年代
- JDK1.8 前，HotSopt 虚拟机的方法区又被称为永久代；

<img src="assets/heap_structure.png" alt="img" style="zoom: 67%;" />

易出的错误：

- OutOfMemoryError: GC Overhead Limit Exceeded:：GC上限超出，GC 时间长，但只回收了很少的堆内存；
- OutOfMemoryError: Java heap space：堆内存不足以存放新创建的对象；

#### 本地内存

（JDK1.7 及以前）HotSpot 用永久代（PermGen）实现方法区，习惯上把方法区称为永久代：

- 运行时常量池：
  - 字符串常量池：JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中；
  - 剩余部分。

JDK1.8：取消永久代，用 Metaspace 元空间实现方法区；实际位于本地内存中。

<img src="assets/method_area.png" alt="img" style="zoom:50%;" />

##### 方法区

《深入理解 Java 虚拟机》书中，方法区（Method Area）用于存储已被虚拟机加载的：

1. 类信息；
2. 常量；
3. 静态变量；
4. 即时编译器编译后的代码缓存等。

方法区用于存储虚拟机加载的字节码文件。

（根据 `jclasslib Bytecode viewer` 反编译插件解析的）.class 字节码文件包括：

1. 一般信息：
   1. 魔数：字节码文件的标志，确定此文件能否被虚拟机接收，是一个固定值 `0XCAFEBABE`；
   2. 主版本号（如表示 JDK1.8）和次版本号；
   3. 访问标志（修饰符）：用于识别类或接口层次的访问信息，包括：是类还是接口，是否为 public 或 abstract 类型，是否声明为 final 等；
   4. 本类索引、父类索引：用于确定当前类和父类的全限定名；指向常量池。
2. 静态常量池（表）=>加载到运行时常量池；主要存放两类常量：
   - 字面量：
     - 文本字符串 `"hello"`=>加载进字符串常量池；JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中；
     -  `final` 常量值、基本数据类型的值15等；
   - 和（类的）符号引用：1. 类和接口的全限定名、2. 字段名和描述符、3. 方法名和描述符。
     - 类加载时，部分符号引用会替换为直接引用，如类的静态方法、私有方法，构造方法，父类方法（因为这些方法不能被重写），而其他方法在第一次调用时才转变。
3. 接口（索引集合）：用来描述类实现的接口；指向常量池。
4. 字段（表集合）：（接口或类中声明的）**静态变量**和实例变量（方法内声明的参数和局部变量在局部变量表中）。=> JDK1.7 字符串常量池和静态变量被从方法区拿到了堆中。
5. 方法（表集合）：描述方法的定义部分，包括访问修饰符、返回类型、方法名等。
6. 属性（表集合）：方法的代码实现 => JIT 即时编译器编译后的代码（缓存）。

HotSpot 把 GC 分代收集扩展至方法区, 即用堆的永久代来实现方法区；

对方法区内存回收的主要目标是：对常量池的回收和对类的卸载。

易出的错误：

- OutOfMemoryError

##### 直接内存/堆外内存

由OS管理；JDK 1.4 引入的 **NIO** 提供了基于Channel与 Buffer的IO方式，可用 Native 函数库直接分配堆外内存, 用 DirectByteBuffer 对象作为这块内存的引用进行操作, 避免了在 Java堆和 Native 堆中来回复制数据。

### GC 垃圾回收

##### 引用类型

1. 强引用：当内存不足时，JVM 宁可出现 OOM 也不回收，和 GC Roots 断绝关系时才回收（如显式地将引用置为 `null`）；常用于普通的对象引用关系，如 `String s = new String("Const")`；
2. **软引用**：当内存不足时回收，如果回收后仍内存不足，抛出内存溢出异常；由 `SoftReference` 类创建；用于维护一些可有可无的对象，常用于高速缓存中，如 mybatis、浏览器的后退按钮；
3. 弱引用：下一次GC时回收，由 `WeakReference` 类创建；
4. 虚引用：跟没有一样，形同虚设。

##### 如何判断可被回收 / 回收时机

1）废弃常量（被运行时常量池回收）：没有被任何对象引用。

2）无用类（被方法区卸载/回收）：需同时满足

1. 类的所有实例都已被回收；
2. 加载类的 ClassLoader 已被回收；
3. 类对应的 Class 对象没有任何引用，无法通过反射访问该类的方法。

3）已死亡对象（被堆回收）：

- 没被引用的/超过作用域的对象；
- （强）引用被置为null（变为弱引用），在下一次GC回收；

方法：

- ~~引用计数器法~~：一个对象没有任何关联引用时回收；无法解决**对象循环引用**；
- 可达性分析法：将GC Roots对象作为起始的存活对象集，向下**搜索**走过的路径（**引用链**/可达路径），
  1. 把能被该集合引用的对象递归加入到集合中（移动到S0）；
  2. 不能被引用（即对象到GC Roots没有任何引用链/该对象是不可达的）；二次标记后还没成功逃脱，只能被回收。

可作为GC Roots的对象：
1. 虚拟机栈（局部变量表）中引用的对象，如方法参数、局部变量、临时变量等；
2. 本地方法栈中 `JNI` 引用的对象；
3. （堆中）类的静态变量引用的对象；
4. （方法区中）[运行时常量池](#方法区)引用的对象。
5. JVM 内部的引用，如基本数据类型的 Class 对象，系统类加载器等。

##### 回收算法

1. 堆内存不规整 => Mark-Sweep（标记-清除）算法：维护**空闲列表**，记录可用内存，标记结束后统一回收；易产生内存碎片；
2. Copying（复制）算法：将可用内存按容量划分为大小相等的两块，当一块内存用完后，将存活的对象移动到另一块，交换指针，清理已用内存；可用内存减为原来的一半，如果存活对象很多，效率会降低；
3. 堆内存规整（没有内存碎片） => Mark-Compact（标记-整理）算法：指针碰撞，将存活对象都向一端移动，清除边界外的；
##### 分代回收策略

核心思想是根据**对象存活的生命周期**将内存划分为若干个区域。JDK1.8 后：

<img src="assets/generation_gc.png" alt="img" style="zoom: 67%;" />

1. 新生代：复制算法，分为一块较大的 Eden 伊甸空间和两块较小的 `From Survivor0` 和 `To Survivor1` 空间（8：1：1）；
   - 对象优先分配在 Eden；
   - Eden 满，触发一次 `Minor/Young 新生代 GC`，将存活对象移动到 `S0`，年龄默认为1；
   - S0 满，触发第二次`Minor/Young GC`，将存活对象移动到 `S1`，年龄+1；
2. 老年代：标记-清除或标记-整理算法
   - 长期存活的对象（`S1`中年龄增加到一定阈值如 15）或 `S1` 被填满，会被移动到老年代；
   - 大对象（需大量连续存储空间，最常见的是大数组）直接分配到老年代；
   - 老年代满触发`Full GC` ，清理新生代、老年代、方法区，仍无法存储对象则抛出OOM。
     - 一般 Full GC 等价于  `Major/Old 老年代 GC`，对老年代 GC。
3. 元空间（永久代）不在GC范围内。

##### 常见的垃圾回收器

1. Serial 串行收集器：单线程，工作时必须暂停其他所有的工作线程，直到它收集结束。新生代用复制算法，老年代用标记-整理算法。简单高效。
2. ParNew 收集器：Serial 收集器的多线程版本。
3. Parallel Scavenge 并行收集器：注重吞吐量（高效率的利用 CPU）。
4. CMS 垃圾收集器：并发，以获取最短回收停顿时间为目标；
   1. 初始标记：暂停其他线程，标记与GC roots直接关联的对象；
   2. 并发标记：可达性分析过程；
   3. 重新标记/并发预处理：查找执行并发标记阶段从年轻代晋升到老年代的对象，重新标记，暂停虚拟机，扫描CMS堆中剩余对象；
   4. 并发清除：清理垃圾对象；
   5. 并发重置：重置CMS收集器的数据结构。
5. G1 垃圾收集器：面向多CPU及大容量内存的服务器，相比于 CMS 的改进：
   - 把堆划分成多个大小相等的独立区域（Region），可单独进行垃圾回收；
   - 基于标记-整理算法，不产生内存碎片；
   - 精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
   - 步骤：
     1. 初始标记
     2. 并发标记
     3. 最终标记：对并发标记过程中，用户线程修改的对象再次标记一下。
     4. 筛选回收：对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间制定回收计划并回收。

##### 内存参数设置和内存调优

在 JVM 的启动参数中加入：

- `-Xms/-Xmx`：设置堆的最小/最大容量；
  - 在线上生产环境，二者设置相同的内存容量，避免在 GC 后调整堆大小带来的压力；
  - 等价于`-XX:InitialHeapSize/-XX:MaxHeapSize`；
- `-Xmn`：新生代大小；扣除新生代剩下的就是老年代大小；
  - 等价于`-XX:MaxNewSize`；
- `-Xss`：线程栈大小；
- `-XX:NewSize/MaxNewSize`：新生代最小/最大值；
- `-XX:MetaspaceSize/-XX:MaxMetaspaceSize`：指定元空间大小和最大值（超过最大值时，将进行死亡类及类加载器的垃圾回收），默认为21M和-1（即没有限制）。
  - JDK1.8 前用`-XX:PermSize/MaxPermSize`。
- `-XX:SurvivorRatio`：新生代 Eden 区 / Survivor 区，默认为 8，即 8**:**1**:**1。

命令行启动时按如下格式设置：

```
java -jar -Xms1G -Xmx1G -Xmn512M -Xss1M -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M app.jar
```

##### 查看 GC 日志

- [2、查看GC日志](https://www.cnblogs.com/chiangchou/p/jvm-2.html#_label3_1)

### JVM 调优

##### JVM 内存溢出

- 内存溢出（OutOfMemory）：申请不到；指程序在申请内存时，没有足够的内存空间供其使用。
- 内存泄露（Memory Leak）：释放不了；指程序在申请内存后，无法释放已申请的内存空间；最终将导致内存溢出。

内存溢出的原因：

1. 内存泄露导致堆、栈内存不断增大；
2. 加载过多 jar、class 文件；
3. 操作过多对象（如死循环 / 循环产生重复的对象实例）导致堆内存已满；
4. nio 直接操作内存，内存过大；
5. 参数设置内存过小。
6. OutOfMemoryError: GC Overhead Limit Exceeded:：GC上限超出，GC 时间长，但只回收了很少的堆内存；
7. OutOfMemoryError: Java heap space：堆内存不足以存放新创建的对象；

##### 故障定位

OOM 分析思路：

- 加入启动参数 dump 出堆转储快照：
  - `-XX:+HeapDumpOnOutOfMemoryError`：发生 OOM 时，dump 一份内存快照文件，输出出错时的堆内信息，用于排查问题。
  - `-XX:+HeapDumpPath=/usr/local/app/oom`

- 通过内存映射工具分析快照，重点是确认内存中的对象是否是必要的，即到底是出现了内存泄漏还是内存溢出。
  - 如果是内存泄漏，可进一步通过工具查看泄漏对象到 GC Roots 的应用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息，及 GC Roots 引用链的信息，就可较准确的定位出泄漏代码的位置；
  - 如果不存在内存泄漏，即内存中的对象确实都还必须存活着，应检查虚拟机的堆参数（-Xms 与 -Xms)，与机器物理内存对比看是否还可调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

##### 性能调优工具

目的：减少GC（STW）。

一、JDK 调优命令：

1. jps（JVM Process Status）：类似 UNIX 的 ps 命令。查看所有 Java 进程的启动类、传入参数和 JVM 参数等信息；
2. jstat（JVM Statistics Monitoring Tool）：用于收集 HotSpot 虚拟机各方面的运行数据；
3. jinfo（Configuration Info for Java）：显示虚拟机配置信息；
4. jmap（Memory Map for Java）：生成堆转储快照；
5. jhat（JVM Heap Dump Browser）：用于分析 heapdump 文件，建立一个 HTTP/HTML 服务器，让用户可在浏览器上查看分析结果；
6. jstack（Stack Trace for Java）：生成虚拟机当前时刻的线程快照（当前虚拟机内每一条线程正在执行的方法堆栈的集合）。

二、Linux 命令行：

1. top 命令
2. vmstat 命令
3. pidstat 命令

三、可视化工具：

1. Java VisualVM（jvisualvm）：提供运行监视和故障处理；
2. 阿里巴巴 [Arthas](https://github.com/macrozheng/mall-learning/blob/master/docs/reference/arthas_start.md) Java 诊断；

### Java 内存模型（JMM）与并发