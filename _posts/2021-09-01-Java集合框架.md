---
title: Java集合框架
categories:
  - Java
tags:
location:
abbrlink: '78r324yt'
permalink: '78r324yt'
date: 2021-09-01 13:42:12
updated: 2021-09-01 13:42:12
---

> 摘要：Java高级之集合框架/容器类，包括List、Set、Quene、Map。

<!-- more -->

## 集合框架（容器类）

所有集合类都位于 java.util 包下，用于表示和操作对象集合，包含大量集合接口及其实现类和操作算法。

集合类 VS 数组：
- 数组元素既可是基本类型的值，也可是对象的引用；
- 而集合只能保存对象的引用。对象本身存放在堆上或方法区里，但基本数据类型在栈上分配内存，随时被收回。但通过自动包装类可把基本类型转为对象类型，存放在集合中。


### Collection 接口及分类

重写toString()来打印内容，否则默认打印地址

一、List 接口

1. ArrayList 类：
2. LinkedList 类：
- void addFirst(E e) / addLast(E e)
- E getFirst() / E getLast()
- E removeFirst() / E removeLast()
- ~~Stack：是一个对象栈，先进后出~~

二、Set 接口

1. HashSet 类：实现了Set接口；基于HashMap实现但有键无值，元素值可以是 null；调用 add()方法（本质是调用HashMap的put()方法，且判断返回值为true？以确保不重复）向 Set 中添加元素；用成员对象计算 hashcode 值，若与已有 hashcode 相同，则用equals()方法判断两对象是否相等，若二者不等则加入成功；
- - LinkedHashSet类：有序不重复无索引，基于LinkHashMap有键无值，能按添加元素的顺序遍历

2. TreeSet 类：实现了 Set 和 SortedSet 接口；对8个包装类、Character、String从大到小排序；自动升序排序（顺序）不重复；基于红黑树(自平衡的排序二叉树)，能按添加元素的顺序遍历，可定制排序方式

三、Quene 接口：阻塞式队列（ArrayBlockingQuene）和非阻塞式队列(PriorityQuene，内存允许，可追加元素)。

- PriorityQueue: Object[] 数组来实现二叉堆；手撕算法典型题包括堆排序、求第K大的数、带权图的遍历等。
- ArrayQueue: Object[] 数组 + 双指针

四、Map 接口

1. HashMap 类：实现了Map接口；非线程安全；允许key和value为null，但作为键只能有一个，作为值可有多个；调用 put()向 map 中添加元素；用key计算 hashcode

底层是 数组和链表（链表散列/链表数组）。HashMap 通过 key 的 hashCode （经过扰动函数处理后）得到 hash 值。如果当前位置存在元素，判断该元素与要存入元素的 hash 值及 key 是否相同，如果相同直接覆盖，不相同（哈希冲突）通过拉链法（附到链表数组的对应链表中）解决冲突。

- LinkedHashMap：JDK1.8 后在解决哈希冲突时先进行数组扩容
- ConcurrentHashMap：线程安全，类似HashMap，唯一区别是其中的核心数据如 value及链表都是 volatile 修饰的，保证了获取时的可见性。采用分段锁技术，其中 Segment 继承于 ReentrantLock。不像 HashTable 那样put/get 都要做同步处理。

2. HashTable 类：**线程安全**，内部的方法基本都经过synchronized 修饰；数组+链表组成的，数组是 Hashtable 的主体，链表主要为了解决哈希冲突；**基本被淘汰不用**；不允许有 null 键和 null 值，否则会抛出 NullPointerException

3. TreeMap 类：红黑树（自平衡的排序二叉树），实现SortMap接口->根据Key**自动排序**；

ArrayList, LinkedList, HashSet，TreeSet，HashMap, TreeMap 都是线程不安全的。

List接口继承自Collection接口：

```
public interface List<E> extends Collection<E> {
}
```

List中没有而ArrayList中独有的方法不能被List对象使用，即多态。

用多态方式调用方法时：
先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。


### List VS Set VS Queue VS Map

1. List：有序可重复，允许多个null对象，可用iterator遍历或get(index)随机访问特定元素
2. Set：无序不可重复，最多只能有一个null对象，只可用iterator遍历
3. Queue：有序可重复，用于排队
4. Map：无序可重复，键值对


### List

##### ArrayList VS LinkedList

- 二者都不是线程安全的
1. 底层实现方式：ArrayList基于动态数组；LinkedList基于双向链表（JDK1.6 后，通过getLast()（获取最后一个元素）源码可见为双向）
2. 按位查找：ArrayList用get(index)随机访问快；LinkedList指定位置 index 查找为O(n)，顺序访问快
3. 插入和删除：ArrayList 效率受元素位置影响，对尾部增删O(1)，指定位置 i 增删为O(n) ；LinkedList先查再增删，增删效率不受元素位置影响，均O(1)
4. 扩容：ArrayList扩容机制为新建数组并拷贝原数组；LinkedList基于双向链表，不需要扩容
5. 内存空间：从单个元素说，LinkedList空间开销大

##### ArrayList 常用方法

```
List<String> lists = new ArrayList<>(); // 经典代码，ArrayList几乎实现了List的所有接口
lists.add("hello");
lists.remove(0);
lists.set(1, "world");
lists.get(2);

```

##### LinkedList 常用方法

```
// 队列
LinkedList<String> queue = new LinkedList<>();

queue.addLast("hello");
queue.removeFirst();

// 栈
LinkedList<Integer> stack = new LinkedList<>();

stack.push("hello");//top index=0
stack.addFirst("world");
stack.pop();
```

遍历用iterator不能用for循环


### hashCode() VS equals()

hashCode() 用于确定本对象在哈希表中的索引位置（如内存地址 => 整数），大大减少equals()的调用次数，从而提高效率。如HashSet、HashMap及HashTable等散列集合。
- 定义在 Object 类中，意味着任何类（包括数组）都实现了此方法。
- 是本地方法，即用 c/c++ 实现。

1. 两个对象相等（引用指向同一个对象） <=> A.equals(B)返回true => 两个对象 hashcode 相同 
2. 两个对象 hashcode 相同 => A.equals(B)不一定返回true => 对象不一定相等（哈希算法，散列，冲突）
3. 两个对象 hashcode 不同 => 对象不等

为什么重写 equals() 时必须重写 hashCode()?
目的在于，在A.equals(B)返回true的情况下，A, B 的hashCode()要返回相同的值；
如果没有重写，则两个对象无论如何都不会相等（即使它们指向相同的数据）。


### Set

Set如何去重/判断已有此对象：
1. hashCode()得到哈希值（相当于内存地址）
2. 若hashcode相等则用equals()比较内容重新确定是否存在该元素，若存在则加入失败

Set为何无序：
基于哈希表存储
数组 + 链表 + 红黑树 + 哈希算法

哈希算法：
- 链址法：CRUD性能都很好

TreeSet引用类型排序
1. 类重写比较器规则接口Comparable；重写compareTo()或compare()方法
2. 直接为集合设置比较器Comparable对象，重写比较方法，二者都有时用集合
```
Set sets = new HashSet<>(); // 经典代码

//1.
class Employee implements Comparatable<Employee>
{
  @Override
  publicint compareTo(Employee o) {
    if(this.age > o.age) {
      return 1;
    } else if(this.age < o.age) {
      return -1;
    } else {
      return 0;
    }
    //return this.age - o.age; // 差序算法
  }
}

TreeSet<String> sets = new TreeSet<>();

//2.
Set<Employee> e1 = new TreeSet<>(new Comparator<Employee>() {
  @Override
  public int compare(Employee o1, Employee o2) {
    return o1.getAge() - o2.getAge();
  }
});
```


### Map

##### HashMap VS HashTable

1. NULL：HashMap允许key和value为null，但 null 作为键只能有一个，null 作为值可有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException
2. 线程安全：HashMap 是非线程安全的；HashTable 是线程安全的

##### HashMap VS HashTree

##### HashMap VS HashSet

##### Map 常用API

```Java
Map<String, Integer> maps = new HashMap<>();

maps.put("Java", 12);
maps.put(null, null);

Integer v = maps.get("Java");

maps.remove("Java");

maps.clear();

maps.containsKey("Java");
maps.containsValue(10);

Set<String> keys = maps.keySet();
for(String key : keys) {
  System.out.println(key);
}

Collection<Integer> values = maps.values();

maps.putAll(maps2);

bool b = Double.compare(d1,d2);
```


### 遍历集合

```Java
Map<String, String> map = new HashMap<>();
map.put("Java", "hello");
map.put(null, null);

// 1. for-each循环，效率最高
// keySet集合迭代，打印键值对
for(String key : map.keySet()) {
    System.out.println(key + " : "+ maps.get(key));
}
// 打印值集合
for(String value : map.values()) {
    System.out.println(value);
}
// entrySet集合迭代
// 键值对整体作为Map.Entry<String, String>实体类型，Map转为Set集合
Set<Map.Entry<String, String> > entries = map.entrySet();
for(Map.Entry<String, String> entry : entries) {
  String key = entry.getKey();
  String value = entry.getValue();
}


// 2. 迭代器
// 定义：提供一种方法访问容器对象各个元素，而又不需暴露该对象的内部细节。实质是实现了用于遍历容器的hasNext()和next()方法
// map不同于set和list，不是继承自Collection接口，没有实现Collection的Iterator 方法，自身没有迭代器来遍历元素。
Collection objs = new HashSet<String>();
// 获取集合对应的迭代器
Iterator<String> it = objs.iterator();
while(it.hasNext()) {
    // it.next()方法返回的数据类型是Object，因此需强制类型转换
    String obj = (String) it.next();
    System.out.println(obj);
    if (obj.equals("C语言")) {
        // 从集合中删除上一次next()返回的元素
        it.remove();
    }
    // 对book变量赋值，不会改变集合元素本身
    obj = "C语言";
}
System.out.println(objs);
        
// 3.lambda表达式 JDK1.8后
objs.forEach(s -> {
  System.out.println(s);
});

maps.forEach((K, V) -> {
  System.out.println(k + "=>" + v);
});

// 4. For-Each : JDK1.5+，Java 5 后推出，专门为集合遍历设计
int[] numbers = { 43, 32, 53, 54, 75, 7, 10 };
// for-each语句
for (int item : numbers) {
    System.out.println("Count is:" + item);
}
```

- continue 语句只能用在 while 语句、for 语句或者 foreach 语句的循环体中


### Collections工具类

都是静态方法

```
//常用方法:
List<String> names = new ArrayList<>();

Collections.addAll(names, "Tom")
Collections.shuffle(names);// 对List乱序
Collections.sort(names); //对 List排序

//排序：
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面

//查找,替换
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须有序
int max(Collection coll)//返回最大元素。 int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定元素代替指定list中的所有元素
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素
```



### 可变参数
数据类型...参数列表
在方法内部本质是一个数组
只允许一个可变参数，放在最后
```
sum(1, 2, 4);
sum(new int[] {1, 2, 4});
```


### fail-fast VS fail-safe

