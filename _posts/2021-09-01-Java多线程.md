---
title: Java多线程
categories:
  - Java
tags:
location:
abbrlink: '8d0t5y39'
permalink: '8d0t5y39'
date: 2021-09-01 13:42:12
updated: 2021-09-01 13:42:12
---

> 摘要：Java高级之多线程，包括线程的生命周期、创建方式、调度、同步，线程安全，volatile 和 synchronized关键字，线程池，JUC工具类，AQS等。

<!-- more -->

## 多线程

### 书

《深入理解Java虚拟机》
《Java 并发编程的艺术》

### 基本概念

##### 多线程 

优点：
1. 减少CPU的空闲时间，提高CPU利用率
 - 对多核CPU：充分利用多核CPU的计算能力；
 - 对单核CPU：防止阻塞；
2. 方便进行业务拆分和建模。

缺点：
- 线程越多占用内存也越大->内存泄漏
- 竞争共享资源->线程安全、死锁
- 频繁的上下文切换

##### 多内核 多线程 多进程 优缺点

##### 上下文切换

上下文切换：指**CPU控制权**（由一个正在运行的线程）切换到另一个（就绪并等待获取CPU执行权的）线程的过程。

原因：
- 时间片用完，因为OS要防止一个线程长时间占用CPU导致其他线程饿死。
- 主动让出 CPU，如调用了 sleep()、wait() 等。
- 调用了阻塞类型的系统中断，如请求IO、线程被阻塞。
- 被终止或结束运行

减少上下文切换可采用：
- 无锁并发编程：
- 用Atomic类CAS算法更新数据，乐观锁可有效减少不必要的锁竞争带来的上下文切换
- 使用最少线程：避免创建不需要的线程，（如任务很少，但创建了很多的线程，会造成大量线程处于等待状态）
- 协程：在单线程里实现多任务的调度，并维持多个任务间的切换

##### 守护线程

定义：为所有用户线程提供服务的线程。如：GC垃圾回收线程，低优先级

```
thread.setDaemon(true);
thread.start();
```

### 生命周期

1. new：新建线程对象（仅由JVM为其分配内存，并初始化成员变量的值）

2. runnable 可运行：
- ready 就绪：调用start()启动后进入ready（可运行线程池中），（JVM为其创建方法调用栈/VM栈和程序计数器），等待被线程调度选中、等待CPU使用权；
- running 运行：ready（唯一入口）获得CPU资源后进入，除非此线程主动放弃 CPU 资源（时间片用完进入ready/阻塞？）或有优先级更高的线程进入，将一直运行、直到结束；

时间片：指将可用的 CPU 时间分配给 Runnable 线程的过程，可基于优先级或等待时间。

3. blocked 阻塞：线程因某种原因让出 CPU，暂时停止运行，等待获取锁；解除阻塞后重新进入ready。

4. waiting 等待：线程内run()运行语句Object.wait()、Thread.join()后进入该状态。当前线程需等待其它线程notify通知或中断。

5. `time_waiting` 超时/限期等待：在一定时间后结束等待。调用Object.wait(long)、Thread.join(long)、Thread.sleep(long)进入。

6. terminted 终止：线程执行完或因异常退出run()方法。

### 创建线程的方式

1. 继承Thread类，重写run()，调用start()启动线程。
- 缺点：单继承

2. 实现Runnable接口，实现run()，将子类对象（作为参数）传给Thread类的构造器 `new Thread(Runnable obj)`来创建线程对象，调用start()启动线程。
- 可继承其他类，多实现
- void，无返回值
- run()只能抛出运行时异常，且无法捕获处理
- 可用匿名内部类简化

3. 实现Callable接口，实现call()，将子类对象（作为参数）传给Thread类的构造器来创建线程对象，调用start()开启线程。
- 有泛型返回值，和Future、FutureTask配合可用来获取异步执行的结果：创建FutureTask(Callable cal)对象，传给Thread的构造器；然后提交给ExecutorsService执行，放入线程池中
- call()允许抛出异常，可获取异常信息

4. 用Executors提供的一系列工厂方法创建线程池（都实现了ExecutorService 接口）：用时直接获取，用完放回。

##### start() VS run()

start()：用于（启动线程）创建新线程，并执行在run()里的代码，使线程进入ready状态；只能调用一次；

run()：用于执行线程的运行时代码；可重复调用；只是 Thread 的一个普通方法，仍在主线程内执行；不会创建新线程也不会调用线程的代码。

==> 多线程执行时要用start()而不是直接调用run()。

线程类的构造方法、静态块是被new此线程所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。

##### 终止线程运行/正在运行的线程

1. run()/call()执行完，线程正常结束；
2. 用interrupt()中断线程，抛出interruptedException；
3. 直接调用stop()强行终止；stop/suspend/resume都是过期作废的方法，容易导致死锁，故不推荐。


### 线程调度/通信/阻塞

##### 线程调度

- 抢占式调度模型：指优先让（可运行池中）优先级高的线程占用CPU，处于运行状态的线程会一直运行，直至不得不放弃 CPU。
- 分时调度模型：

##### 线程通信的方式

1. volatile 修饰变量：保证所有线程对变量访问的可见性。主要通过读-写共享变量来完成隐式通信。
2. synchronized：确保多个线程在同一时刻只能有一个处于方法或同步块中。
3. wait()/notify()方法。
4. IO通信。

##### 导致线程阻塞 VS 唤醒/解除阻塞

唤醒：让线程重新进入就绪状态

- 等待阻塞（wait）：当前线程需等待其它线程notify通知或中断。(如某项资源就绪/另一个线程放弃排他锁)。
 - 执行wait()进入此状态：JVM会把该线程放入**等待池**，释放占用的所有资源（包括持有的锁)；
 - 不会去竞争同步锁，不能自动唤醒（需被其他线程显式唤醒），收到其他线程发出的通知（如调用notify()/notifyAll()）后才会去竞争锁。

- 超时等待（`time_waiting`）：不分配CPU，超时自动唤醒。

- 同步阻塞：获取 synchronized 同步锁时，锁被其它线程占用（获取失败)，会放入**锁池**；
 - 释放同步锁后、锁池中的线程会去竞争同步锁，某个线程竞争成功后会解除阻塞，进入ready。
 - （等待另一个线程的synchronized 块释放, 或可重入的 synchronized 块里别人调用wait() , 即线程在等待进入临界区）

结束阻塞/恢复线程的时机：
1. 调用sleep()让出占用的CPU资源；sleep()超时
2. 调用yield()让出占用的CPU资源（给优先级相同或更高的线程）进入ready？
3. 调用join()；join()等待线程终止或超时
4. 发出I/O请求；I/O处理完毕
5. 调用suspend()挂起线程（被挂起后不会释放锁，可能与其他线程、主线程产生死锁，已废弃）；resume()恢复线程。

其它唤醒/解除阻塞：
- 因调用wait()、sleep()、join()导致的，可中断线程并抛出InterruptedException；
- 如果线程遇到了IO阻塞，无法唤醒。

##### 常用方法

1. wait()：使一个线程处于等待阻塞状态，并释放所持有的（对象的）锁，用于线程交互；
2. sleep()：使线程从running进入blocked；一直持有锁，用于暂停执行；静态方法，要处理InterruptedException 异常；
3. join()：进入blocked，直到调用者执行完本身才能执行；
4. yield()：使当前线程从 running（不能被其他状态调用）直接变为 ready，让出CPU时间片；静态方法。
5. notify()：唤醒一个wait状态的线程，由 JVM 决定唤醒哪个线程，与优先级无关；
6. notityAll()：唤醒所有wait状态的线程，并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；

static Thread Thread.currentThread(): 返回当前线程。在Thread子类中就是this，常用于主线程和Runnable实现类

boolean isAlive()：判断线程是否还活着

##### wait() VS sleep() 

- 两者都可暂停线程执行

1. 类：wait() 是 Object类的普通本地方法；sleep() 是 Thread类的静态本地方法。
2. 释放锁（最大不同）：等待时wait() 会释放锁，加入等待池；sleep() 一直持有锁，即使有synchronized同步块，其他线程仍不能访问共享数据
3. 依赖：wait()依赖同步器synchronized，而sleep()不依赖
4. 唤醒：wait() 需其它线程调用notify()/notifyAll() 唤醒，或`time_waiting`超时；sleep() 执行完自动唤醒。
5. 用途：wait() 常用于线程间交互/通信；sleep() 常用于当前线程休眠或轮询暂停操作。
6. sleep()会让出 CPU执行时间且强制上下文切换，wait()则不一定，可能还有机会重新竞争到锁继续执行。

线程调用对象的 wait()/notify()/notifyAll()时，都必须先获得对象的锁
==>所以只能在同步方法/同步块中被调用。

同步块比同步方法更好：
同步块外的代码是异步执行的，比同步整个方法效率更高。
原则：同步的范围越小越好。

##### sleep() VS yield()

1. 优先级：sleep()不考虑线程的优先级，会给低优先级的线程运行的机会；yield()只会给相同或更高优先级的线程机会；
2. 作用：执行 sleep()后转入blocked，而执行 yield()后转入ready；
3. 异常：sleep()声明抛出 InterruptedException，而 yield()没有声明任何异常；
4. sleep() 比 yield()（跟OS CPU 调度相关）更可移植，不建议用yield()来控制并发线程。


### 线程同步

##### 同步 VS 异步

同步：必须等被调用的方法结束后，后面的代码才能执行。

异步：不管被调用方法是否完成，都会继续执行后面的代码，调用完成后会通知调用者。

##### 线程间的同步方式

线程同步：两个或多个共享关键资源的线程并发执行。用于避免关键资源使用冲突。

- 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。如 synchronized 关键词和各种 Lock（互斥锁、读写锁、记录锁、自旋锁）。
- 信号量(Semphares) ：允许同一时刻多个线程访问同一资源，但需控制最大线程数量。
- 事件(Event) :Wait/Notify：通过通知的方式来保持多线程同步，方便比较多线程优先级。
- 条件变量
- 屏障（barrier）

##### synchronized

用来控制线程同步：可保证在任意时刻只有一个线程执行方法/代码段

- 作用范围是synchronized后大括号{}中的代码
- 作用对象是调用{}的对象；

1. 修饰实例方法（同步方法）：
作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。

2. 修饰静态方法:
因其是类成员，相当于给当前类加锁，作用于类的所有对象实例，访问静态 synchronized 方法、进入同步代码前要获得当前类的锁，而访问非静态 synchronized 方法占用的是当前实例对象锁，二者不互斥。

3. 修饰代码块（同步语句块）：
synchronized(this|object) 表示进入同步代码库前要获得给定对象的锁。

4. 不能修饰构造器：其本身就是线程安全的，不存在同步的构造方法一说。

##### JMM（Java内存模型）

Java内存模型：
- 线程间的**共享变量**存储在主内存（物理内存，虚拟机内存的一部分），每个线程都有自己的工作内存（即所用变量的主内存副本，CPU缓存）。
- 对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。
- 操作完成后，通过缓存一致性协议将数据刷回主存。

线程间主要通过读-写共享变量来完成隐式通信。

##### volatile

volatile修饰共享变量：保证每个线程都能获取主存中的最新值，避免出现数据脏读。

1. 保证变量对所有线程的可见性：一个线程修改了变量值，立即更新到主存，对其他线程立即可见。其他线程直接从主存读取新值，而不是工作内存中的副本；
2. 禁止指令重排，保证有序性；
3. 不能单独保证原子性，结合 CAS 可保证。

为了提高性能，处理器和编译器常会对指令重排序：
- 不影响单线程环境的执行结果，但会破坏多线程的执行语义；
- 存在数据依赖关系的不允许重排序。

##### volatile VS synchronized

1. 修饰：volatile 只能用于变量而 synchronized 可修饰类、方法、变量及代码块；
2. 作用：volatile 用于解决变量在多个线程间的可见性（线程通信）； synchronized 用于解决多个线程间访问资源的同步性（线程同步）。
3. 性质：volatile 能保证数据的可见性（和有序性），但不能保证原子性；synchronized 两者都能保证。
4. 性能：volatile 是线程同步的轻量级实现，性能比 synchronized 好；
5. 阻塞：volatile 不会造成线程阻塞；synchronized 可能造成 。
6. 优化：volatile 变量不会被编译器优化；synchronized变量可被优化。

##### 同步容器 VS 并发容器

##### ThreadLocal

ThreadLocal（线程共享变量）：为每个线程维护一个本地Map，key为ThreadLocal对象，value为对应线程的变量副本（Entry 对象）==>用于查找；以空间换时间

用途：
1. 对象跨层传递时可避免多次传递，打破层次约束；
2. （主要）用于线程间的数据隔离，解决线程安全问题；填充的数据只属于当前线程；
3. 进行事务操作，用于存储线程事物信息；
4. 数据库连接，Session会话管理。

内存泄漏：
由于 ThreadLocal 是弱引用，Entry 的 value 是强引用，因此当 ThreadLocal 被回收后，value 依旧不会被释放，产生内存泄漏。

避免：
- 用完ThreadLocal后调用remove()手动清空；必须回收自定义的 ThreadLocal 变量记录的当前线程的值，尤其在线程池场景下，线程经常会被复用。尽量用 try-finally 块进行回收。
- 用private static ThreadLocal修饰变量，任何时候都能访问value，进而清除掉。是针对一个线程内所有操作共享的，故设置为static，所有此类实例共享此静态变量。即，类第一次被使用时装载，只分配一块存储空间，所有（本线程内定义的）此类的对象都可操控这个变量。
```
objectThreadLocal.set(userInfo);
try {
    // ...
} finally {
    objectThreadLocal.remove();
}
```

##### happens-before 先行发生原则：定义了操作A必然先行发生于B的一些规则。

- 符合规则，不需额外做同步措施；
- 不符合规则，一定是非线程安全的。

##### happens-before八大原则

- 程序次序规则：一个线程内写在前面的操作先行发生于后面的。

- 锁定规则：unlock 操作先行发生于后面对同一个锁的 lock 操作。

- volatile 规则：对 volatile 变量的写操作先行发生于后面的读操作。

- 线程启动规则：线程的 start()先行发生于线程的每个动作。

- 线程中断规则：对线程interrupt()的调用先行发生于被中断线程的代码检测到中断事件的发生。

- 线程终止规则：线程中所有操作先行发生于对线程的终止检测。

- 对象终结规则：对象的初始化先行发生于 finalize() 方法。

- 传递性规则：如果操作 A 先行发生于B，B 先行发生于C，则 A 先行发生于 C

##### as-if-serial VS happens-before规则

as-if-serial：编译器等会对原始程序进行指令重排序和优化，但和原结果一致。

1. 语义：保证单线程和正确同步的多线程 程序的执行结果不变。
2. 对程序员：分别按程序的顺序和happens-before指定的顺序执行。
3. 目的：都是为（在不改变程序执行结果的前提下，）尽可能提高执行的并行度。


### 线程安全

定义：多线程下（重复）运行的结果与单线程的结果始终一致，且其他变量的值也和预期的值始终一致。

堆是所有线程共享，栈是线程安全的。

##### 线程安全级别

1. 不可变（Immutable）：
 - 对象一旦被创建，任何一个线程都改变不了它的状态（数据/属性值），除非新创建一个；
 - （所有域都是 final 类型，且被正确创建（创建期间没有 this 引用的溢出））
==>（保证了对象的内存可见性，）不需任何同步手段就可直接在多线程下使用

如 String、包装类、BigInteger 和 BigDecimal 等。

2. 绝对线程安全：不管运行时环境如何，调用者都不需额外的同步措施。如
- CopyOnWriteArrayList
- CopyOnWriteArraySet

3. 相对线程安全，即通常所说的线程安全：如Vector的add()、remove()都是原子操作，但如果多个线程同时执行遍历和add() ，会出现ConcurrentModificationException（即fail-fast机制）

4. 线程非安全：ArrayList、LinkedList、HashMap等

##### 线程安全策略/保证线程安全的方法 及 三要素

保证三要素、即保证线程安全

1. 原子性（Atomicity）：一个（或多个操作）是不可中断的，要么全都执行，要么全都不执行。
 - Lock（手动）锁：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁间的代码；
 - synchronized 同步方法/代码块：对线程加独占锁，修饰的类/方法/变量/代码片段同一时间只允许一个线程访问；
 - 用安全类，如Atomic原子类（CAS）、Unsafe类；如i++是非线程安全的，可用`AtomicInteger.incrementAndGet()`替换

2. 可见性（Visibility）：一个线程修改共享变量后，其他线程能立即得知最新值。
- volatile：保证新值能立即同步到主内存，且每次使用前都从主内存重新读取；
- synchronized：在释放锁前将工作内存新值更新到主存中；
- Lock

3. 有序性（Ordering）：对于改变顺序不影响语义的代码，JVM和CPU编译时可能会优化代码和指令重排；保证线程内串行语义？虽然多线程存在并发和指令优化等操作，但在本线程内观察所有执行操作是有序的。
- volatile：有禁止指令重排序的语义
- synchronized：变量在同一个时刻只允许一条线程对其进行lock操作，使有同一个锁的两同步块只能串行地进入；
- Happens-Before 规则：两个操作的执行顺序只要可通过happens-before推导出来，则JVM会保证其顺序性，否则可任意重排序以提高效率。


### 悲观锁 VS 乐观锁

悲观锁：每次获取数据时，都担心数据被修改，因此加独占锁，确保自己使用的过程中数据不会被别人修改，使用完成后解锁；期间对该数据读写的其他线程都会等待/阻塞；synchronized 的实现，传统的关系型数据库如行锁，表锁等，读锁，写锁等。遵循一锁二判三更新四释放的原则。

使用场景：写多读少，并发量不大
- 乐观锁在获得锁的同时已完成了更新，校验逻辑易出现漏洞，另外，对冲突的解决策略有较复杂的要求，处理不当易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。

缺点：导致频繁的上下文切换和调度延时，降低性能；一个线程持有锁会导致其他所有需要此锁的线程挂起。

乐观锁：对于并发间操作产生的线程安全问题持乐观状态，认为竞争不总是会发生，不需持有锁；每次获取数据时，都不担心数据被修改，因此读操作前不加锁，写操作时才判断数据在此期间是否被其他线程修改。如果发生修改，则返回写入失败；如果没有被修改，则执行修改操作，返回修改成功。

期间该数据可被其他线程读写；
使用场景：读多写少
一般用CAS算法实现。

在项目开发中的实践：
SVN、Git等版本控制管理器，提交时对比版本号，如果远程仓库的版本号和本地的不一样表示有人已提交过代码，需要先更新到本地处理一下版本冲突问题。

##### CAS，Compare and Swap，比较-交换

原理：基于乐观锁，当且仅当预期原值 A 和内存位置 V 的值相同时，才将 V 修改为新值 B 并返回true，否则处理器什么都不做。解决多线程并行情况下使用锁造成性能损耗的一种机制，这是硬件实现的原子操作。

产生的问题：

1. **ABA 问题**：
线程1准备将内存值由A改为C
- 线程1从内存位置 V读取了数据A；
- 由于没有锁，线程2将内存位置 V 的值由A改为B，又由B改回A；
- 线程1通过CAS比较，发现数据仍是A没变，很容易认为在此期间没有线程修改过数据，就写成了C，返回成功；
- 如果C的值在ABA的线程中发生改变，则不能实现预期结果。

JUC包中AtomicStampedReference类（加入版本号，对比内存值+版本号）解决 ABA 问题。

2. 循环时间长开销大：并发量较高，资源竞争严重时，许多线程反复尝试更新某一个变量，CAS操作却又一直不成功（自旋），相当于死循环，浪费CPU 资源。

3. 只能保证一个共享变量的原子操作：对多个共享变量无法保证。
 - 此时可用synchronized锁；可用AtomicReference来保证对象间的原子性，把多个对象放入CAS中。


### 线程池

池化技术：为了减少每次获取资源的消耗，提高利用率。如数据库连接池、Http 连接池等

##### 好处

1. 降低资源消耗。重复利用已创建的线程，减少线程创建/销毁、及系统资源的开销。
2. 提高响应速度。当任务到达时，不需等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，无限制的创建会消耗**系统资源**、降低系统的稳定性（OOM），可统一分配、调优和监控。

##### 实现原理

提交一个新任务到线程池时：

1. 若核心线程池未满/中的线程不全在执行->创建新线程执行任务；
2. 若核心线程池已满，任务队列未满->放入任务队列等待执行；
3. 若任务队列已满，线程数 < 线程池最大线程数（线程池未满）->创建临时线程处理任务；
4. 线程数 > 最大线程数->根据拒绝策略处理任务。

##### 创建线程池

方式一：通过构造器ThreadPoolExecutor()创建（Alibaba推荐，规避资源耗尽的风险）。
```
ExecutorService service = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>());

service.execute(new Runnable() {
	public void run() {
	    System.out.println("execute方式");
	}
});

Future<Integer> future = service.submit(new Callable<Integer>() {

	@Override
	public Integer call() throws Exception {
		System.out.println("submit方式");
		return 2;
	}
});
try {
	Integer number = future.get();
} catch (ExecutionException e) {
	e.printStackTrace();
}

```
参数有：
1. corePoolSize：核心线程数，线程池中活跃的线程数；
2. maxinumPoolSize：允许同时运行的最大线程数；
3. keepAliveTime：空闲线程（超出核心线程数外的）的最大存活时间；
4. unit：空闲时间的单位；
5. workQueue：任务队列，存放等待执行的任务；
6. threadFactory：用于executor创建新线程；
7. Handler：任务拒绝策略。

ExecutorService：真正的线程池接口，用于创建并返回不同类型的线程池。
- execute(Runnable obj) ：没有返回值；
- submit(Callable obj)：返回future对象，用于判断任务是否执行成功。

方式二：通过 Executor 框架的工具类/线程池的静态工厂类 Executors 来实现。目的是将任务提交和运行分离，用户不需从代码层考虑设计任务的提交运行。不推荐。

1. newSingleThreadExecutor() ：创建一个只有一个线程的线程池；
2. newFixedThreadPool(n); 创建一个（可重用）固定线程数的线程池；不推荐。
3. newCachedThreadPool()：创建一个可按需创建新线程的线程池；
4. newScheduledThreadPool(corePoolSize)：创建一个可定时执行的线程池，指定核心线程数；

5. newWorkStealingPool()：创建一个有多个任务队列的线程池。

- 1、2、4：允许的请求队列长度为 `Integer.MAX_VALUE`，可能会堆积大量的请求，从而导致 OOM。
- 3：允许的创建线程数量为 `Integer.MAX_VALUE`，可能会创建大量的线程，从而导致 OOM。

参考：https://github.com/yangchong211/YCBlogs/blob/master/java/Java并发/20.线程池基础介绍.md


### JUC并发工具类

Unsafe 类：使 Java 拥有指针一样操作内存空间的能力，是 Java 并发开发的基础。

##### Atomic原子类

原子类：有原子操作特征的类。一个操作是不可中断的。在多线程一起执行时，一个操作一旦开始，就不会被其他线程干扰。

##### 4类

1. 基本类型 AtomicInteger
2. 数组类型 AtomicIntegerArray
3. 引用类型 AtomicReference
4. 对象的属性修改类型 AtomicIntegerFieldUpdater

##### Atomic类基本实现原理

原理：用 CAS  + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，提升执行效率。

以AtomicIntger 为例：方法getAndIncrement：以原子方式将当前的值加1


### JUC 核心类 AQS

AbstractQueuedSynchronizer 抽象队列同步器：是一个抽象类，用来构建锁和同步器。

##### AQS原理

AQS用一个 volatile int state 变量作为共享资源，（volatile能保证多线程下的可见性，state=1代表当前对象锁已被占有，）多线程争用资源被阻塞时（线程获取资源失败）会进入FIFO线程等待（同步）队列挂起；获取成功就执行临界区代码，释放资源时会通知/唤醒同步队列中的等待线程。

AQS：利用先进先出队列实现的底层同步工具类，是很多上层同步实现类的基础，如: [常用的 AQS 组件/同步器](#常用的 AQS 组件/同步器)，它们通过继承 AQS 实现其模版方法，然后将 AQS 子类作为同步组件的内部类，通常命名为 Sync。

另外state的操作都是通过CAS来保证其并发修改的安全性。

用途：能简单高效地构造出应用广泛的大量的同步器

##### AQS的两种功能/资源共享方式

1. Exclusive（独占锁）：每次只能有一个线程能持有锁，如ReentrantLock提供了两种锁获取方式：
- 公平锁：按发出请求的顺序（排队顺序）获得锁，先到先得
- 非公平锁：发出请求后立即尝试获取锁，若可用则直接获取锁（谁抢到就是谁的），尝试失败才排队等待

2. Share（共享锁）：多个线程可同时获取锁，并发访问共享资源，如Semaphore、CountDownLatch、ReadWriteLock，读-写锁，只允许一个资源可被多个读/写操作访问，但读-写不能同时进行。

##### 常用的 AQS 组件/同步器

- Semaphore（信号量）：限制某段代码块的并发数，指定多个线程同时访问某个资源。synchronized/ReentrantLock（相当于构造器参数最大并发数/计数器n=1）都是一次只允许一个线程访问某个资源。

- CountDownLatch（倒计时器）：同步工具类，让当前线程等待其它线程都执行完毕再开始执行。通过计数器实现，初始值是线程数量，每执行完一个线程-1。只能一次性使用。

- CyclicBarrier(循环栅栏)：和 CountDownLatch 类似，但可重复使用（reset）。


- **可重入锁（ReentrantLock）**：能对共享/临界资源重复加锁，即当前线程再次获取该锁不会阻塞。基于AQS，唯一实现了Lock接口的类。

- ReentrantReadWriteLock 读写锁可看作组合式？


### 生产者消费者模型

作用：
1. 通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率；
2. 解耦；

##### 实现

- wait和notify
- ReentrantLock
- BlockQueue
- Semaphore
- PipedInputStream

### IO多路复用