---
title: Spring框架
categories:
  - 应用框架
tags:
location:
abbrlink: '81y02uhg'
permalink: '81y02uhg'
date: 2021-09-01 13:42:12
updated: 2021-09-01 13:42:12
---

> 摘要：Spring框架，包括IoC和DI，Bean，AOP，事务等。

<!-- more -->

## Spring 框架

### Spring 概述

Spring是轻量级的开源J2EE（容器）框架和中间层框架（万能胶）。

优点：
- 非侵入式：对象可不依赖于Spring的API；（不改变现有的类结构，就能增强JavaBean的功能，Struts2等传统框架常要实现特定接口、继承特定类才能增强功能，改变了java类的结构）
- 松耦合：IoC
- AOP
- 容器：管理对象的生命周期和配置
- 对单元测试支持比较好：框架中包含测试环境；支持 JUnit4，可通过注解方便地测试。
- WEB框架：MVC
- 方便集成各种优秀框架：支持 Struts2、Hibernate、MyBatis等
- 为JavaEE 开发中一些 API（JDBC、JavaMail、远程调用等）提供了封装
- 事务管理：提供一个持续的事务管理接口，可扩展到上至本地事务下至全局事务（JTA）
- 声明式事务的支持：只通过配置就可完成事务管理，无须手动编程。

##### Spring Framework 八大模块

1. Data Access/Integration 数据访问/集成
- JDBC
- ORM：提供与流行的"对象-关系"映射框架无缝集成的 API，包括 JPA、JDO、Hibernate 和 MyBatis 等。
- JMS
- TX事务
2. Web
- Web-MVC
3. Core Container 核心容器：
- Beans 模块：包括IoC和DI
- Core 模块
- Context 模块
- SpEL（Spring Express Language）

4. AOP
5. ~~Aspects：与 AspectJ 的集成提供支持~~
6. ~~Instrumentation~~
7. ~~Messaging~~ 
8. ~~Test~~


### IoC 设计思想

1. 控制反转（Inversion of Control）：new/创建对象的控制权，由开发者手动创建转移（反转）给第三方IoC容器管理。

2. 依赖注入（Dependency Injection）：通过IoC容器管理对象间的依赖，容器在创建实例时，自动注入对象需要的外部资源。

二者含义相同，是从两个角度描述的同一个概念。

##### IoC 容器的两种实现

IoC 容器：管理对象的实例化（，初始化），（从创建到销毁的）整个生命周期。

IoC 容器的两种实现：

1. BeanFactory容器：Spring内部用；懒加载（获取对象时才创建对象）；简单，占内存少，启动快。用于初始化 Bean，并调用方法。

实现 BeanFactory 接口最常用的是 XmlBeanFactory 类

```
Resource res = new ClassPathResource("appContext.xml"); 
BeanFactory fact = new XmlBeanFactory(res);  
Student stu = (Student) fac.getBean("student");
```

2. ApplicationContext 容器：面向开发者；不管用没用到，容器启动时一次性创建所有 bean ；即时加载（加载配置文件时创建对象）；继承并扩展 BeanFactory，功能更完整；

- ClassPathXmlApplicationContext：从 class path 加载配置文件，更常用；
- FileSystemXmlApplicationContext：从参数指定位置加载配置文件，不常用。
- XmlWebApplicationContext：从Web系统中的XML文件加载配置文件。

二者都是通过 XML 配置文件加载 Bean 的，通常用后者，只有在系统资源较少时，才考虑用 BeanFactory。

主要区别在于 Bean 的某一属性没有注入时，
- BeanFacotry 加载后，第一次调用 getBean() 会抛出异常，
- ApplicationContext 会在初始化时自检所依赖的属性是否注入。

##### 属性注入的方式

Spring Framework 中仅有前两种：

1. 构造器注入：XML配置文件中，用 <constructor-arg> 标签给构造方法的参数赋值，包含：
- value 用于注入基本数据类型及字符串类型的值；
- ref 用于注入已定义好的 Bean；
- type 用来指定对应的构造函数；
- index 指定参数位置。

2. setter()注入：通过调用默认无参构造器或无参static工厂方法，实例化bean对象，并调用setXxx()设置其属性。

配置文件中，用 <property> 为每个属性注入值。

3. 注解自动注入，大部分
- @Configuration：配置类？
- @Autowired：基于类型自动注入，默认是byType，可通过@Qualifile改为byName
- @Resource：默认（指定值）是byName，找不到（与名称匹配的bean）（or不指定值）时用byType，相同的类型在IOC容器中不能有两个
- @Qualifier("userDAO")：限定要自动注入的bean的id，一般和@Autowired联用，指定bean的名称
- @ComponentScan：扫描器？
- @Value：注入简单类型数据 （jdk8种基本数据类型+String类型）

4. 接口注入/工厂方法

5. ~~p名称空间注入~~：setter()的优化

6. 泛型注入

##### 构造器注入和 setter() 注入

构造函数注入	setter 注入
- 没有部分注入；有部分注入
- 不会覆盖 setter 属性；会覆盖 setter 属性
- 任意修改都会创建一个新实例	；任意修改不会创建一个新实例
- 适用于设置很多属性；适用于设置少量属性


### Spring Bean

Bean：由 IoC 容器管理的对象。根据配置元数据创建。

##### 工厂模式

工厂方法：分为无参和有参，静态工厂和实例工厂。

用静态工厂方法创建Bean

IoC底层原理：

```
//工厂模式
class UserFactory {
    public static UserDao getDao() {
    //xml解析
    String className = class属性值;
    //通过反射创建对象
    Class clazz = Class.forName(className);
    return (UserDao)clazz.newInstance();
    
    //return new UserDao();
    }
}

UserDao dao = UserFactory.getDao();
```

##### 配置文件

描述如何创建对象和哪些组件需要哪些服务。用于定义 Bean 的属性值和作用域，Bean 间的依赖关系

格式：
1. Properties 配置文件：key-value 形式，只能赋值，不能进行其他操作，用于简单的属性配置。
2. XML 配置文件：树形结构，结构清晰灵活，内容繁琐，用于大型复杂的项目。

##### 配置（元数据）方式/实现Bean

1）基于xml配置Bean：
- bean 标签：要创建的对象；
- id: 对象的唯一标识，不可重复；
- class: bean 的完全限定名，即从 package name 到 class name；
- property：给属性赋值，name 的名称取决于 set() 后的参数；
- 用 constructor 赋值，name 的名称取决于参数列表；
- 指定 abstarct="true"而不指定 class 属性，定义为 Bean 定义模板，只能被继承，不能被实例化。
- 通过 parent 属性指定继承的父 Bean。

```
//创建对象：默认执行无参构造器
<bean id="user" class="com.spring5.User" name="">
    <--!1. 用set方法注入属性-->
    //注入基本数据类型（8大基本数据类+String）
    <property name="bname" value="java"></property>

    //注入null和特殊符号属性
    <property name = "email"><null/></property>

    <property name="auther" name=""></property>
    <property name="address">
        <value><!CDATA[<<南京>>]></value>
    
    //注入聚合对象
    //注入外部bean属性
    <property name="userDao" ref=userDaoImpl"></property>
    <property>
    
    //注入内部bean同内部类
    //员工属于一个部门
    <property name="dept">
        <bean id="dept" class="...">
            <propert name="dname" value="security"></property>
        </bean>
    </property>
    
    //级联赋值
    <property name="dept" ref="dept"></property>
    
    //注入集合，创建类，定义数组、List、Set、Map属性，生成set方法
    <property name="courses">
        //注入数组类型属性
        <array>
            <value>java</value>
        </array>
        //注入List集合属性
        //注入Map属性
        //在集合里设置对象类型的值
    </property>
    
    <--!2. 用有参构造注入属性-->
    <constructor-arg name="oname" index=0  value="China"></constructor-arg>
    
</bean>

<bean id="userDaoImpl" class="com.at.spring5.dao.UserDaoImpl"></bean>

    public Orders(String oname) {
        this.oname = oname;
    }
    
psvm ctrl+.
```

2）基于注解的配置，在Java类中用注解设置依赖关系

Spring 配置文件（xml或properties）中启用注解装配，如：

```
<beans>
<context:annotation-config/>
<!-- bean definitions go here -->
</beans>
```

3）基于 Java API 配置Bean，（把Java代码当作配置文件，）会用到注解：Java配置类？
- @Configuration 表明是 JavaConfig配置类，用于（通过简单调用同类中的其他 @Bean 方法来）配置/定义Bean间的依赖关系。
- @ComponentScan 用特定注解标注的类统一扫描加载到Spring容器
- @Bean 替代 <bean /> 元素；将该方法返回的Bean对象加载到Spring容器，可用@Bean的name属性自定义，默认为方法名。
- @Import 允许从另一个Java/XML配置文件加载bean定义。

要实现注入只需将要注入的Bean的类型作为参数，调用该类的带参构造器构建Bean，
或：先创建这个类的对象，然后调用该对象的set方法进行注入，以被注入的Bean的方法为参数

Spring Boot中彻底抛弃了xml配置，后期推荐用此方式

4） ~~基于Groovy DSL配置（很少见）~~

##### 将类声明为 bean 的注解

一般用 @Autowired 注解自动装配 bean，要想把类标识成可用于自动装配的 bean 类,采用以下注解可实现：

- @Component：泛指组件，用于任意层次，同@Name，较少用
- @Repository：用于Dao（数据访问/持久？）层
- @Service： 用于Service业务（逻辑）层，同@Component；
- @Controller：用于控制层，接受用户请求并调用 Service 层返回数据给前端页面。同@Component；

##### @Component VS @Bean

- 作用对象: @Component 注解作用于类，而@Bean作用于方法。
- @Component常通过类路径扫描来自动侦测及自动装配到Bean容器；@Bean 常在方法中定义产生这个 bean,告诉Spring这是某个类的示例，当用它时还给我。
- @Bean 的自定义性更强，很多地方只能通过 @Bean 来注册bean。如引用第三方库中的类需装配到 Spring容器时

##### Bean 作用域

Spring 5：

1. singleton：默认值，单例模式，容器中只有一个共享的Bean实例，由BeanFactory维护。存储在高速缓存中，只要 id 与该 Bean 定义相匹配，都会返回该缓存对象。适用于无会话状态的 Bean（如 DAO 层、Service 层）。

2. prototype：每次获取 Bean 时，容器都会创建一个新的 Bean 实例。适用于需保持会话状态的 Bean（如 Struts2 的 Action 类）。

3. request：每次 HTTP 请求都会创建一个新的 bean，仅在当前 request 内有效（在请求完成后，bean会失效并被GC回收）。
4. session：同一个 HTTP Session 共享一个 Bean 实例。
5. application：类似于 singleton，同一个 Web 应用（可能有多个 IoC 容器）共享一个 Bean 实例。
6. websocket：作用域是 WebSocket。

后4个只能在 Web 环境下（XmlWebApplicationContext）使用，如果用 ClassPathXmlApplicationContext 加载这些作用域中的任意一个的 Bean，会抛出异常。

```
配置 bean 的作用域

1. xml 方式：
<bean id="" class="" scope="singleton"></bean>

2. 注解方式：
@Bean
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Person personPrototype() {
    return new Person();
}
```

##### Bean生命周期


##### 同名Bean的优先级

- 同一个配置文件内，以最上面定义的为准
- 不同配置文件中的，后解析的配置文件会覆盖先解析的
- 同文件中@Bean（最先注册）的优先级>@ComponentScan


### Beans 自动装配

Bean装配/依赖注入：在 IoC 容器中，Bean 与 Bean 间建立依赖关系。装配方式即依赖注入方式。

手动装配 bean：XML 配置中通过 <constructor-arg>和 <property> 中的 ref 属性，手动维护 Bean 与 Bean 间的依赖关系。

自动装配 bean：Spring 容器依据规则，为指定的 Bean 从应用的上下文（AppplicationContext 容器）中查找所依赖的 Bean，并自动建立 Bean 间的依赖关系。

#### 五种规则

- no：默认设置，表示不用自动装配，Bean 依赖必须通过 ref 元素引用定义。
- byName：根据 Property 的 name 自动装配/注入对象依赖项，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。
- byType：根据 Property 的数据类型（Type）自动装配，如果一个 Bean 的数据类型兼容另一个 Bean 中 Property 的数据类型，则自动装配。
- constructor：类似于 byType，根据构造方法参数的数据类型，进行 byType 模式的自动装配。
- autodetect：如果 Bean 中有默认的构造方法，则用 constructor 模式，否则用 byType 模式。

##### IoC容器自动装配Bean的方式

1. XML：applicationContext.xml配置文件
- 根据名字来装配
- 根据类型类装配

配置 <bean> 元素的 autowire 属性，值有：

局限：
- 用 <constructor-arg> 和 <property> 设置指定依赖项，将覆盖自动装配。
- 基本元数据类型（简单属性，如原数据类型，字符串和类）无法自动装配。
- 不精确

##### 如何解决循环依赖

1. 构造器的：直接抛出BeanCurrentlylnCreationException异常。 
2. 单例模式下的setter（默认的单例Bean中，属性互相引用）：通过三级缓存处理。 
3. 非单例：无法处理。


### 基于注解的配置

##### @Controller VS @ResposeBody VS @RestController

- @Controller：返回一个视图/页面，用于传统的Spring MVC 前后端不分离的情况。扫描该类下有 @RequestMapping 的方法，根据注解信息生成一个对应的处理器对象

- @ResponseBody：将 Controller 返回的对象转换为指定格式，并写入HTTP 响应对象的 body，常用来返回 JSON（较多）或 XML 数据。

还需配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类才能返回 JSON 格式，如Spring MVC 默认用 MappingJackson2HttpMessageConverter。

- @RestController：只返回对象（对象数据直接以 JSON 或 XML 格式（由客户端的 ACCEPT 请求头决定）写入 HTTP 响应中），属于 RESTful Web/API服务，最常用的前后端分离框架的情况。

开发 RESTful Web服务，Spring 4 后新加：
@Controller + @ResponseBody= @RestController。

##### RequestMapping VS @GetMapping

@RequestMapping：配置处理器的 HTTP 请求方法，URI等信息，将请求和方法进行映射

- @RequestMapping：可注解在类（一般是配置这个控制器的 URI 前缀）和方法上；@GetMapping 仅可注册在方法上
- @RequestMapping：可进行 GET、POST、PUT、DELETE 等请求方法；@GetMapping 是 @RequestMapping 的 GET 请求方法的特例，用于提高清晰度。

##### @RequestParam 和 @PathVariable 两个注解的区别

都用于方法参数，
获取参数值的方式不同，@RequestParam 的参数从请求携带的参数中获取，而 @PathVariable 注解从请求的 URI 中获取


### AOP

AOP（面向切面编程）：将与业务无关却为业务模块所共同调用的逻辑（交叉业务逻辑，如事务处理、日志管理、权限控制等）封装成切面。

便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

##### 代理模式：Spring AOP

Spring AOP VS AspectJ AOP

1. Spring AOP 基于动态代理/运行时增强，不需专门的编译过程和类加载器：
- JDK 动态代理：被代理的类至少实现一个接口
- CGLIB 动态代理/子类代理：目标类没有实现接口

2. AspectJ 基于静态代理/编译时增强：
- 性能更好，功能更全，需特定的编译器处理

##### AspectJ AOP

1. 基于XML的声明式 AspectJ/开发AOP：
指通过 Spring 配置文件定义切面、切入点及通知，都必须定义在 <aop:config> 元素（将定义好的 Bean 转换为切面 Bean）中。

2. 基于注解的声明式 AspectJ：
启用 @AspectJ 注解有以下两种方法：
1）使用@Configuration和@EnableAspectJAutoProxy注解：

```
@Configuration 
@EnableAspectJAutoProxy
public class Appconfig {
}
```

2）基于XML配置：
在 XML 文件中添加以下内容启用 @AspectJ。
<aop:aspectj-autoproxy>


##### 代理工厂（静态方法）

- 把AOP加入IOC容器中
- 把UserDao放入容器中
- 在配置文件中开启注解扫描，用工厂静态方法来创建代理类对象


### Spring 框架中用到的设计模式

1. 工厂模式：通过 BeanFactory、ApplicationContext 创建Bean对象；

2. 单例模式：Bean默认为单例模式，只有一个实例；Spring 中 bean 的默认作用域就是 singleton(单例)的。Spring 实现单例的方式：
- xml : <bean id="userService" class="top.snailclimb.UserService" scope="singleton"/>
- 注解：@Scope(value = "singleton")

3. 代理模式：AOP用到JDK的动态代理和CGLIB字节码生成技术；

4. 模板方法：用来解决代码重复的问题。如 RestTemplate, JmsTemplate, JpaTemplate、jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类。

5. 观察者模式：定义对象间的依赖关系，一个对象发生改变时，所有依赖它的对象都会被动更新，如事件驱动模型（如每次添加商品时都需重新更新索引，ApplicationListener（listener的实现））。

6. 适配器/包装器(Wrapper)模式 : 可根据客户的需求动态切换不同的数据源，使接口不兼容的类一起工作。Spring AOP 的增强或通知(Advice)、spring MVC 适配Controller。

7. 装饰者模式: 



### JDBC/JdbcTemplate

位于 spring-jdbc-x.x.x.jar 包中，还需导入 spring-tx-x.x.x.jar 包用来处理事务和异常。

### JPA？

```
//用 JPA 在数据库中非持久化一个字段

@Entity(name="USER")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "ID")
    private Long id;

    @Column(name="USER_NAME")
    private String userName;

    private String secrect;

}
```

### Spring 事务管理

事务管理：按照给定的事务规则来执行提交或回滚操作。

1. 编程式事务：编写代码实现管理事务，难维护；
2. 声明式事务：分离事务管理和业务逻辑代码，实际是通过 AOP 实现；不需编程，只需通过在 XML 文件中配置或直接基于注解实现；实现声明式事务的方式：？
- 基于XML（<tx> 和<aop>命名空间）的声明式事务管理：推荐，最大特点是与 Spring AOP 结合紧密，可充分利用切点表达式的强大支持，更加灵活。
- 基于 @Transactional 的全注解方式：简化，使用最多

##### 事务传播行为/规则

- PROPAGATION_REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。最常见
- PROPAGATION_SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。
- PROPAGATION_MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。
- PROPAGATION_REQUIRES_NEW: 新建事务，如果当前存在事务，把当前事务挂起。
- PROPAGATION_NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- PROPAGATION_NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。
- PROPAGATION_NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与 PROPAGATION_REQUIRED类似的操作。




## Spring MVC

是一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet，本身是 Spring 框架的一部分。


### MVC 设计模式

Model 1 时代：
1. 数据模型层（Model）：应用程序的主体部分，负责数据逻辑（业务规则）的处理和实现数据操作（即在数据库中存取数据）。
2. 视图层（View）：负责格式化数据并呈现给用户；包括数据展示、用户交互、数据验证、界面设计等功能。
3. 控制层（Controller）：负责接收并转发请求，对请求进行处理后，指定视图并将响应结果发送给客户端。

Model 2 时代，早期 JavaWeb MVC 开发模式：
1. JavaBean + JSP；
2. JavaBean + JSP + Servlet
- Java Bean(Model，即 dao 和 bean）
- JSP（View）
- Servlet（Controller，可在JSP中实现）

Spring MVC 时代：
- 业务逻辑层（Service/Controller）：可以管理事务和记录日志等；业务逻辑相关的部分无法单独处理，但 service+serviceImpl、dao+daoImpl 又太冗余，于是将其单独列为业务逻辑层
- 持久层（Dao数据库操作/Entity实体类/Model）：可以整合 MyBatis、Hibernate 和 JdbcTemplate 等技术。
- 表现层（View）：提供了与 Spring MVC、Struts2 框架的整合


### Spring MVC VS Structs2

1. Spring MVC 基于方法开发，会将 URL 信息与 Controller 类的某个方法绑定并进行映射，请求参数作为该方法的形参，生成 Handler 对象，只包含一个 method 方法。
Struts2 基于类开发，Action 类中所有方法的请求参数都是成员变量，方法越多，类越乱。

2. Spring MVC 支持单例开发模式，而 Struts2 由于只能通过类的成员变量接受参数，无法用单例模式。


### Spring MVC 工作原理详解/流程说明

1. 客户端（浏览器）发送请求到 DispatcherServlet。
2. DispatcherServlet 根据请求信息调用 HandlerMapping。
3. 解析请求到对应的 Handler（即 Controller）。
4. HandlerAdapter 适配器根据 Handler调用真正的处理器处理请求，并处理相应的业务逻辑。
5. 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是逻辑上的 View。

6. ViewResolver 会根据逻辑 View 查找实际的 View。
7. DispaterServlet 把返回的 Model 传给 View（视图渲染）。
8. 把 View 返回给请求者（浏览器）
