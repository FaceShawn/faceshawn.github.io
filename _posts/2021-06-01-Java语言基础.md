---
title: Java语言基础
categories:
  - 编程语言
tags:
location:
abbrlink: '8urh23fh'
permalink: '8urh23fh'
date: 2021-06-01 13:42:12
updated: 2021-06-01 13:42:12
---

> 摘要：Java语法，包括final、static关键字，数据类型，面向对象的封装、继承和多态，常用类等。

<!-- more -->

[Java基础知识点和答案](https://github.com/gzc426/Java-Interview/blob/master/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%92%8C%E7%AD%94%E6%A1%88.md)

## Java VS C++

1. 纯面向对象的语言，封装、继承、多态->低耦合的系统，易维护、复用、扩展；C++ 兼容 C，效率高但有面向过程。
2. JVM：跨平台/平台无关，一次编译到处运行（很好的可移植性），字节码运行机制，既有编译又有**解释**；C++为编译型语言，C++11 数组，Windows VS Linux。
3. JVM：自动内存管理，内存更安全；C++ 要手动释放内存，指针易导致野指针（指向垃圾内存的指针：没有初始化；free或delete后没有置为NULL、被误以为是合法指针、而继续使用）、内存泄漏。
4. 多线程：支持多线程；C++ 没有内置的多线程机制，必须调用 OS 的多线程功能。
5. 继承：Java类单继承，接口多继承；C++ 类支持多重继承；
6. 重载：Java 只支持方法重载；C++ 同时支持方法重载和操作符重载
7. 支持网络通信编程且很方便，支持Web应用开发

## JDK、JRE、JVM 对比

- JDK（Java Development Kit），是一种功能齐全的 Java SDK，用于程序开发者创建、编译程序。
   - Java 开发组件：javac 编译器、jar 打包工具、javadoc 文档生成器、java-debuger（jdb）调试工具、javap -c 反汇编；
   - **JRE**（JAVA Runtime Environment）：包含普通用户运行 Java 程序所需的全部内容。
       - JVM（JAVA Virtual Machine）：是一个用于执行**JAVA字节码**的虚拟机进程，实现**一次编译，到处运行**；
         - HopSpot、JRockit、J9Vm
       - 用于产品环境的 Java 类库。

## 常量和变量

### （非 static）成员变量 VS 局部变量

[静态变量/类变量](#二、修饰成员变量（=>静态变量/类变量）)

1. 定义（本质）：static 成员变量属于类，用类名调用，由类的所有对象共享，持久驻内存，下次调用保留原值；非 static 成员变量属于对象，用对象名调用；局部变量是在代码块/方法中定义的变量/方法的参数。
2. 修饰符：成员变量都可以；局部变量不能被**访问控制修饰符**及 static 修饰，只能被 final 修饰。
3. 存储位置：static 成员变量属于类，存于方法区，（非 static ）成员变量属于对象，存于堆内存；局部变量存于VM栈中的局部变量表。
4. 默认值：成员变量有默认值，在JVM类加载时自动初始化（如未赋初值则取默认值）（例外：被 final 修饰的必须显式地赋值）；而局部变量（除形参外）必须显式地初始化，在字节码执行时才会运行方法中的（局部变量）代码。
5. 生命周期：成员变量与类/对象一致；局部变量与方法一致。

```
public class DataClass {
    int age; // 成员变量/全局成员变量/实例变量
    static String URL = "hello"; // 静态成员变量
    static final String website = "C"; // 静态常量
}
```

### final 关键字

final 核心思想：最终的、不可修改的；表示变量值不可变、方法不可覆盖、类不可继承。

##### 一、修饰类：不可被继承（没有子类）

- 所有成员方法被隐式指定为final，（但成员变量不变）；

- abstract和final互斥、冲突，二者不能同时存在；

- 所有包装类都是用final修饰；

  - String是final类，不可变；

##### 二、修饰方法：final方法不可**重写**，可重载

作用：

- =>用于防止子类覆盖父类方法的实现，安全；如：POJO 类的 setter 方法，不允许被覆写。
- =>方法被转为内嵌，提高执行效率。

> （类中所有）private 方法都被隐式指定为 private [final] ；
> final也可修饰private，但无意义。

##### 三、修饰变量：实质上是常量

从变量类型分类：
1. 修饰基本类型或 String 类型的变量：使用前必须有且仅有一次初始化，初始化后值不可变，第二次赋值将抛出编译时错误（`Compiler Error: cannot assign a value to final variable`）。
   
   - 若编译阶段已知其确切值，则会当做**编译期常量**（直接宏替换），存入调用类的常量池中。
   
2. 修饰引用类型变量：初始化后**引用**不可变（即不能指向另一个对象），但**引用指向的对象的内容**可变。即 final 数组 / 集合可添加、删除元素。

   **String VS final String**

   - [==比较引用的地址](#运算符 == VS equals)
   - String 为变量；final String为编译期常量

   ```
   // 字面量“hello2”存入字符串常量池中，a为变量，指向常量池的地址
   String a = "hello2";
   
   // b为编译期常量，指向常量池的地址
   final String b = "hello";
   // c为变量
   String c = "hello"; 
   
   // true，b是常量，在编译期间就计算出了b+2=”hello2”，在常量池中找到已有地址，与a相同
   a == b + 2;
   // false，c是变量，在编译期间不能确定其值，在堆中新建对象”hello”，+运算得到新变量 “hello2”，二者地址不同
   a == c + 2;
   ```

从变量位置分类：
1. 修饰静态成员变量（修饰类变量、常量=const）：只可在静态初始化块中/声明时赋初值；
2. 修饰（实例）成员变量：只可在非静态初始化块中/声明时/**每个构造器中**赋初始值；
3. 修饰局部变量：使用前赋值，不允许二次赋值。

```Java
// 静态常量，作用域是全局，不用创建对象，用类名直接访问
HelloWorld.PI;

public class HelloWorld {
    // 修饰静态常量
    public static final double PI = 3.14;
    // 修饰成员常量
    final int Y = 10;
    public static void main(String[] args) {
        // 修饰局部常量
        final double X = 3.3;
    }
}
```

- 在foreach语句中可用final声明存储循环元素的变量

- 局部内部类和匿名内部类只能访问局部 finial 常量：因为外部类运行后局部变量会被回收，内部类延长局部变量copy的生命周期、用finial保证二者一致。JDK1.8后默认加 finial。


### static关键字

static 修饰的成员属于类，可被类的所有对象共享，加 static 不影响作用域。只保存一份拷贝，建议用类名调用。

##### 一、修饰成员方法（=>静态方法、类方法）：

不依赖任何对象，在类加载时（在方法区）分配内存，可通过类名直接访问；非 static 成员（变量或方法）在对象实例化前不存在，不能被 static 方法调用

- ==>只能访问类的静态成员；

- ==>方法中不能以任何方式引用this和super；但反之在非静态方法中可通过this访问静态成员；

方便在没有创建对象的情况下调用方法/变量，如：
1. Collections类中的一些方法，如Objects.equals()，[Arrays 工具类](#Array 类和 Arrays 工具类)的静态方法；
2. util工具类中的方法。如[Math 工具类](#Math 类)的静态方法；
3. 单例模式的 `getInstance()`、工厂模式的`create/build()`、`Logger LOGGER = LoggerFacbory.getLogger(Users.class)` 等。

构造器不是静态方法：
- 定义：不是方法，只负责初始化；
- this：构造器中可使用this（指向当前对象），而静态方法不依赖任何对象；
- 调用：只能通过new（或别的构造器）调用，不能通过方法调用。

##### 二、修饰成员变量（=>静态变量/类变量）

>  实质上就是全局变量；

目的：作为共享变量使用；减少对象的创建；保留唯一副本。

- 内存分配：由类的所有对象共享，持久驻内存，下次调用保留原值；
- 存储位置：static 成员变量属于类，存于方法区，（非 static ）成员变量属于对象，存于堆内存；局部变量属于方法，存于VM栈中的局部变量表。
- 调用方式：（推荐）用类名调用；
- 生命周期：从类被加载开始，到类被 GC 彻底回收时；

##### 三、静态代码块

执行顺序：静态代码块-->非静态代码块-->构造器。 

定义在类中方法外，用于初始化静态变量（给静态变量/类变量赋值）：不管创建多少对象，静态代码块都只执行一次；对于定义在它之后的静态变量，可赋值，但不能访问。如单例模式、定义枚举类。

非静态代码块与构造函数的区别是：非静态代码块是对所有对象进行统一初始化，而构造函数是给对应的对象初始化。

##### 四、静态内部类

> static只能修饰内部类。

非静态内部类在编译完成后会隐含地保存一个引用，指向创建它的外部类，但静态内部类没有。意味着：

- 创建不依赖外部类的创建；
- 不能使用任何外部类的非 static 成员变量/方法。

如：`AB-BA` 死锁问题。

##### 五、静态导入包

> 1.5 后的新特性， 格式为：import static，可导入某个类中的指定静态资源，且不需用类名调用类中静态成员，可直接用类中静态成员变量/方法。

### final VS static 变量

```
class MyClass {
	// 所有实例共享
    public final double i = Math.random(); 
    public static double j = Math.random();
}

MyClass cls1 = new MyClass();
MyClass cls2 = new MyClass();

cls1.i == cls2.i; // false，两个i值不同
cls1.j == cls2.j; // true，两个j值相同
```


## 数据类型

### 四大类八小类基本数据类型

> primitive type

1. 布尔型 boolean 1Byte false：不能转换成任何数据类型，true != 1，占用大小根据实现JVM不同有所差异；
2. 字符型 char 2 'u0000'：
3. 整型
   1. byte 1 0
   2. short 2 0：32767
   3. int 4 0：2^31-1=2,147,483,647)
   4. long 8 0L：
4. 浮点型
   1. float 4 0F：
   2. double 8 0D：

```
long price = 12.2L
float price = 12.2F; 
double price = 12.254(D);
```

### 包装类

> wrapper class，箱子

包装类都是final修饰，无法继承。

##### 基本数据类型 VS 包装类

区别：

- 根本：数据类型；面向对象的类。
- 存储位置：基本数据类型直接存放在VM栈的局部变量表中，占用空间小；而包装类对象存在堆中。  
- 默认值：基本数据类型有默认值（int = 0）且不是 null；包装类型若不赋值则为 null。

##### 包装类放入常量池的取值

- Boolean：TRUE/FALSE 两个常量，用于表示布尔值 true 和 false 
- **Character**：[0,127]
- Byte Short **Integer** Long：[-128,127]
- Float、Double：不会进入常量池
- String 类型：所有字面量都会进入常量池

包装类在常量池的值会**复用**已有对象的缓存数据，可直接用`==`判断；其它范围的值，必须全部用 equals()比较；

- 如，对于 `Integer var = ?` 在 -128 至 127 间的赋值，Integer 对象是在 **`IntegerCache.cache`** 产生，会复用已有对象，此区间外的所有数据都在**堆**上产生，不复用已有对象。

##### 自动装箱/拆箱机制


从 JAVA SE5 开始引入自动装箱/拆箱机制->将基本数据类型当成对象操作，使二者可相互转换：

自动拆箱的时机：

1. 将包装类型变量直接赋值给对应基本数据类型时；
2. 当要访问对象的真实数据值时，如要输出对象的值；
3. 当要对包装类的实际值进行数学运算时，如比较大小。

```Java
Integer i1 = new Integer(128); // 手动装箱，基本数据类型 => 堆内存中的包装类对象
Integer i2 = 128; // 自动装箱，调用了 **Integer.valueOf(66)**，i2指向常量池中的对象；Double、Float的valueOf()类似。
i1 == i2? // false，比较引用，常量池外的值不复用，不同对象的地址不同；若为[-128, 127]，则复用已有对象，地址相同，返回true
i1.equals(i2)? // true，不同对象的值相等

int d3 = i2.intValue(); // 手动拆箱，包装类对象 => 基本数据类型
int d3 = i2; // 自动拆箱，调用了 i2.intValue()/xxxValue()
```

##### 与字符串间的转换

继承自 `Object` 类的方法：

```
Integer i3 = Integer.valueOf(str); // 字符串 => 包装类对象
String str = i1.toString(); // 包装类对象 => 字符串

int i3 = Integer.valueOf(str); // （推荐，经典代码）字符串 => 包装类对象 => （自动拆箱）基本数据类型
int i4 = Integer.parserInt(str); // 字符串 => 基本数据类型
```

### 数据类型转换

自动类型转换：

a.                char -> int -> long -> float -> double
b. byte -> short -> int -> long -> float -> double


- ==下转型==（down-casting，也称为窄化）会造成精度损失
- 将float变量赋值给int变量需用强制类型转换 

- instanceof 关键字：若对象为类（或接口、抽象类、父类）的实例，则返回true

三目运算符 `condition ? 表达式 1 : 表达式 2 `中，注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常。如表达式 1 或 表达式 2 的值：

1. 任一个是基本数据类型；

2. 类型不一致，会强制拆箱升级成表示范围更大的那个类型。 

  反例：
```
Integer a = 1;
Integer b = 2;
Integer c = null;
Boolean flag = false;
// a*b的结果是int类型，那么c会强制拆箱成int类型，抛出NPE异常 
Integer result = (flag ? a * b : c);
```

### 运算符 == VS equals

`==` 比较的是引用，即：

1. 用于基本数据类型，直接比较其（vm栈中）存储的值是否相等；
2. 用于引用类型，比较两个引用是否指向同一块内存（堆内存中的对象地址）/同一个对象；
- 除非是同一个new出来的对象才为true，或在字符串常量池中指向同一个内存地址，否则为false。因为每new一次，都会重新开辟堆内存空间。
- null == null //返回true，null既不是对象也不是一种类型，仅是一种特殊的值
3. 表达式（包含算术运算）== 包装类（触发自动拆箱==>基本数据类型）：比较的是数值

不能用 `==` 比较的有：

- 基本类型的变量、值 == 引用类型的变量、值；不能触发自动拆箱
- boolean 类型的变量、值 == 其他任意类型的变量、值；
- 包装类之间；
- 没有继承关系的两个引用类型；
- 浮点数 == 浮点数：浮点数采用"尾数+阶码"的编码方式，二进制无法精确表示大部分的十进制小数。计算机内存放的值与实际值存在误差，导致浮点数精度陷阱。[计算机系统基础（四）浮点数](http://kaito-kidd.com/2018/08/08/computer-system-float-point/)

```
float a = 1.0F - 0.9F;// 0.100000024，在计算机内4Byte，32bit，1符号位8指数位23有效数字，用"尾数+阶码"的编码方式，二进制无法精确表示大部分的十进制小数
float b = 0.9F - 0.8F;// 0.099999964
a == b？// 预期返回true，实际为false

// 1. 指定一个误差范围，两个浮点数的差值在此范围内，则认为是相等的。
float diff = 1e-6F;
if (Math.abs(a - b) < diff) {
    System.out.println("true"); 
}

// 2. 用 BigDecimal 来定义值，再进行浮点数的运算操作。
BigDecimal a = new BigDecimal("1.0"); 
// BigDecimal(double) 存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。
// 或使用 BigDecimal 的 valueOf 方法，内部其实执行了 Double 的 toString，按 double 的实际能表达的精度对尾数进行了截断。
BigDecimal b = new BigDecimal("0.9");
BigDecimal c = new BigDecimal("0.8");

BigDecimal x = a.subtract(b); // 0.1 
BigDecimal y = b.subtract(c); // 0.1
x.compareTo(y)? //true
//而不是 Objects.equals(x, y)?// equals() 会比较值和精度(1.0 与 1.00 返回结果为 false)，而 compareTo() 则会忽略精度。
```

`equals()` 用来比较两个对象（内存中）的内容是否相同，即对象是否相等。

1. 不能用来比较基本数据类型（及其包装类？）的变量；
2. 对于引用类型：
   - 若没重写 equals() `<==>` equals() 继承自Object类，故每个对象都有 equals()，Object中默认（直接调用 ==）对比两个对象的地址是否相等；
   - 多数情况下，重写 equals() `==>` 比较对象存储的内容是否相等。如String类、包装类、Date类等；
    - 重写 equals() 必须重写 hashCode，保证equals()相同的对象 hashCode 也相同。否则违背了两个相等的对象必须有相等的 hashCode 这一Java关键约定，进而影响散列表、hashmap等。
      - 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两种方法。
      - String 因为覆写了 hashCode 和 equals 方法，所以可以愉快地将 String 对象作为 key 来使用。
- equals() 和 hashCode 同时存在的意义：
 - equals：比较的是地址，保证比较对象是否是绝对相等的
 - hashCode：保证在最快的时间内判断两个对象是否相等，可能有误差值
 - 一个是保证可靠，一个是保证性能
 - 同一对象的hashCode一定相等，不同对象的hashCode也可能相等

```
String s1 = "ab"; // 将字面量"ab"放到常量池中，并将引用 s1 指向对象；推荐
String s2 = "ab"; // 在常量池查找到"ab"的地址，并赋给s2
s1 == s2? // true，s1和s2地址相同
s1.equal(s2)? // true，比较字符串的内容

String str1 = new String("ab"); // 在堆内存创建一个新对象，a 引用指向新对象
String str2 = new String("ab"); // 在堆内存创建另一个新对象，b 引用指向新对象
str1 == str2? // false，非同一对象
str1.equals(str2)? // true，对象的内容一样

s1 != str1 // s1是常量池中的对象的引用，str1是堆内存中的对象的引用，二者地址不同
s1.equal(str1) // true，内容相同，重写hashCode()

String str3 = str2; // 引用传递，指向堆内存中的同一对象
str3 == str2? // true
str3 == s1? // false
str3.equal(s1) // true

Objects.equals(null,"hello");// 避免空指针异常

42 == 42.0? // true
```

### 三类引用数据类型

> reference type

作为方法的参数类型和返回类型

1. 数组
2. 类
3. 接口

#### 数组

##### 用法

1. 声明；只得到一个存放数组的变量，并没有为数组元素分配内存空间；
2. 用 new 关键字分配内存空间；
3. 初始化；
4. 使用。

```
int[] arr = new int[5]; // 声明 + 动态初始化，程序员指定数组的长度，由系统初始化每个元素的默认值，此处 int 默认值为0
int[] num = new int[]{1, 2, 3, 5, 8};  // 一般不用
int[] num = {1,2,3,5,8}; // 声明 + 静态初始化，程序员显式指定每个元素的初始值，由系统决定数组的长度
nums.length; // 数组，故用属性

List<Integer> list = new ArrayList<>();
list.size(); // 泛型集合，vector、List等，固有方法

str.length(); // String 对象，故有方法
```

当指定的下标值超出数组的总长度时，会拋出 ArrayIndexOutOfBoundsException（数组越界异常）。

因为 Java 类与类间支持继承，可能产生一个数组里可存放多种数据类型的假象。如一个水果数组，元素可是苹果或香蕉（都继承了水果），但元素类型还是水果。

##### 数组、List接口、ArrayList类

- 数组：大小固定，查找快
- List：是接口
- ArrayList：是List的实现类，有序，以一定的顺序保存元素。

##### Array 类和 Arrays 工具类

Array 类：提供静态方法，动态创建和访问数组。

```
int[] data = new int[10]; // 没有进行初始化 默认值为0
Array.set(data, 7, 6); // 设置data[7]=6
```

Arrays 类：提供静态方法，对数组进行操作。定义在`java.util`包中，主要实现数组元素的查找，内容填充、排序等。

```
// 以下静态方法均被重载多次，可用于各种类型的数组，如float[]等
public static List asList(int[] a) 将数组转为集合
List list = Arrays.asList(a);

public static boolean equals(int[] a, int[] a2) 判断两个数组是否相等
public static void fill(int[] a,int val) 将指定内容填充到数组中
public static int[] copyOf(int[] a, int n) 拷贝，不改变参数内容，也可用于扩容
public static void sort(int[] a) 排序
public static int binarySearch(int[] a, [int fromIndex, int toIndex,] int key) 对排序后的数组[fromIndex, toIndex]范围内进行二分检索。返回搜索值的索引；否则返回 -1
public static String toString(int[] a) 输出数组信息
```

## 类和面向对象

### 类

- 按需加载类，且只加载一次：[JVM]()
- static成员变量初始化
- 执行static语句块
 - static成员变量和static语句块的执行顺序同代码中的顺序一致
- 初始化对象的成员变量，类变量在任何方法（包括构造器）调用前初始化
- 执行构造器
- 生成对象

### 对象

> Object Oriented

根据JVM规范："对象是动态分配的类实例或数组"。实例是内存中的对象。

抽象：指将一类对象的共同特征提取出来构造类，**类是对象（实例）的抽象**。一切皆对象。

```
Student stu1 = new Student("小刘", 22); // 显式创建对象

String str1 = "Hello"; // 隐式创建对象
String str2 = str1 + "Java";

new Person("张三", 30).tell(); // 匿名对象，对象只用一次，在实际开发中大多作参数，区别于单例模式
```

### this、super 关键字

this代表当前（类的）对象的引用，指向本对象；super 代表对父类对象的引用，指向父类对象。

1. 在构造器中，this用于区分同名成员变量与局部变量；this 调用本类中的其他构造方法/super() 调用父类中的其他构造方法时，必须处于构造器的首行，否则编译器会报错。
2. 在 static 方法中，this、super不可用。

### 封装

定义：把数据和操作方法绑定，用于控制对外隐藏和暴露哪些数据。封装的基本单位是类。POJO 的getter/setter 方法；ORM 框架。

### 继承

继承：指子类可使用父类的所有属性和方法。子类 is a 父类

继承的特点：
- 单继承（不支持多重继承）：程序结构更清晰便于维护。多重继承会使类型转换、构造方法的调用顺序变复杂，影响性能。
- 若支持多重继承：类C继承自类A和类B，如果类A和B都有自定义的成员方法f()，则调用类C.f()会产生二义性；
- 通过实现多个接口间接支持多重继承：接口由于只包含方法定义，不能有方法的实现，类C不能直接调用方法，需实现具体的f()才能调用，不会产生二义性。
- 对于父类的包访问权限、成员变量/方法，如果子类和父类在同一个包下，则子类能继承；否则，子类不能继承；
- 子类**拥有**父类所有的属性和方法（包括私有属性和私有方法），但无法访问父类中的私有属性和方法，仅拥有。
  - 继承后变量和方法的访问顺序：就近原则；
- 子类不能继承父类的构造器。
- 子类可重写父类的方法；

super主要用法：

1. `super.成员变量/方法;` // 用于在子类中调用父类的同名成员变量或方法；
2. `super(param1, ...)`
　- // 用于在子类构造器（的第一行显式地）调用父类构造器；
    - 若父类有无参构造器，系统会自动调用`super()`；
    - 若父类的构造器都带参，则必须用`super(param1, ...)`显式调用一次。

### 方法重载 VS 重写

- 重载（overload）：同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理；
- 重写/覆盖、覆写（override）：子类**继承**父类已有的方法，并重新实现其内部逻辑、功能。

0. 方法名都相同。
1. 发生范围：重载在同一个类；重写在子类中。
2. 参数列表（类型、个数、顺序） ：重载至少一个不同；重写一定相同。
3. 返回值类型、异常：重载可不同（只有返回值不同不算重载）；重写子类的返回值类型、异常范围（`RunTimeException`）<=父类（`Exception`）。
4. 访问修饰符：重载可不同；对重写，子类访问权限（`public，而非private`）>=父类（`protected`），即子类修饰符不能做更严格的限制->父类方法修饰符为 `private/final/static`或构造器（都不能被继承）则子类不能重写，但被 static 修饰的方法能被再次声明。
5. 发生阶段：重载实现的是**编译时**的多态性（即前绑定）；重写实现的是**运行时**的多态性（即后绑定）。

### 多态

多态：即**一个接口，多个方法**。指多个子类继承并重写父类的同一属性或方法，或多个子类实现接口并覆盖接口中的同一方法，并将父类引用指向子类对象。

```
// 引用的自动类型转换，指存在继承关系的对象类型转换
Animal animal = new Dog(); // 向上转型，把Dog类型转换为Animal类型
animal.run();

// 引用的强制类型转换，编译正常，运行可能报错ClassCastException类型转换异常，建议在强转前判断对象的真实类型
Dog dog = (Dog) animal; // 向下转型，把Animal类型转换为Dog类型
animal.run();

Animal animal = new Cat();
if (animal instanceof Cat) {
    Cat cat = (Cat) animal; // 向下转型
}
```

实现多态有 3 个必要条件：
1. 子类继承父类/实现接口；
2. 方法重写；
3. 父类引用指向子类对象（向上转型）或接口的引用变量指向其实现类的实例对象。

分类：
1. 编译时多态：是静态的，主要指**方法重载**。编译后变成不同的方法；
2. 运行时多态：是动态的，即通常所说的多态性，指继承父类和实现接口时，可用父类引用指向子类对象。

特征：
1. 对于方法的调用：编译看左边，运行看右边？
2. 对于变量：编译、运行都看左边

优势：
1. 父类作为方法的形参（入参）用来传递对象；
2. 便于类与类间解耦，右边对象可组件化切换，改换业务。

劣势：
1. 编译看左边，不能调子类独有的方法。

### 值传递 VS 引用传递

Java中没有指针的概念，类似的是引用。

Java 中方法参数的传递方式是**值传递** ：

- 值传递 ：Java方法接收的是实参值的拷贝，会创建副本；方法对拷贝副本的修改不会影响实参值。
  - 参数是基本类型时：传递的是基本类型的字面量值的拷贝，会创建副本。
  - 参数是引用类型时：传递的是实参所引用对象在堆中地址值的拷贝，同样也会创建副本。
    - 方法可修改引用指向对象的状态，但这仍是按值调用而非引用调用。
- 引用传递、拷贝 ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，修改形参将影响实参。

```
Son s1 = new Son("son1", 12);
Son s2 = s1;
s1.age = 23; // 会影响s2
s1 == s2? // true，二者指向的地址相同
```

<img src="assets/引用拷贝.png" alt="image-20201216222353944" style="zoom: 80%;" />

### 深拷贝 vs 浅拷贝

Java中有三种类型的对象拷贝：将一个对象的属性拷贝到另一个有着相同类类型的对象中去。

- 浅拷贝（Shallow Copy）：对基本数据类型进行值传递，对引用数据类型，进行引用传递般的拷贝（即复制引用但不复制引用（指向的对象）内的对象）。

  - 在当前类中实现Clonable接口并重写Object类的`protected clone()`，在方法内直接调用父类的`clone()`方法，即`return super.clone()`。

  ```
  Class Son implements Cloneable {
  	String name;
  	Father father;
  	....
  	@Override
  	protected Son clone() throws CloneNotSupportedException {
  		return super.clone();
  	}
  }
  	Father f = new Father("bigFather");
      Son s1 = new Son("son1", 13);
      s1.father = f;
      Son s2 = s1.clone();
      s1 == s2? // false，二者地址不同
      s1.father == s2.father? // true，二者内的father对象地址相同，为同一个father
      
      s1.name == s2.name? // true
      s1.name = "son222"; // 改变s1.name指向的String对象
      s1.name == s2.name? // false
  ```

  <img src="assets/shallow_copy.png" alt="image" style="zoom: 90%;" /><img src="assets/shallow_copy_string.png" alt="image-20201217103648400" style="zoom: 60%;" />

  

- 深拷贝（Deep Copy）：对基本数据类型进行值传递，对引用数据类型，创建一个新对象并复制（new）其内的成员变量。比浅拷贝速度慢且花销大。

  - 通过序列化来实现深拷贝：适用于引用数量或层数太多时，原对象写入文件后拷贝给clone对象，原对象的修改不会影响clone对象，因为clone对象是从这个媒介读取。
  - 在当前类中实现Cloneable接口并重写`clone()`，在方法内new一个当前类的新对象，即`return new Student(name, subj.getName()); `。

  ```
  // Father clone()方法
  @Override
  protected Father clone() throws CloneNotSupportedException {
      return (Father) super.clone();
  }
  // Son clone()方法
  
  @Override
  protected Son clone() throws CloneNotSupportedException {
      Son son = (Son) super.clone(); // 待返回克隆的对象
      son.name = new String(name);
      son.father = father.clone();
      return son;
  }
  
  // 地址均不同，均返回false
  ```

<img src="assets/deep_copy_1.png" alt="" style="zoom:90%;" />

- 延迟拷贝（Lazy Copy）：二者组合

### 接口

`implements` 实现类；接口（interface）是用来被实现的，没有构造器。

- 类与类单继承；
- 类与接口的多实现；
- 接口与接口的多继承。

`JDK1.8` 前接口中只有：

1. 默认为抽象方法 public abstract；
2. 常量。

`JDK1.8` 后新增三个方法：

1. 默认方法：用 default 修饰，即实例方法；
2. 静态方法：只能用接口名本身调用，不能用子接口/实现类调用；
3. 私有方法：被私有方法/默认方法调用，只能在本接口中访问。

##### 抽象类

抽象方法：只有声明，没有具体的实现。

抽象类（abstract class）：包含抽象方法的类，不能用来创建对象。

- 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。
- 类继承抽象类或实现接口，要实现所有抽象方法，否则仍需被声明为抽象类。

抽象类的意义（代码复用）：

1. 为了被子类单继承；
2. 模板设计模式（部分实现，部分抽象）。

##### 抽象类 VS 接口

同：

- 都不能直接例化，（但可定义抽象类和接口类型的引用）；
- （接口的实现类或抽象类的子类）需实现相应的方法后才能被例化。

异：

1. 一个类只能**继承（extends）**一个抽象**类**；但可**实现（implements）**多个接口。抽象类被设计用来继承的，接口被设计用来实现的。
2. 接口比抽象类更抽象：抽象类可有静态方法、静态代码块、**构造器**；接口中 JDK1.8后可有静态方法，没有构造器。
3. 抽象类可定义**成员变量**；接口中的成员变量只能用public static finial修饰（JDK1.8 后默认为default），实际是常量。
4. 抽象类可有（普通成员）**方法的具体实现**；接口（只有public abstract方法定义，）不能有方法的具体实现。
5. 抽象类中的方法可用`private, protected, public`**修饰**；接口只能用`public`。

### 内部类

1. 静态内部类：作为外部类的静态成员。public static，只加载一次，寄生和宿主的关系；只能访问外部类的静态成员。

2. 成员内部类（实例内部类）：作为成员对象的内部类。可访问（private及以上）外部类的属性和方法。外部类想访问内部类属性或方法时，必须通过创建的内部类对象访问。外部类也可访问内部类属性。**实例内部类对象属于外部对象，是外部对象实例化的成员变量**；没有静态区，不能定义静态成员，能定义常量；`Outter.Inner o = new Outter().new Inner();`能访问外部类的静态成员和实例成员。

3. 局部内部类：几乎不用。方法中的内部类。只能定义实例成员，不能定义静态成员。访问权限类似局部变量，只能访问外部类的final变量。

4. **匿名内部类**：没有类名的局部内部类，只能用一次，只能访问外部类的final变量。new子类时重写父类的抽象方法可省略子类定义，立即返回匿名内部类对象；用于对象回调、创建接口对象来简化代码。


## 泛型

泛型：即参数化类型，就是一个标签：<数据类型>，用于对象具体类型不确定的情况。

可在编译阶段约束**引用**数据类型，从而不出现类型转换异常。

操作的数据类型被指定为一个参数，在类中称为泛型类、接口中称为泛型接口、方法中称为泛型方法。建议用`E，T，K，V，？（通配符）`代表。

泛型没有继承关系：虽然BMW和BENZ都继承了Car，但是ArraryList<BMW>和ArraryList<BENZ>与ArraryList<Car>无关。

```
List<String> lists = new ArrayList<>();

public interface Data<E> {
} // 泛型接口，在实现接口时再传入真实数据类型

public StudentData implements Data<Student> {
}

// 泛型的上下限：？ extend Car
// 泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add 方法，
public static void run(ArrayList<? extends Car>) {
}
// 而<? super T>不能使用 get() 方法，两者在接口调用赋值时易出错。
public static void run(ArrayList<? super Car>) {
}
```

## 注解

注解可被编译器打包进入class文件，是一种用作标注的元数据。

用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。

1. 由编译器使用的注解，作用在代码上。如：
   - `@Override`：检查该方法是否正确地实现了覆写；
   - `@Deprecated`：标记过时方法。如果使用该方法，会报编译警告；
   - `@SuppressWarnings`：告诉编译器忽略此处代码产生的警告；
2. 元注解：作用在其他注解上的注解。
   - `@Retention`：标识这个注解怎么保存，是只在代码中，还是编入class文件中，或是在运行时可通过反射访问。
   - `@Documented`：标记这些注解是否包含在用户文档中。
   - `@Target`：标记这个注解应是哪种 Java 成员。
   - `@Inherited`：标记这个注解是继承于哪个注解类（默认没有继承于任何父类）。
3. 从 Java 7 开始，额外添加了 3 个注解:
   - `@SafeVarargs`： 忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。
   - `@FunctionalInterface`：Java 8 开始支持，标识一个匿名函数或函数式接口。
   - `@Repeatable`：Java 8 开始支持，标识某注解可在同一个声明上使用多次。
4. 在程序运行期能读取的注解。在加载后一直存在于JVM中，最常用。如：
   - `@PostConstruct`标注的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。

## IO 和 序列化

### 序列化

序列化： 一个对象可被表示为一个字节序列，包括对象的类型信息、对象的数据、存储在对象中的数据类型。可反序列化，在内存中新建对象。

整个过程都是 JVM 独立的，即，在一个平台上序列化的对象可在另一个完全不同的平台上反序列化该对象。如果JVM在反序列化时找不到该类，则抛出一个 ClassNotFoundException 异常。

Serializable 序列化接口：是java.io包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口。没有任何方法或字段，只是用于标识可序列化的语义。实现了Serializable接口的类可被ObjectOutputStream转换为字节流，同时也可通过ObjectInputStream再将其解析为对象。

具体实现：

- 实体类实现Serializable接口；

- 类的所有属性都是可序列化的。

- 显式地定义 serialVersionUID：在反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的。序列化类新增属性时，不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，需修改。

  ```
  private static final long serialVersionUID = 1L; 
  ```

常见应用场景：

- 把内存中的对象状态数据保存到一个文件或数据库中时，比较常见，如用mybatis框架编写持久层insert对象数据到数据库中时；
- 网络通信用套接字在网络中传送对象时，如用RPC协议进行网络通信时;

Stream流

ObjectInputStream 和 ObjectOutputStream类

- public final Object readObject() throws IOException 方法：序列化一个对象，并发送到输出流；
- public final Object readObject() throws IOException,  ClassNotFoundException 方法：从流中取出下一个对象，并反序列化。返回值为Object，因此需转成合适的数据类型。

```java
Employee e = new Employee();
e.name = "Reyan Ali";
FileOutputStream fileOut = new FileOutputStream("/tmp/employee.ser");
ObjectOutputStream out = new ObjectOutputStream(fileOut);
out.writeObject(e);
out.close();
fileOut.close();

FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");
ObjectInputStream in = new ObjectInputStream(fileIn);
e = (Employee) in.readObject();
....
```

[Java对象为啥要实现Serializable接口？](https://zhuanlan.zhihu.com/p/66210653)

### NIO

IO 多路复用

- [Java NIO - 基础详解](https://pdai.tech/md/java/io/java-io-nio.html)

### AIO

### BIO

## 网络编程

- Socket 编程

- URL 处理

## 反射机制

##### 反射

反射：将（类/接口的）`.class 字节码文件`加载进 JVM （的方法区）时，会（在堆中）创建一个对应的`java.lang.Class 对象`，用来映射类中的各种成分。用于在**运行期/时**获取**Class 类对象**及其类内部详细信息（成员方法、属性、构造函数等）、及**反向控制**实例对象的能力。

- 通过Class实例获取`class`信息的方法称为反射。
- 这种动态获取类信息及调用对象方法的功能称为Java语言的**反射机制**。

<img src="assets/java-basic-reflection-3.png" alt="img" style="zoom:65%;" />

##### 应用场景

多用于框架的底层原理，是框架的灵魂。可在运行时分析类及执行类中方法。

- Spring/Spring Boot、MyBatis 等框架中都大量使用反射机制，框架中**动态代理**的实现也依赖反射；
  - 动态代理机制：JDK提供的（如`Proxy.newProxyInstance()`）没有实现类、但在运行期动态创建接口对象的方式。通过`Proxy`创建代理对象，然后将接口方法“代理”给`InvocationHandler`完成的。
- 注解的实现也用到反射。
- `toString()`里重写并打印类信息。

##### 优缺点

优点 ：代码更灵活；为各种框架提供开箱即用的功能提供便利；

缺点 ：不安全。如可无视（发生在编译时的）泛型参数的安全检查；性能稍差。

##### 获取 Class 类对象

获取Class对象的方式有：

1. 一般不知道具体类，知道具体类的情况下：类名.class。Class 对象不初始化，不执行静态代码块和静态对象；

2. 实例对象.getClass()，继承自Object.getClass()；

3. Class.forName("类的全限定名")；

4. ~~通过类加载器`xxxClassLoader.loadClass(类路径？)`。Class 对象不会进行初始化。~~

```
ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.User");
```

##### 反射的使用/基本操作

可通过以下类调用反射API：

- **Class 类**：可获得（Class对象所表示的）类的属性、方法，是一个Java中的泛型类型。用于封装被加载到JVM中的类和接口的信息。Class类常用方法有：
  - Class<?> getClass()：获取类引用
  - getSimpleName()：获取类名
  - getName()：获取全限定类名
  - newInstance()：实例化
  - getPackage()
  - `Class getSuperclass()`：获取父类类型；
  - `Class[] getInterfaces()`：获取当前类实现的所有接口。
  - Constructor<?>[] getConstructors()
  - `Fileds[] getFileds()`
  - `Field getField(String name)`：获取公有字段；
  - `getDeclaredFields`：用于获取所有声明的字段，包括公有和私有字段；
  - Method[] getMethods()
  - Method getMethod(String name, Class<?>... parameterTypes)
- Construct 类：获取（Class对象所表示的）类的构造方法，可在运行时动态创建对象。
- Field 类：获取（Class对象所表示的）类的成员变量，及对它的（运行时）动态修改权限（包含private）。
  - `setAccessible(true)`：为了调用private方法而取消安全检查；
  - `getName()`：返回字段名称，如`"name"`；
  - `getType()`：返回字段类型，也是一个`Class`实例，如，`String.class`；
  - `getModifiers()`：返回字段的修饰符，是一个`int`，不同的bit表示不同的含义。
- Method 类：获取（Class对象所表示的）类的成员方法，可动态调用对象的方法（包含private）。
  - Object invoke(Object obj, Object... args)：JVM调用包装在当前Method对象obj中的方法，并传入方法调用的参数args。调用静态方法时传入的第一个参数为`null`；
  - `getName()`：返回方法名称，如：`"getScore"`；
  - `getReturnType()`：返回方法返回值类型，也是一个Class实例，如：`String.class`；
  - `getParameterTypes()`：返回方法的参数类型，是一个Class数组，如：`{String.class, int.class}`；
  - `getModifiers()`：返回方法的修饰符，是一个`int`，不同的bit表示不同的含义。
- Object 类：是所有 Java 类的父类。

```
/**
 * 建立和插入关系表操作
 *
 * @param dao       可以操作的dao
 * @param dataList  要插入的数据
 * @param productId 建立关系的id
 */
private void relateAndInsertList(Object dao, List dataList, Long productId) {
    try {
        if (CollectionUtils.isEmpty(dataList)) return;
        for (Object item : dataList) {
            Method setId = item.getClass().getMethod("setId", Long.class);
            setId.invoke(item, (Long) null);
        }
        Method insertList = dao.getClass().getMethod("insertList", List.class);
        insertList.invoke(dao, dataList);
        
        /**
         * 获取指定参数，并对参数进行修改
         */
        Class<?> targetClass = Class.forName("cn.javaguide.User");
        Field field = targetClass.getDeclaredField("value");
        //为了对类中的参数进行修改，取消安全检查
        field.setAccessible(true);
        field.set(targetObject, "JavaGuide");
        
    } catch (Exception e) {
        LOGGER.warn("创建产品出错:{}", e.getMessage());
        throw new RuntimeException(e.getMessage());
    }
}
```

[JavaGuide 反射的一些基本操作](https://javaguide.cn/java/basis/reflection.html#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)

##### 反射机制执行流程及原理

- 反射是线程安全的；
- 反射用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；
- 当找到需要的方法，会copy一份，而不是用原来的实例，从而保证数据隔离；
- 调度反射方法，最终是由 JVM 执行 `invoke0()` 执行；

## 异常

http://c.biancheng.net/view/6635.html

- 拋出（throw）异常：生成异常对象，并提交给 JVM。

- 捕获（catch）异常：JVM 在方法栈中查找能处理该类型异常的对象。捕捉异常并处理的代价远大于直接抛出。

### 异常分类

可检查异常和不可检查异常：除了，其他的都是检查异常。

- `unchecked exceptions`（非检查异常）：`RuntimeException` 及其子类、 `Error`。
- `checked exception`（检查异常）：代码还没运行，编译器就会检查，并要求必须处置的异常。必须要对这段代码 `try...catch`，或 `throws exception`。

顶级父类 Throwable：将异常层层抛给顶层，统一处理。

- `Error`：非检查异常，程序无法处理（无法通过 catch 捕获，只能尽量避免）的错误。发生时JVM会终止线程。如
   - `Java Virtual Machine Error`
   - `OutOfMemoryError（OOM）`
   - `StackOverFlowError`
   - `NoClassDefFoundError`：类定义错误等。

- `Exception`：程序本身可处理（通过 try-catch 捕获）的异常。如
   - **`RunTimeException`** 运行时异常、非检查异常，可不处理；
     - `ArrayIndexOutOfBoundsException`：数组下标越界；
    - `ArrayStoreException`：向类型不兼容的数组元素赋值；
    - `NullPointerException（NPE）`：使用 JDK8 的 Optional 类来防止 NPE 问题。可能出现 NPE 的有，需进行 NPE 检查：
       - 级联调用 `obj.getA().getB().getC();` 一连串调用；
       - 远程调用返回对象时；
         - 数据库的查询结果可能为 null；
         - 对于 Session 中获取的数据；
       - 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null；
       - 返回类型为基本数据类型，return 包装数据类型的对象为 null，自动拆箱将抛出 NPE，`public int method() { return Integer 对象; }`。
    - `ClassCastException`：类型转换异常；
    - `ArithmeticException`
    - `NumberFormateException`：如，在解析字符串形式的数字时，可能存在数字格式错误；
   - 非运行时异常、检查异常。从语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。
     - `IOException`
     - `ClassNotFoundException`
     - `InterruptedException`：线程被另一个线程中断；
     - `IllegalAccessException`：访问类被拒绝；
     - `NoSuchMethodException`：通过反射机制调用的方法不存在；
     - 及用户自定义的 Exception 异常。

### try / catch / finally

**finially 代码块**：表示附带的语句块最终一定被执行，遇错也一定执行，在return前执行；常用于回收、释放资源。

以下情况不会执行，直接结束：

- 当程序在进入try语句块前就出现异常时。
- 当程序在try块中强制退出时，如用System.exit(0)。

其它情况下，在try/catch/finally语句执行时，try块先执行，
- 当有异常发生，catch和finally进行处理后程序就结束了；
- 当没有异常发生，在执行完finally中的代码后，后面代码会继续执行。

值得注意的是，
- 当 try/catch 语句块中有return时，finally语句块中的代码会在return前执行。
- 如果 try/catch/finally 块中都有return语句，finally 块中的 return 语句会覆盖 try/catch 模块中的。

### throws VS throw

throws：一般用在方法声明上，代表可能会抛出的异常列表。

throw：一般用在方法内部（出现异常的地方），由开发者定义，当程序语句出现问题后，创建异常对象并立即主动抛出一个异常。

```
try{
} catch (FileNotFoundException e) {
    // 打印异常堆栈
    e.printStackTrace();
} catch (Exception e) {
    e.printStackTrace();
}
```

## JDK1.8 新特性

##### Interface

- interface 中的方法可用`default` 或 `static`修饰，这样就可有方法体，实现类也不必重写此方法。

##### Lambda 表达式

用于：

- 简化、替代（函数式接口的）匿名内部类写法；
- 集合迭代；
- 方法的引用；
- 访问变量；

语法格式

```
(parameters) -> expression 或
(parameters) ->{ statements; }
```

##### Stream

新增了 `java.util.stream` 包

##### Optional

用于解决 NPE 问题

##### Date-Time API

- 格式化；
- Java 8 前转换都需借助 `SimpleDateFormat` 类，而**Java 8 后**只需 `LocalDate`、`LocalTime`、`LocalDateTime`的 `of` 或 `parse` 方法；
- 之前都对应 `Date`；现在JDBC时间类型和 Java8 时间类型对应关系是：
  1. `Date` ---> `LocalDate`；
  2. `Time` ---> `LocalTime`；
  3. `Timestamp` ---> `LocalDateTime`。
- 引入 `java.time.ZonedDateTime `来表示带时区的时间，可看成是 `LocalDateTime + ZoneId`。

## 常用类

### Collections 类

```
int min = (int) Collections.min(Arrays.asList(numbers));
```

### Object 类

如果定义类时并未显式指定父类，则默认继承 `java.lang.Object` 类

- `toString()`：默认返回类（带包的）全名`@`当前对象在堆内存的地址，通常重写来返回对象的内容；如`"org.webtree.www.User@Hello"`；

- equals()：默认比较对象的地址是否相同；

```
// 方法一：
@Override
public boolean equals(Object obj) {
    if (obj instanceof Student) {
    	Student stu = (Student)obj;
      	return this.name.equals(stu.name); // this.name 无判空
    } else {
      	return false;
    }
}
// 方法二：IDEA自动生成
```

-  `clone()`：慎用，默认是[浅拷贝](#深拷贝 vs 浅拷贝)，若想实现深拷贝需覆写 clone() 方法实现成员对象的深度遍历式拷贝。

- `finalize()`：当GC准备好释放对象占用空间时，首先会调用finalize()，并在下一次垃圾回收动作发生时真正回收对象占用的内存。


### Objects 类

```
Objects.equals(o1, o2); // 推荐使用
```

### String 类

~~String类有11种构造方法：~~ 

##### String 类

String 用[finial](final 关键字)修饰的字符数组保存，每次都创建新对象（多了会导致性能降低）。一旦创建，其值不可改变，适用于**不常改变长度**的字符串，String.length()；

   - [String是final类，不可变](https://xmmarlowe.github.io/2021/09/10/Java/Java-String%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8final%E4%BF%AE%E9%A5%B0%EF%BC%9F/)；原因：

   ```
   private [final] char value[]
   
   String s = “Hello World”; 
   // 获取String类中的value字段
   Field val = String.class.getDeclaredField(“value”);
   // 改变value属性的访问权限
   val.setAccessible(true);
   
   // 获取s对象上的value属性的值
   char[] value = (char[]) valueFieldOfString.get(s);
   // 改变value所引用的数组中的第5个字符
   value[5] = ‘_’; //Hello_World
   ```

   - `final`：表示char数组的引用地址不可变；
   - `private`修饰符：表示值不会被外部修改。其实可通过反射机制改变值。
   - 二者配合保证用String类声明的对象的值不可变。
   - 好处：

     1. 使 JVM 可实现**字符串常量池**：复制String变量、new同一字面量、不同的字符串变量指向相同的字面量，都是指向字符串常量池中的同一内存地址的同一对象。
        - 可重复使用字符串常量，避免每次都重新创建相同的对象，节省内存。
        - 不影响引用该对象的其他变量，如果字符串是可变的，当某个变量改变了该内存的值时，其他指向该内存地址的变量的值也会改变，不符合常量池设计的初衷。

      2. 保证了字符串对象在**多线程**环境下是**线程安全**的。常用字符串来传递数据，如数据库的用户名密码、网络编程中的ip和端口。因为字符串是不可变的，故值不能被修改；如果可变，那么可通过改变引用地址指向的值去修改字符串的值，从而导致安全漏洞。
      3. 内存地址不变，**HashCode** 由内存地址间接得到，保证了 HashCode 的唯一性：创建String时hashcode就被缓存了，不必每次重新计算，处理速度快，很适合作为Map的键。
   - 缺点：每次修改String对象都会产生新对象，占用内存。如 String 对象`+`操作直接生成新常量，并把 String 对象引用指向新常量。

##### 字符数组、StringBuffer、StringBuilder

1. 字符数组；

   ```
   // 用字符数组构造字符串变量
   char[] strArr = { 'H', 'e', 'l', 'l', 'o' };
   String s = new String(strArr);
   ```

StringBuffer、StringBuilder 都是对**原对象**操作，都用无final修饰的字符数组保存。

2. `StringBuffer`：线程安全（多线程、共享变量、结果不受影响），方法都是 `synchronized` 修饰的，推荐用于多线程使用共享变量的情景。对象创建后，仍可修改值。

3. `StringBuilder`：性能最好? 非线程安全。重载 toString() ，在调用该类对象时自动返回一个字符串，用`System.out.println(对象名)`可打印出来。
   - 循环体内，字符串的连接需用 `append()` 方法进行扩展；
   - 如直接用 String，每次循环都会 new 出一个 StringBuilder 对象，然后进行 append() 操作，最后通过 toString() 返回 String 对象，造成内存资源浪费。

- [Java String 类](https://www.runoob.com/java/java-string.html)
- [String字符串常用函数](https://blog.csdn.net/CSDN2497242041/article/details/106814072)

##### 获取

- `int length() `: 字符数
- `char charAt(int index)`: 返回指定索引处的char值
  
  - 当访问到不存在的角标时会发生StringIndexOutOfBoundsException（角标越界异常）
- `int indexOf(**int** ch, [int fromIndex])`：从指定位置开始，获取ch第一次出现的索引位置
  
  - 没有则返回-1；
- `int indexOf(**String** str, [int fromIndex])`
- `lastIndexOf()`：同indexOf
- `String substring(begin, [end])`：**切片**，截取指定位置 [begin,end) 的新子串。 
- `String[] split(String regex, [int limit])`：根据正则匹配**切割/拆分**，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。
  
  - regex：正则表达式分隔符。
  - limit：分割份数。
  ```
  String str = "a,b,c,,";
  String[] ary = str.split(",");
  // 预期大于 3，结果等于 3
  System.out.println(ary.length);
  ```

##### 判断

- `boolean contains(str)`: 是否包含子串
  - 同：`if(str.indexOf(str) != -1)`，区别：无法获取子串出现的位置。
- `boolean isEmpty()`: 是否有内容。原理是判断字符串长度是否为0
- `boolean startsWith(String prefix)`：是否以指定前缀开头
- `boolean endsWith(String suffix)`：
- `boolean equals(str)`：判断字符串内容是否相同。重写了Object类中的equals()，只判断字符串内容是否相同
- `boolean equalsIgnoreCase()`：忽略大小写，判断内容是否相同
- `int compareTo(str)`：对两个字符串进行字典顺序的比较，基于字符的 Unicode 值。相等返回 0；小于str参数，返回负数。

##### 替换和合并

操作都不是在原有的字符串对象上进行的，而是生成了新的String对象，然后将原String的变量引用指向新对象。

- `String replace(char old, char new)`: 如果要替换的字符不存在，返回原串
  - `String replace(" ",“”)`：消除字符串所有空格
  - `String trim()`：删除字符串的头尾空白符
- `String replaceAll(String regex, String replaceStr)`：用 replaceStr 替换所有正则匹配的子串。
- `String replaceFirst(String regex, String replaceStr)`：只替换匹配的第一个子串。
- `String concat(String str)`: 将 str 拼接到结尾，不能拼接其他类型，二者都不能为null，否则运行时会报空指针异常 NPE（编译时没有报错）。
- `+`：可对字符，数字，字符串等数据类型的拼接
- `StringBuilder.setCharAt(index, char)`：替换单个字符

```
String str = "Test string";
StringBuilder strBuilder = new StringBuilder(str);
strBuilder.setCharAt(1, 'X');
str = strBuilder.toString();
```

##### 转换

- `char[] toCharArray()`：将字符串转成字符数组`for(char ch : str.toCharArray()){}`
- `byte[] getBytes()`：将字符串转成字节数组
- `String(byte[])`：将字节数组转成字符串
- `static String **String.valueOf**(int)`： 将基本数据类型int转成字符串
- static String valueOf(double)`：将基本数据类型double转成字符串
- `String toUpperCase()`：将字符串全部转成大写
- `String toLowerCase()`

### Math 类

- `abs()`
- `ceil()`：取上限
- `floor()`
- `pow(2, 3)`
- `round(4.9999)`

### Date / Calendear / LocalDate 类

- `SimpleDateFormat` 是线程不安全的类，一般不定义为 static 变量，如果定义为 static，必须加锁，或用 DateUtils 工具类。

```
import java.util.Date;

Data d = new Date();
long ts =  d.getTime(); // 时间戳

System.currentTimeMillis(); // 获取当前毫秒数，而不是 new Date().getTime()

SimpleDataFormate sdf = new SimpleDateFormate("yyyy-MM-dd HH:mm:ss EEE a"); //统一为 GMT

String rs = sdf.format(d);
String rs2 = sdf.format(ts);

sdf.parse("2019-09-11");

// 获取今年的天数 365
int daysOfThisYear = LocalDate.now().lengthOfYear(); 
// 获取指定某年的天数
LocalDate.of(2011, 1, 1).lengthOfYear();

Calendar calendar = Calendar.getInstance();
calendar.add(Calendar.YEAR, 71); // after 71 year
calendar.set(2020, 1, 26);
calendar.add(Calendar.DATE, daysOfThisYear);//一年后
```

### BigInteger / BigDecimal 类

用来做精度运算

```
BigDecimal bd = BigDecimal.valueOf(0.3333);
bd.add(0.111);
bd.doubleValue();
```

### 枚举类
用于信息标志和信息分类，元素为常量对象

多例模式

继承Enum类

```
Sex s = Sex.BOY;
s.ordinal();// index
Sex.values();//all values
```

### 正则表达式 Pattern类

适合做校验

```
"hello".matches("\\d{4,}");
"he2kele4we".splite("\\d+");
"he2kele4we".replaceAll("\\d+", "/");

Pattern pt = Pattern.compile("\\d+");
Matcher mt = pt.matcher("hjeiji@jhj@".);
while(matcher.find()) {
  matcher.group();
}
```

### System 类

- exit()
- cuurentTimeMilis()
- copyArray()基本不用