---
title: Java语言基础
categories:
  - 编程语言
tags:
location:
abbrlink: '8urh23fh'
permalink: '8urh23fh'
date: 2021-06-01 13:42:12
updated: 2021-06-01 13:42:12
---

摘要：Java语法，包括final、static关键字，数据类型，面向对象的封装、继承和多态，常用类等。

<!-- more -->

---

[Java基础知识点和答案](https://github.com/gzc426/Java-Interview/blob/master/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%92%8C%E7%AD%94%E6%A1%88.md)

## Java VS C++

1. 纯面向对象的语言（封装、继承、多态）-> 低耦合的系统，易维护、复用、扩展；C++ 兼容 C，效率高但有面向过程。
2. JVM：跨平台/平台无关，一次编译到处运行（很好的可移植性），字节码运行机制，既有编译又有解释；C++为编译型语言，C++11 数组，Windows VS Linux。
3. JVM：自动内存管理，没有指针（除 `Unsafe` 类），内存更安全；C++ 要手动释放内存，指针易导致野指针（指向垃圾内存的指针：没有初始化直接使用导致野指针；free 或 delete 后没有置为 NULL，被当做合法指针使用导致野指针）、空指针 NPE、内存泄漏。 
4. 多线程：支持多线程；C++ 没有内置的多线程机制，必须调用 OS 的多线程功能。
5. 继承：Java类单继承，接口多继承；C++ 类支持多重继承；
6. 重载：Java 只支持方法重载；C++ 同时支持方法重载和操作符重载
7. 支持网络通信编程且很方便，支持Web应用开发

## JDK、JRE、JVM 对比

- `JDK（Java Development Kit）`，是一种功能齐全的 Java SDK，用于程序开发者创建、编译程序。
   - Java 开发组件：`javac` 编译器、`jar` 打包工具、`javadoc` 文档生成器、`java-debuger（jdb）`调试工具、`javap -c` 反汇编；
   - `JRE（JAVA Runtime Environment）`：包含普通用户运行 Java 程序所需的全部内容。
       - `JVM（JAVA Virtual Machine）`：是一个用于执行**Java 字节码**的虚拟机进程，针对不同系统有特定的实现；实现**一次编译，到处运行**；如，`HopSpot、JRockit、J9Vm`。
       - 用于产品环境的 Java 类库。
   - Oracle JDK vs OpenJDK

## 基本语法

### 关键字

注意 ：虽然 `true`, `false`, 和 `null` 看起来像关键字但实际上是字面值，同样也不可作为标识符。

<img src="assets/Java-key-words.png" alt="image-20220817125334449" style="zoom: 65%;" />

## 常量和变量

### （非 static）成员变量 VS 局部变量

[静态变量/类变量](#二、修饰成员变量（=>静态变量/类变量）)

1. 定义（本质）：static 成员变量属于类，用类名调用，由类的所有对象共享，持久驻内存，下次调用保留原值；非 static 成员变量属于对象，用对象名调用；局部变量是在代码块/方法中定义的变量/方法参数。
2. 修饰符：成员变量都可以；局部变量不能被**访问控制修饰符**及 static 修饰，只能被 final 修饰。
3. 存储位置：static 成员变量属于类，存于方法区，（非 static ）成员变量属于对象，存于堆内存；局部变量存于VM栈中的局部变量表。
4. 默认值：成员变量有默认值，在JVM类加载时自动初始化（如未赋初值则取默认值）（例外：被 final 修饰的必须显式地赋值）；而局部变量（不自动初始化）必须显式地初始化，在字节码执行时才会运行方法中的（局部变量）代码。
5. 生命周期：成员变量与类/对象一致；局部变量与方法一致。

```
public  class DataClass {
    int age; // 成员变量/全局成员变量/实例变量
    static String URL = "hello"; // 静态成员变量
    static final String website = "C"; // 静态常量
}
```

### final 关键字

final 核心思想：最终的、不可修改的；表示变量值不可变、方法不可覆盖、类不可继承。

##### 一、修饰类：不可被继承（没有子类）

- 所有成员方法被隐式指定为final，（但成员变量不变）；

- abstract和final互斥、冲突，二者不能同时存在；

- 所有包装类都是用final修饰；

  - String是final类，不可变；

##### 二、修饰方法：final方法不可**重写**，可重载

作用：

- =>用于防止子类覆盖父类方法的实现，安全；如：POJO 类的 setter 方法，不允许被覆写。
- =>方法被转为内嵌，提高执行效率。

> （类中所有）private 方法都被隐式指定为 private [final] ；
> final也可修饰private，但无意义。

##### 三、修饰变量：实质上是常量

从变量类型分类：
1. 修饰基本类型或 String 类型的变量：使用前必须有且仅有一次初始化，初始化后值不可变，第二次赋值将抛出编译时错误（`Compiler Error: cannot assign a value to final variable`）。
   
   - 若编译阶段已知其确切值，则会当做**编译期常量**（直接宏替换），存入调用类的常量池中。
   
2. 修饰引用类型变量：初始化后**引用**不可变（即不能指向另一个对象），但**引用指向的对象的内容**可变。即 final 数组 / 集合可添加、删除元素。

   1. 字符型常量 VS 字符串常量

      1. **形式** : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。

         ```
         //  `char` 在 Java 中占两个字节
         final char ch = 'a';
         private [final] char value[] = {'b', 'u', 'f', 'f'};
         final String str = "hello";
         ```

      2. **含义** : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。

      3. **占内存大小** ： 字符常量只占 2 个字节; 字符串常量占若干个字节。

   2. `String` VS `final String`

      - [==比较引用的地址](#运算符 == VS equals())
      - String 为变量；final String为编译期常量

      ```
      // 字面量“hello2”存入字符串常量池中，a为变量，指向常量池的地址
      String a = "hello2";
      
      // b为编译期常量，指向常量池的地址
      final String b = "hello";
      // c为变量
      String c = "hello"; 
      
      // true，b是常量，在编译期间就计算出了b+2=”hello2”，在常量池中找到已有地址，与a相同
      a == b + 2;
      // false，c是变量，在编译期间不能确定其值，在堆中新建对象”hello”，+运算得到新变量 “hello2”，二者地址不同
      a == c + 2;
      ```

从变量位置分类：
1. 修饰静态成员变量（修饰类变量、常量=const）：只可在静态初始化块中/声明时赋初值；
2. 修饰（实例）成员变量：只可在非静态初始化块中/声明时/**每个构造器中**赋初始值；
3. 修饰局部变量：使用前赋值，不允许二次赋值。

```Java
// 静态常量，作用域是全局，不用创建对象，用类名直接访问
HelloWorld.PI;

public class HelloWorld {
    // 修饰静态常量
    public static final double PI = 3.14;
    // 修饰成员常量
    final int Y = 10;
    public static void main(String[] args) {
        // 修饰局部常量
        final double X = 3.3;
    }
}
```

- 在 foreach 语句中可用 final 声明存储循环元素的变量

- 局部内部类和匿名内部类只能访问局部 finial 常量：因为外部类运行后局部变量会被回收，内部类延长局部变量copy的生命周期、用finial保证二者一致。JDK1.8后默认加 finial。


### static关键字

static 修饰的成员属于类，可被类的所有对象共享，加 static 不影响作用域。只保存一份拷贝，建议用类名调用。

##### 一、修饰成员方法（=>静态方法、类方法）：

不依赖任何对象，在类加载时（在方法区）分配内存，可通过类名直接访问；非 static 成员（变量或方法）在对象实例化前不存在，不能被 static 方法调用：

- ==>只能访问类的静态成员；

- ==>方法中不能以任何方式引用this和super；但反之在非静态方法中可通过this访问静态成员；

方便在没有创建对象的情况下调用方法/变量，如：
1. Collections类中的一些方法，如Objects.equals()，[Arrays 工具类](#Array 类和 Arrays 工具类)的静态方法；
2. util工具类中的方法。如[Math 工具类](#Math 类)的静态方法；
3. 单例模式的 `getInstance()`、工厂模式的`create/build()`、`Logger LOGGER = LoggerFacbory.getLogger(Users.class)` 等。

构造器不是静态方法：
- 定义：不是方法，只负责初始化；
- this：构造器中可使用this（指向当前对象），而静态方法不依赖任何对象；
- 调用：只能通过new（或别的构造器）调用，不能通过方法调用。

##### 二、修饰成员变量（=>静态变量/类变量）

>  实质上就是全局变量；

目的：作为共享变量使用；减少对象的创建；保留唯一副本。

- 内存分配：由类的所有对象共享，持久驻内存，下次调用保留原值；
- 存储位置：static 成员变量属于类，存于方法区，（非 static ）成员变量属于对象，存于堆内存；局部变量属于方法，存于VM栈中的局部变量表。
- 调用方式：（推荐）用类名调用；
- 生命周期：从类被加载开始，到类被 GC 彻底回收时；

##### 三、静态代码块

执行顺序：静态代码块-->非静态代码块-->构造器。 

定义在类中方法外，用于初始化静态变量（给静态变量/类变量赋值）：不管创建多少对象，静态代码块都只执行一次；对于定义在它之后的静态变量，可赋值，但不能访问。如单例模式、定义枚举类。

非静态代码块与构造函数的区别是：非静态代码块是对所有对象进行统一初始化，而构造函数是给对应的对象初始化。

##### 四、静态内部类

> static只能修饰内部类。

非静态内部类在编译完成后会隐含地保存一个引用，指向创建它的外部类，但静态内部类没有。意味着：

- 创建不依赖外部类的创建；
- 不能使用任何外部类的非 static 成员变量/方法。

如：`AB-BA` 死锁问题。

##### 五、静态导入包

> 1.5 后的新特性， 格式为：import static，可导入某个类中的指定静态资源，且不需用类名调用类中静态成员，可直接用类中静态成员变量/方法。

### final VS static 变量

```
class MyClass {
	// 所有实例共享
    public final double i = Math.random(); 
    public static double j = Math.random();
}

MyClass cls1 = new MyClass();
MyClass cls2 = new MyClass();

cls1.i == cls2.i; // false，两个i值不同
cls1.j == cls2.j; // true，两个j值相同
```


## 数据类型

### 四大类八小类基本数据类型

> primitive type，所占空间大小，默认值

1. 布尔型 `boolean` 占用大小根据实现 JVM 不同有所差异，逻辑上是1Byte false：不能转换成任何数据类型，true != 1；
2. 字符型 `char` 2Byte 'u0000'：0 ~ 65535
3. 整型
   1. `byte` 1Byte 0
   2. `short` 2Byte 0：32767
   3. `int` 4Byte 0：2^31-1 = 2,147,483,647
   4. `long` 8Byte 0L：[BigInteger 类](#BigInteger 类)
4. 浮点型
   1. `float` 4Byte 0F：
   2. `double` 8Byte 0D：

```
long price = 12.2L
float price = 12.2F; 
double price = 12.254(D);
```

### 包装类

> wrapper class，箱子

包装类都是final修饰，无法继承。

##### 基本数据类型 VS 包装类

区别：

1. 根本：数据类型；面向对象的类。
2. 存储位置：基本数据类型**的局部变量**直接存放在VM栈的局部变量表中，占用空间小，基本数据类型的非 `static` **成员变量**存放在堆中；而包装类属于对象类型，对象存在堆中。  
3. 默认值：基本数据类型有默认值（int = 0）且不是 null；包装类型若不赋值则为 null。
4. 泛型：基本类型不可用于泛型；包装类型可以。

##### 包装类型的常量池缓存机制

包装类放入常量池的取值：

1. `Boolean`：`TRUE/FALSE` 两个常量，用于表示布尔值 `true 和 false`；
2. **`Character`**：[0,127]；
3. `Byte Short **Integer** Long`：[-128,127]；
4. `Float、Double`：不会进入常量池；
5. `String` 类型：所有字面量都会进入常量池；

包装类在常量池的值会**复用**已有对象的缓存数据，可直接用`==`判断；其它范围的值，必须全部用 `equals()` 比较；

- 如，对于 `Integer var = 40` 在 -128 至 127 间的赋值，会发生装箱，Integer 对象是在 **`IntegerCache.cache`** 产生，会复用（缓存中的）已有对象；此区间外的所有数据都在**堆**上产生，不复用已有对象。
- 而`Integer i2 = new Integer(40)` 会直接创建新的对象。

##### 自动装箱/拆箱机制

从 JAVA SE5 开始引入自动装箱/拆箱机制->将基本数据类型当成对象操作，使二者可相互转换：

- **装箱**：将基本类型用对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

自动拆箱的时机：

1. 将包装类型变量直接赋值给对应基本数据类型时；
2. 当要访问对象的真实数据值时，如输出对象的值；
3. 当要对包装类的实际值进行数学运算时，如比较大小。

频繁拆装箱，也会严重影响系统的性能，应尽量避免不必要的拆装箱操作。

```Java
// 装箱
Integer i1 = new Integer(128); // 手动装箱，基本数据类型 => 堆内存中的包装类对象
Integer i2 = 128; // 自动装箱，调用 Integer.valueOf(66)，i2指向常量池中的对象；Double、Float的valueOf()类似。
i1 == i2? // false，比较引用，常量池外的值不复用，不同对象的地址不同；若为[-128, 127]，则复用已有对象，地址相同，返回true
i1.equals(i2)? // true，不同对象的值相等

// 拆箱
int d3 = i2.intValue(); // 手动拆箱，包装类对象 => 基本数据类型
int d3 = i2; // 自动拆箱，调用 i2.intValue()/xxxValue()
```

##### 与字符串间的转换

继承自 `Object` 类的方法：

```
Integer i3 = Integer.valueOf(str); // 字符串 => 包装类对象
String str = i1.toString(); // 包装类对象 => 字符串

int i3 = Integer.valueOf(str); // （推荐，经典代码）字符串 => 包装类对象 => （自动拆箱）基本数据类型
int i4 = Integer.parserInt(str); // 字符串 => 基本数据类型
```

### 数据类型转换

自动类型转换：

a.                	`char -> int -> long -> float -> double`
b. `byte -> short -> int -> long -> float -> double`


- 下转型（down-casting，也称为窄化）会造成精度损失；
- 将 float 变量赋值给 int 变量需用强制类型转换；

- instanceof 关键字：若对象为类（或接口、抽象类、父类）的实例，则返回 true；

三目运算符 `condition ? 表达式 1 : 表达式 2 `中，注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常。如表达式 1 或 表达式 2 的值：

1. 任一个是基本数据类型；

2. 类型不一致，会强制拆箱升级成表示范围更大的那个类型。 

  反例：
```
Integer a = 1;
Integer b = 2;
Integer c = null;
Boolean flag = false;
// a*b的结果是int类型，那么c会强制拆箱成int类型，抛出NPE异常 
Integer result = (flag ? a * b : c);
```

### 运算符 == VS equals()

引用相等和对象相等的区别：

- 引用相等：一般比较的是指向的内存地址是否相等，用 `==` 比较；
- 对象相等：一般比较的是内存中存放的内容是否相等，用 `equals()`比较；

##### 运算符 ==

对于 `==`，因为 Java 只有值传递，所以不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

1. 用于基本数据类型，直接比较其（vm栈中）存储的值是否相等；
2. 用于引用类型，比较两个引用是否指向同一块内存（堆内存中的对象地址）/同一个对象；
   - 除非是同一个new出来的对象才为true，或在字符串常量池中指向同一个内存地址，否则为false。因为每new一次，都会重新开辟堆内存空间。
   - `null == null`：返回 true，null 既不是对象也不是一种类型，仅是一种特殊的值；
3. 表达式（包含算术运算）== 包装类（触发自动拆箱 => 基本数据类型）：比较的是数值；

```
42 == 42.0? // true
```

不能用 `==` 比较的有：

1. 基本类型的变量、值 == 引用类型的变量、值；不能触发自动拆箱
2. boolean 类型的变量、值 == 其他任意类型的变量、值；
3. 包装类之间；
4. 没有继承关系的两个引用类型；
5. 浮点数 == 浮点数：[BigDecimal 类](#BigDecimal 类)

##### equals()

`equals()` 用来比较两个对象（内存中）的内容是否相同，即对象是否相等。

1. 不能用来比较基本数据类型（~~及其包装类？~~）的变量；

2. 对于引用类型：
   - 若没重写 equals() `<==>` equals() 继承自Object类，故每个对象都有 equals()，Object中默认（直接调用 `==`）对比两个对象的地址是否相等；
   - 多数情况下，重写 equals() `==>` 比较对象存储的内容是否相等。如String类、包装类、Date类等；
   
   ```
   Objects.equals(null,"hello"); // 避免空指针异常
   ```

重写 `equals()` 必须重写 `hashCode()`：保证 `equals()` 相同的对象哈希码也相同。否则违背了两个相等的对象必须有相等的哈希码这一Java关键约定，进而影响散列表、hashmap等。

- 因为 Set 存储的是不重复的对象，依据 `hashCode()` 和 `equals()` 进行判断，所以 Set 存储的对象必须覆写这两种方法。
- String 因为覆写了 `hashCode()` 和 `equals()` 方法，所以可以愉快地将 String 对象作为 key 来使用。

`equals()` 和 `hashCode()` 同时存在的意义：一个是保证可靠，一个是保证性能；

- `equals()`：比较的是地址，保证比较对象是否是绝对相等的；
- `hashCode()`：用于获取哈希码（确定该对象在哈希表中的索引位置），通常用来将对象的内存地址转换为整数后返回；
  - 保证在最快的时间内判断两个对象是否相等，可能有误差值；同一对象的 hashcode 一定相等，不同对象的也可能相等；

##### String 变量中的应用

```
String s1 = "ab"; // 将字面量"ab"放到常量池中，并将引用 s1 指向对象；推荐
String s2 = "ab"; // 在常量池查找到"ab"的地址，并赋给s2
s1 == s2? // true，s1和s2地址相同
s1.equal(s2)? // true，比较字符串的内容

String str1 = new String("ab"); // 在堆内存创建一个新对象，a 引用指向新对象
String str2 = new String("ab"); // 在堆内存创建另一个新对象，b 引用指向新对象
str1 == str2? // false，非同一对象
str1.equals(str2)? // true，对象的内容一样

s1 != str1 // s1是常量池中的对象的引用，str1是堆内存中的对象的引用，二者地址不同
s1.equal(str1) // true，内容相同，重写hashCode()

String str3 = str2; // 引用传递，指向堆内存中的同一对象
str3 == str2? // true
str3 == s1? // false
str3.equal(s1) // true
```

### 三类引用数据类型

> reference type

作为方法的参数类型和返回类型

1. 数组
2. 类
3. 接口

#### 数组

##### 用法

1. 声明；只得到一个存放数组的变量，并没有为数组元素分配内存空间；
2. 用 new 关键字分配内存空间；
3. 初始化；
4. 使用。

```
int[] arr = new int[5]; // 声明 + 动态初始化，程序员指定数组的长度，由系统初始化每个元素的默认值，此处 int 默认值为0
int[] num = new int[]{1, 2, 3, 5, 8};  // 一般不用
int[] num = {1,2,3,5,8}; // 声明 + 静态初始化，程序员显式指定每个元素的初始值，由系统决定数组的长度

int n = nums.length; // 数组的属性
int n = str.length(); // String 对象的方法

List<Integer> list = new ArrayList<>();
int n = list.size(); // 泛型集合的方法，vector、List等
```

当指定的下标值超出数组的总长度时，会拋出 ArrayIndexOutOfBoundsException（数组越界异常）。

因为 Java 类与类间支持继承，可能产生一个数组里可存放多种数据类型的假象。如一个水果数组，元素可是苹果或香蕉（都继承了水果），但元素类型还是水果。

##### 数组、List接口、ArrayList类

- 数组：大小固定，查找快
- List：是接口
- ArrayList：是List的实现类，有序，以一定的顺序保存元素。

##### Array 类和 Arrays 工具类

Array 类：提供静态方法，动态创建和访问数组。

```
int[] data = new int[10]; // 没有进行初始化 默认值为0
Array.set(data, 7, 6); // 设置data[7]=6
```

Arrays 类：提供静态方法，对数组进行操作。定义在`java.util`包中，主要实现数组元素的查找，内容填充、排序等。

```
// 以下静态方法均被public static修饰（省略）、均被重载多次，可用于各种类型的数组，如float[]等
List asList(int[] a) 将数组转为集合
List list = Arrays.asList(a);

boolean equals(int[] a, int[] a2) // 判断两个数组是否相等
String toString(int[] a) // 输出数组信息

void fill(int[] a,int val) // 将指定内容填充到数组中
int[] copyOf(int[] a, int n) // 拷贝，不改变参数内容，也可用于扩容
int[] copyOfRange(int[] a, int fromIndex, int toIndex) // 拷贝区间

void sort(int[] a) // 排序
// 必须有序
int binarySearch(int[] a, [int fromIndex, int toIndex,] int key) // 对排序后的数组[fromIndex, toIndex]范围内进行二分检索。返回搜索值的索引；否则返回 -1
```

## 面向对象

### 对象

> Object Oriented

根据 JVM 规范："对象是动态分配的类实例或数组"。实例是内存中的对象。

抽象：指将一类对象的共同特征提取出来构造类，**类是对象（实例）的抽象**。一切皆对象。

```
Student stu1 = new Student("小刘", 22); // 显式创建对象

String str1 = "Hello"; // 隐式创建对象
String str2 = str1 + "Java";

new Person("张三", 30).tell(); // 匿名对象，对象只用一次，在实际开发中大多作参数，区别于单例模式
```

面向对象和面向过程的主要区别在于解决问题的方式不同：

- 面向过程：把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。
- 面向对象：会先抽象出对象，然后用对象执行方法的方式解决问题。一般更易维护、易复用、易扩展。

### this、super 关键字

this 代表当前（类的）对象的引用，指向本对象；super 代表对父类对象的引用，指向父类对象。

1. 在构造器中，this用于区分同名成员变量与局部变量；this 调用本类中的其他构造方法/super() 调用父类中的其他构造方法时，必须处于构造器的首行，否则编译器会报错。
2. 在 static 方法中，this、super不可用。

### 封装

定义：指把对象的属性隐藏在内部，不允许外部对象直接访问，但可提供可被外界访问的方法来操作属性。控制对外隐藏和暴露哪些数据。基本单位是类。POJO 的getter/setter 方法。

### 继承

继承：指子类可使用父类的所有属性和方法。子类 is a 父类。

继承的特点：
1. 子类**拥有**父类所有的属性和方法（包括私有属性和私有方法），但无法访问父类中的私有属性和方法，仅拥有。
   - 子类不能继承父类的构造器；
   - 子类可重写父类的方法；
   - 继承后变量和方法的访问顺序：就近原则；
2. 单继承（不支持多重继承）：程序结构更清晰、便于维护。多重继承会使类型转换、构造方法的调用顺序变复杂，影响性能。
   - 若支持多重继承：类 C 继承自类 A 和类 B，如果类 A 和 B 都有自定义的成员方法 f()，则调用类 C.f() 会产生二义性；
   - 通过实现多个接口间接支持多重继承：接口由于只包含方法定义，不能有方法的实现，类C不能直接调用方法，需实现具体的f()才能调用，不会产生二义性。
3. 对于父类的包访问权限、成员变量/方法，如果子类和父类在同一个包下，则子类能继承，否则子类不能继承；

`super` 主要用法：

1. `super.成员变量/方法`：用于在子类中调用父类的同名成员变量或方法；
2. `super(param1, ...)`：用于在子类构造器（的第一行显式地）调用父类构造器；
   - 若父类有无参构造器，系统会自动调用 `super()`；
   - 若父类的构造器都带参，则必须用 `super(param1, ...)`显式调用一次。
### 方法重载 VS 重写

- 重载（overload）：同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理；
- 重写/覆盖、覆写（override）：子类**继承**父类已有的方法，并重新实现其内部逻辑、功能。遵循两同两小一大。

区别：

0. 方法名都相同。
1. 发生范围：重载在同一个类；重写在子类中。
2. 参数列表（类型、个数、顺序） ：重载至少一个不同；重写一定相同。
3. 返回值类型、异常：重载可不同（只有返回值不同不算重载）；重写子类的返回值类型、异常范围（`RunTimeException`）<=父类（`Exception`）。
4. 访问修饰符：重载可不同；对重写，子类访问权限（`public，而非private`）>=父类（`protected`），即子类修饰符不能做更严格的限制->父类方法修饰符为 `private/final/static`或构造器（都不能被继承）则子类不能重写，但被 static 修饰的方法能被再次声明。
5. 发生阶段：重载实现的是**编译时**的多态性（即前绑定）；重写实现的是**运行时**的多态性（即后绑定）。

### 多态

多态：即**一个接口，多个方法**。指多个子类继承并重写父类的同一属性或方法，或多个子类实现接口并覆盖接口中的同一方法，并将父类引用指向子类对象。

```
// 引用的自动类型转换，指存在继承关系的对象类型转换
Animal animal = new Dog(); // 向上转型，把Dog类型转换为Animal类型
animal.run();

// 引用的强制类型转换，编译正常，运行可能报错ClassCastException类型转换异常，建议在强转前判断对象的真实类型
Dog dog = (Dog) animal; // 向下转型，把Animal类型转换为Dog类型
animal.run();

Animal animal = new Cat();
if (animal instanceof Cat) {
    Cat cat = (Cat) animal; // 向下转型
}
```

实现多态有 3 个必要条件：
1. 子类继承父类/实现接口；
2. 方法重写；
3. 父类引用指向子类对象（向上转型）或接口的引用变量指向其实现类的实例对象。

分类：
1. 编译时多态：是静态的，主要指**方法重载**。编译后变成不同的方法；
2. 运行时多态：是动态的，即通常所说的多态性，指继承父类和实现接口时，可用父类引用指向子类对象。引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；

特征：
1. 对于方法的调用：编译看左边，运行看右边？
   1. 如果子类重写了父类方法，真正执行的是子类覆盖的方法；
   2. 如果子类没有覆盖父类的方法，执行的是父类的方法。
2. 对于变量：编译、运行都看左边；

优势：
1. 父类作为方法的形参（入参）用来传递对象；
2. 便于类与类间解耦，右边对象可组件化切换，改换业务。

劣势：
1. 编译看左边，不能调子类独有的方法。

### 值传递 VS 引用传递

Java中没有指针的概念，类似的是引用。

Java 中方法参数的传递方式是**值传递**，对引用类型的参数采用的也是值传递，不过，这个值是实参的地址：

1. 值传递：Java方法接收（传递）的是实参值的拷贝，会创建副本；方法对拷贝副本的修改不会影响实参值。
  1. 参数是基本类型时：传递的是基本类型的字面量值的拷贝，会创建副本；
  2. 参数是引用类型时：传递的是实参（所引用对象在堆中）地址值的拷贝，同样也会创建副本；

    - 方法可修改引用指向对象的状态，但这仍是按值调用而非引用调用。
2. 引用传递、拷贝 ：方法接收的直接是实参所引用的对象（在堆中）的地址，不会创建副本，修改形参将影响实参。

<img src="assets/java-value-passing-03.jpg" alt="引用数据类型参数2" style="zoom:60%;" />

```
public class Person {
    private String name;
   // 省略构造函数、Getter&Setter方法
}

public static void main(String[] args) {
    Person xiaoZhang = new Person("小张");
    Person xiaoLi = new Person("小李");
    swap(xiaoZhang, xiaoLi);
    System.out.println("xiaoZhang:" + xiaoZhang.getName());
    System.out.println("xiaoLi:" + xiaoLi.getName());
}

public static void swap(Person person1, Person person2) {
    Person temp = person1;
    person1 = person2;
    person2 = temp;
}

// 打印结果
xiaoZhang:小张
xiaoLi:小李
```

### 深拷贝 vs 浅拷贝

Java中有三种类型的对象拷贝：将一个对象的属性拷贝到另一个有着相同类型的对象中去。

<img src="assets/shallow&amp;deep-copy.jpg" alt="浅拷贝、深拷贝、引用拷贝示意图" style="zoom:80%;" />

- 浅拷贝（Shallow Copy）：在堆上创建一个新的对象（区别于引用拷贝的一点）；拷贝基本数据类型变量（进行值传递）；复制引用但不复制引用指向的对象本身（即对引用数据类型，进行引用传递般的拷贝）。即拷贝对象和原对象共用同一个内部对象。

  - 在当前类中实现Clonable接口并重写Object类的`protected clone()`，在方法内直接调用父类的`clone()`方法，即`return super.clone()`。

    <img src="assets/shallow_copy.png" alt="image" style="zoom: 90%;" /><img src="assets/shallow_copy_string.png" style="zoom: 60%;" />

  ```
  Class Son implements Cloneable {
  	String name;
  	Father father;
  	....
  	@Override
  	protected Son clone() throws CloneNotSupportedException {
  		return super.clone();
  	}
  }
  	Father f = new Father("bigFather");
      Son s1 = new Son("son1", 13);
      s1.father = f;
      Son s2 = s1.clone();
      s1 == s2? // false，二者地址不同
      s1.father == s2.father? // true，二者内的father对象地址相同，为同一个father
      
      s1.name == s2.name? // true
      s1.name = "son222"; // 改变s1.name指向的String对象
      s1.name == s2.name? // false
  ```

- 深拷贝（Deep Copy）：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。（对基本数据类型进行值传递，对引用数据类型，创建一个新对象并复制（new）其内的成员变量。）比浅拷贝速度慢且花销大。

  - 通过序列化来实现深拷贝：适用于引用数量或层数太多时，原对象写入文件后拷贝给clone对象，原对象的修改不会影响clone对象，因为clone对象是从这个媒介读取。
  - 在当前类中实现Cloneable接口并重写`clone()`，在方法内new一个当前类的新对象，即`return new Student(name, subj.getName()); `。

  ```
  // Father clone()方法
  @Override
  protected Father clone() throws CloneNotSupportedException {
      return (Father) super.clone();
  }
  // Son clone()方法
  
  @Override
  protected Son clone() throws CloneNotSupportedException {
      Son son = (Son) super.clone(); // 待返回克隆的对象
      son.name = new String(name);
      son.father = father.clone();
      return son;
  }
  
  // 地址均不同，均返回false
  ```

<img src="assets/deep_copy_1.png" alt="" style="zoom:90%;" />

- 延迟拷贝（Lazy Copy）：二者组合

### 接口

`implements` 实现类；接口（interface）是用来被实现的，没有构造器。

- 类与类单继承；
- 类与接口的多实现；
- 接口与接口的多继承。

`JDK1.8` 前接口中只有：

1. 默认为抽象方法 public abstract；
2. 常量。

`JDK1.8` 后新增三个方法：

1. 默认方法：用 default 修饰，即实例方法；
2. 静态方法：只能用接口名本身调用，不能用子接口/实现类调用；
3. 私有方法：被私有方法/默认方法调用，只能在本接口中访问。

##### 抽象类

抽象方法：只有声明，没有具体的实现。

抽象类（abstract class）：包含抽象方法的类，不能用来创建对象。

- 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。
- 类继承抽象类或实现接口，要实现所有抽象方法，否则仍需被声明为抽象类。

抽象类的意义（代码复用）：

1. 为了被子类单继承；
2. 模板设计模式（部分实现，部分抽象）。

##### 抽象类 VS 接口

同：

1. 都不能直接例化，（但可定义抽象类和接口类型的引用）；（接口的实现类或抽象类的子类）需实现相应的方法后才能被例化。
2. 都可包含抽象方法。
3. 都可有默认实现的方法（Java 8 可用 `default` 关键字在接口中定义默认方法）。

异：

1. 一个类只能**继承（extends）**一个抽象**类**；但可**实现（implements）**多个接口。抽象类被设计用来被继承的（用于代码复用），接口被设计用来实现的。
2. 接口比抽象类更抽象：抽象类可有静态方法、静态代码块、**构造器**；接口中 JDK1.8后可有静态方法，没有构造器。
3. 抽象类可定义**成员变量**，默认 default，可在子类中被重新定义，也可被重新赋值；接口中的成员变量只能用 `public static finial` 修饰（JDK1.8 后默认为default），实际是常量，不能被修改且必须有初始值。
4. 抽象类可有（普通成员）**方法的具体实现**；接口（只有public abstract方法定义，）不能有方法的具体实现。
5. 抽象类中的方法可用`private, protected, public`**修饰**；接口只能用`public`。

### 内部类

1. 静态内部类：作为外部类的静态成员。public static，只加载一次，寄生和宿主的关系；只能访问外部类的静态成员。
2. 成员内部类（实例内部类）：作为成员对象的内部类。可访问（private及以上）外部类的属性和方法。外部类想访问内部类属性或方法时，必须通过创建的内部类对象访问。外部类也可访问内部类属性。**实例内部类对象属于外部对象，是外部对象实例化的成员变量**；没有静态区，不能定义静态成员，能定义常量；`Outter.Inner o = new Outter().new Inner();`能访问外部类的静态成员和实例成员。
3. 局部内部类：几乎不用。方法中的内部类。只能定义实例成员，不能定义静态成员。访问权限类似局部变量，只能访问外部类的final变量。
4. **匿名内部类**：没有类名的局部内部类，只能用一次，只能访问外部类的final变量。new子类时重写父类的抽象方法可省略子类定义，立即返回匿名内部类对象；用于对象回调、创建接口对象来简化代码。

### 可变长参数

- 可变参数只能作为函数的最后一个参数。

- 方法重载会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。

```
public static void method2(String arg1, String... args) {
   // ....
}
```



## 异常

[Java异常（Exception）处理及常见异常](http://c.biancheng.net/view/6635.html)

### 异常分类

<img src="assets/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图" style="zoom:70%;" />

顶级父类 `java.lang.Throwable`：将异常层层抛给顶层，统一处理。

- `Error`：程序无法处理的错误，无法通过 catch 捕获，只能尽量避免。发生时 JVM 一般会终止线程。
  - `Java Virtual Machine Error`：JVM 运行错误；
  - `OutOfMemoryError（OOM）`
  - `StackOverFlowError`
  - `NoClassDefFoundError`：类定义错误；
  - `AssertionError`
  - `IOError`
- `Exception`：程序本身可处理的异常，可通过 try-catch 捕获。
  - `checked exception`（（编译时）受检查异常）：代码还没运行，编译器就会检查，并要求必须处理的异常；如果不处理，程序就不能编译通过。除了`RuntimeException`及其子类以外都是 `checked exception`。必须要对这段代码 `try...catch`，或 `throws exception`。
    1. `IOException`
    2. `ClassNotFoundException`
    3. `SQLException`
    4. `InterruptedException`：线程被另一个线程中断；
    5. `IllegalAccessException`：访问类被拒绝；
    6. `NoSuchMethodException`：通过反射机制调用的方法不存在；
    7. 及用户自定义的 Exception 异常。
  - `unchecked exceptions`（不受检查异常）：即使不处理也可正常通过编译。包括`RunTimeException` （运行时异常）及其子类；日常开发中经常用到；
    1. `NullPointerException（NPE）`：需进行 NPE 检查，使用 JDK8 的 Optional 类来防止 NPE 问题。可能出现 NPE 的有：
       1. 级联（链式）调用 `obj.getA().getB().getC()` 一连串调用；
       2. 远程调用返回对象时；
          - 数据库的查询结果可能为 null；
          - 对于 Session 中获取的数据；
       3. 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null；
       4. 返回类型为基本数据类型，return 的包装类为 null，自动拆箱将抛出 NPE，`public int method() { return Integer 对象; }`。
     2. `ArrayIndexOutOfBoundsException`：数组下标越界；
     3. `ArrayStoreException`：向类型不兼容的数组元素赋值；
     4. `ClassCastException`：类型转换异常；
     5. `NumberFormateException`：字符串转为数字时格式错误；
     6. `ArithmeticException`：算数错误；
     7. `SecurityException` ：安全错误，如权限不够；
    8. `UnsupportedOperationException`：不支持的操作错误，如重复创建同一用户；
    9. `RejectedExecutionException`：线程池拒绝策略；

### Throwable 类的常用方法

- `void printStackTrace()`：在控制台上打印 `Throwable` 对象封装的异常信息；
- `String getMessage()`：返回异常发生时的简要描述；
  - `String getLocalizedMessage()`：默认返回`getMessage()`；若用 `Throwable` 的子类覆盖此方法，返回异常对象的本地化信息。
- `String toString()`：返回异常发生时的详细信息；

### try-catch-finally

1. `try` 块： 用于捕获异常。其后可接多个 `catch` 块；如果没有 `catch` 块，则必须跟一个 `finally` 块。
2. `catch` 块 ：用于处理 try 捕获到的异常。
   - JVM 在方法栈中查找能处理该类型异常的对象。捕捉异常并处理的代价远大于直接抛出。
3. `throw` 块：一般用在方法内部（出现异常的地方），由开发者定义，当程序语句出现问题后，创建异常对象并（立即主动）抛出异常（提交给 JVM）。
   - `throws`：一般用在方法声明上，代表可能会抛出的异常列表。
4. `finially` 块：无论是否捕获或处理异常，语句最终一定执行；当在 `try` 块或 `catch` 块中遇到 `return` 语句时，在方法返回前执行。常用于回收、释放资源。
   - 以下情况不会执行 `finially` 块，而是直接结束：

     1. 当程序在进入try语句块前就出现异常时；finally 前 JVM 被终止运行；
     2. 当程序在try块中强制退出时，如用 `System.exit(0)`；
     3. 程序所在的线程死亡；
     4. 关闭 CPU；
   - 其它情况下，try 块先执行，
     1. 当有异常发生，catch 和 finally 进行处理后程序就结束了；
     2. 当没有异常发生，在执行完 finally 中的代码后，后面代码会继续执行。
   - 不要在 finally 语句块中使用 `return`：当 try 语句和 finally 语句中都有 return 语句时，finally 块中的 return 语句会覆盖 try/catch 中的。

```
try {
    System.out.println("Try to do something");
    throw new RuntimeException("RuntimeException");
} catch (Exception e) {
    System.out.println("Catch Exception -> " + e.getMessage());
} finally {
    System.out.println("Finally");
}

输出：
Try to do something
Catch Exception -> RuntimeException
Finally

try{
} catch (FileNotFoundException e) {
    // 打印异常堆栈
    e.printStackTrace();
} catch (Exception e) {
    e.printStackTrace();
}
```

### try-with-resources

Java 7 之后，面对必须要关闭的资源，应优先使用 `try-with-resources` 而不是`try-finally`。代码更简短、清晰，产生的异常对也更有用。

- 类似于`InputStream`、`OutputStream` 、`Scanner` 、`PrintWriter`等资源调用`close()`方法来手动关闭。

```
try (Scanner scanner = new Scanner(new File("test.txt"))) {
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException fnfe) {
    fnfe.printStackTrace();
}
```

## 泛型

泛型（Generics）参数：即参数化类型：<数据类型>。编译器可对泛型参数进行检测，通过泛型参数指定传入的对象类型。只是一个占位符，必须在传递类型后才能使用。常用 `E，T，K，V，?（通配符）`表示，用于对象具体类型不确定的情况。

1. 自定义接口通用返回结果 `CommonResult<T>` 通过参数 `T` 可根据具体的返回类型动态指定结果的数据类型；
2. 定义 `Excel` 处理类 `ExcelUtil<T>` 用于动态指定 `Excel` 导出的数据类型；
3. 构建集合工具类（参考 `Collections` 中的 `sort`, `binarySearch` 方法）。

泛型没有继承关系：虽然 BMW 和 BENZ 都继承了 Car，但 `ArraryList<BMW>` 和`ArraryList<BENZ> ` 与 `ArraryList<Car>`无关。

##### 使用方式

3种使用方式：

1. 泛型类：实现泛型类时在传入真实数据类型；
2. 泛型接口：
   1. 实现泛型接口，不指定类型；
   2. 实现泛型接口，指定类型；
3. 泛型方法；

```
// 泛型接口
public interface Generator<E> {
	public T method();
}

// 泛型的上下限：
// 泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add 方法；
// 而<? super T>不能使用 get() 方法，两者在接口调用赋值时易出错。
public static void run(ArrayList<? extends Car>) {
}
public static void run(ArrayList<? super Car>) {
}
```

## 反射机制

##### 反射

反射：将（类/接口的）`.class 字节码文件`加载进 JVM （的方法区）时，会（在堆中）创建一个对应的`java.lang.Class 对象`，用来映射类中的各种成分。用于在**运行期/时**获取**Class 类对象**及其类内部详细信息（成员方法、属性、构造函数等）、及**反向控制**实例对象的能力。

- 通过Class实例获取`class`信息的方法称为反射。
- 这种动态获取类信息及调用对象方法的功能称为Java语言的**反射机制**。

<img src="assets/java-basic-reflection-3.png" alt="img" style="zoom:65%;" />

##### 应用场景

多用于框架的底层原理，是框架的灵魂。通过反射可在运行时分析类及执行类中方法；获取、调用任意一个类的所有属性和方法。

1. Spring/Spring Boot、MyBatis 等框架中都大量使用反射机制，框架中**动态代理**的实现也依赖反射；
  - 动态代理机制：JDK提供的（如`Proxy.newProxyInstance()`）没有实现类、但在运行期动态创建接口对象的方式。通过`Proxy`创建代理对象，然后将接口方法“代理”给`InvocationHandler`完成的。
2. 注解的实现用到反射。Spring 中通过 `@Component`注解声明一个类为 Spring Bean、 通过 `@Value `注解就读取到配置文件中的值：基于反射分析类，获取到类/属性/方法/参数上的注解，之后就可做进一步的处理。
3. `toString()`里重写并打印类信息。

##### 优缺点

优点 ：代码更灵活；为各种框架提供开箱即用的功能提供便利；

缺点 ：不安全。如，可无视（发生在编译时的）泛型参数的安全检查；性能稍差。

##### 获取 Class 类对象

获取Class对象的方式有：

1. （一般不知道具体类），知道具体类的情况下：`类名.class`。Class 对象不会进行初始化（不执行静态代码块和静态对象）；

2. `实例对象.getClass()`，继承自 `Object.getClass()`；

3. `Class.forName("类的全限定名")`；

4. ~~通过类加载器`xxxClassLoader.loadClass(类路径？)`。Class 对象不会进行初始化。~~

   ```
   ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.User");
   ```

##### 反射的使用/基本操作

可通过以下类调用反射API（[JavaGuide 反射的一些基本操作](https://javaguide.cn/java/basis/reflection.html#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C)）：

1. `Class` 类：可获得（Class 对象所表示的）类的属性、方法，是一个 Java 中的泛型类型。用于封装被加载到 JVM 中的类和接口的信息。Class类常用方法有：
  - `Class<?> getClass()`：获取类引用
  - getSimpleName()：获取类名
  - `getName()`：获取全限定类名
  - `newInstance()`：实例化
  - getPackage()
  - `Class getSuperclass()`：获取父类类型；
  - Class[] getInterfaces()：获取当前类实现的所有接口。
  - Constructor<?>[] getConstructors()
  - `Fileds[] getFileds()`
  - `Field getField(String name)`：获取公有字段；
  - `getDeclaredFields`：用于获取所有声明的字段，包括公有和私有字段；
  - Method[] getMethods()
  - Method getMethod(String name, Class<?>... parameterTypes)
2. `Construct` 类：获取（Class对象所表示的）类的构造方法，可在运行时动态创建对象。
3. `Field` 类：获取（Class对象所表示的）类的成员变量，及对它的（运行时）动态修改权限（包含private）。
  - `setAccessible(true)`：为了调用 private 方法而取消安全检查；
  - `getName()`：返回字段名称，如`"id"`；
  - `getType()`：返回字段类型，也是一个`Class`实例，如，`String.class`；
  - `getModifiers()`：返回字段的修饰符，是一个`int`，不同的bit表示不同的含义。
4. `Method` 类：获取（Class对象所表示的）类的成员方法，可动态调用对象的方法（包含private）。
  - `Object invoke(Object obj, Object... args)`：JVM 调用包装在当前 Method 对象obj 中的方法，并传入方法调用的参数 args。调用静态方法时传入的第一个参数为`null`；
  - `getName()`：返回方法名称，如：`"getScore"`；
  - `getReturnType()`：返回方法返回值类型，也是一个Class实例，如：`String.class`；
  - `getParameterTypes()`：返回方法的参数类型，是一个Class数组，如：`{String.class, int.class}`；
  - `getModifiers()`：返回方法的修饰符，是一个`int`，不同的bit表示不同的含义。

```
/**
 * 建立和插入关系表操作
 *
 * @param dao       可以操作的dao
 * @param dataList  要插入的数据
 * @param productId 建立关系的id
 */
private void relateAndInsertList(Object dao, List dataList, Long productId) {
    try {
        if (CollectionUtils.isEmpty(dataList)) return;
        for (Object item : dataList) {
            Method setId = item.getClass().getMethod("setId", Long.class);
            setId.invoke(item, (Long) null);
        }
        Method insertList = dao.getClass().getMethod("insertList", List.class);
        insertList.invoke(dao, dataList);
        
        /**
         * 获取指定参数，并对参数进行修改
         */
        Class<?> targetClass = Class.forName("cn.javaguide.User");
        Field field = targetClass.getDeclaredField("value");
        // 为了对类中的参数进行修改，取消安全检查
        field.setAccessible(true);
        field.set(targetObject, "JavaGuide");
    } catch (Exception e) {
        LOGGER.warn("创建产品出错:{}", e.getMessage());
        throw new RuntimeException(e.getMessage());
    }
}
```

##### 反射机制执行流程及原理

- 反射是线程安全的；
- 反射用软引用 relectionData 缓存 class 信息，避免每次重新从 JVM 获取带来的开销；
- 当找到需要的方法，会copy一份，而不是用原来的实例，从而保证数据隔离；
- 调度反射方法，最终是由 JVM 执行 `invoke0()` 执行；

## 注解

`Annotation` （注解）：是 Java5 开始引入的新特性，可看作是一种特殊的注释，本质是一个继承了`Annotation` 特殊接口；主要用于修饰类、方法、变量，提供某些信息供程序在编译或运行时使用。

##### 注解解析方法

注解只有被解析后才会生效，常见的解析方法有两种：

1. 编译期直接扫描 ：编译器在编译 Java 代码时扫描对应的注解并处理，如 `@Override` 注解，编译器在编译时就会检测当前的方法是否重写了父类对应的方法。
2. 运行期通过反射处理 ：框架中自带的注解（如 Spring 框架的 `@Value` 、`@Component`）。

##### 注解分类

JDK 内置注解：

1. 由编译器使用的注解，作用在代码上。如：

   - `@Override`：检查该方法是否正确实现了覆写；
   - `@Deprecated`：标记过时（已弃用）方法。如果使用该方法，会报编译警告；
   - `@SuppressWarnings`：告诉编译器忽略此处代码产生的警告；

2. 元注解：作用在其他注解上的注解，用于定义其它注解（ `@interface` 类型的类）。

   1. `@Target`：标记注解作用在哪种成员上：

      ```
      /** Class, interface (including annotation type), or enum declaration */
      TYPE,
      FIELD, METHOD, PARAMETER,
      CONSTRUCTOR,
      LOCAL_VARIABLE,
      ANNOTATION_TYPE,
      PACKAGE,
      // since 1.8
      TYPE_PARAMETER,
      TYPE_USE
      ```

   2. `@Retention(RetentionPolicy.SOURCE)`：标识注解怎么保存：

      - `SOURCE`：只在源代码中；
      - `CLASS`：编入class文件中；
      - `RUNTIME`：在运行时可通过反射访问。

   3. `@Documented`：标记注解是否包含在用户文档中。

   4. `@Inherited`：标记注解继承于哪个类（默认没有继承于任何父类）。

   ```
   @Target({ElementType.FIELD, ElementType.TYPE})
   @Retention(RetentionPolicy.SOURCE)
   public @interface Setter {
   }
   ```

3. 从 Java 7 开始，额外添加了 3 个注解：

   1. `@SafeVarargs`： 忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。
   2. `@FunctionalInterface`：Java 8 开始支持，标识匿名函数或函数式接口。
   3. `@Repeatable`：Java 8 开始支持，标识注解可在同一个声明上使用多次。

4. 在程序运行期能读取的注解。在加载后一直存在于JVM中，最常用。如：

   - `@PostConstruct`标注的方法会在调用构造方法后自动被调用（这是 Java 代码读取该注解实现的功能，JVM 并不会识别该注解）。

## I/O 和 序列化

### 序列化

定义

- 序列化： 将对象（包括对象的类型信息、存储在对象中的数据及其类型）转换成二进制字节流的过程；
- 反序列化：在内存中新建对象。如果 JVM 在反序列化时找不到该类，则抛出一个 `ClassNotFoundException`。

目的：持久化 Java 对象，将对象存储到文件系统、数据库、内存中，或通过网络传输对象；

整个过程都是 JVM 独立的，即，在一个平台上序列化的对象可在另一个完全不同的平台上反序列化该对象。

序列化和反序列化对应 OSI 七层协议模型中的表示层：主要就是对应用层的用户数据进行处理转换为二进制流。属于 TCP/IP 四层模型中应用层的一部分。

##### 具体实现

常见序列化协议：

- 文本类序列化：可读性较好，但性能较差，一般不会选择；
  - JSON
  - XML

- 基于二进制的序列化协议：
  1. JDK 自带的序列化，只需实现 `java.io.Serializable`接口即可。几乎不直接用此方式，主要原因有两个：
     1. 不支持跨语言调用；
     2. 相比于其他序列化框架性能更差，序列化后的字节数组体积较大，导致传输成本加大。
  2. Kryo：推荐；
  3. Protobuf
  4. hessian

JDK 自带序列化的实现：

- 用于序列化和反序列化的类必须实现 `Serializable` 接口；是 `java.io` 包中定义的、用于实现 Java 类的序列化操作而提供的一个**语义级别**的接口。没有任何方法或字段，只是用于标识可序列化的语义。

  - 对象中如果有属性不想被序列化，使用 `transient` 修饰。

  - 实现了 Serializable接口的类可被 ObjectOutputStream 转换为字节流，同时也可通过 ObjectInputStream 再将其解析为对象。

- 显式地定义 `serialVersionUID`：在反序列化时，JVM会把传来的字节流中的serialVersionUID 与本地相应实体（类）的 serialVersionUID 进行比较，如果相同就认为是同一个类。

  - 序列化类新增属性时，不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，需修改。

  ```
  private static final long serialVersionUID = 1L; 
  ```

##### 常见应用场景

1. 将内存中的对象存储到文件中时需进行序列化，将对象从文件中读取出来需进行反序列化。比较常见，如用 Mybatis 框架编写持久层 insert 对象数据到数据库中时；
2. 将对象存储到缓存数据库（如 Redis）时需用到序列化，将对象从缓存数据库中读取出来需反序列化；
3. 对象在进行网络传输（如远程方法调用 RPC ）之前需先被序列化，接收到序列化的对象之后进行反序列化；网络通信用 Socket 套接字在网络中传送对象时，如用 RPC 协议进行网络通信时；

##### trasient 关键字

作用：阻止实例中用 `trasient` 修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

1. 只能修饰变量，不能修饰类和方法；
2. 修饰的成员变量不能被序列化（修饰的对象需实现 Serializable 接口），在反序列化后变量值将会被置成默认值。；
3. 静态变量不管是否被 transient 修饰，均不能被序列化（如果反序列化后类中 static 变量还有值，则为当前 JVM 中对应 static 变量的值）。
   - 序列化保存的是对象状态，静态变量保存的是类状态，不属于任何对象，因此静态变量不能被序列化。

### Java I/O 流

IO 即 `Input/Output`，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。

IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。Java IO 流的  4 个抽象类基类：

1. `InputStream`（字节输入流）：用于从源头（通常是文件）读取数据（字节信息）到内存中；
   - `read()` 方法：返回输入流中下一个字节的数据。
   
   - `FileInputStream`：是一个常用的字节输入流对象，可直接指定文件路径，直接读取单字节数据，也可读取至字节数组中。通常会配合 `BufferedInputStream`。
   
   - `BufferedInputStream`（字节缓冲输入流）：不是一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。大幅减少了 IO 次数，提高了读取效率。
   
     `BufferedInputStream` 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 `BufferedInputStream` 源码即可得到这个结论。
2. `Reader`（字符输入流）：
   
   - `BufferedReader` （字符缓冲输入流）
3. `OutputStream`（字节输出流）
   
   - `BufferedOutputStream`（字节缓冲输出流）：缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。
4. `Writer`（字符输出流）：
   
   - `BufferedWriter`（字符缓冲输出流）

##### Stream 流

ObjectInputStream 和 ObjectOutputStream 类

- public final Object readObject() throws IOException 方法：序列化一个对象，并发送到输出流；
- public final Object readObject() throws IOException,  ClassNotFoundException 方法：从流中取出下一个对象，并反序列化。返回值为Object，因此需转成合适的数据类型。

```java
Employee e = new Employee();
e.name = "Reyan Ali";
FileOutputStream fileOut = new FileOutputStream("/tmp/employee.ser");
ObjectOutputStream out = new ObjectOutputStream(fileOut);
out.writeObject(e);
out.close();
fileOut.close();

FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");
ObjectInputStream in = new ObjectInputStream(fileIn);
e = (Employee) in.readObject();
....
```

### Java I/O 中的设计模式

装饰器

适配器

工厂模式

观察者模式

### I/O 模型

<img src="assets/冯诺依曼体系结构.jpeg" alt="冯诺依曼体系结构" style="zoom: 18%;" />

日常开发过程中接触最多的就是 磁盘 IO（读写文件） 和 网络 IO（网络请求和响应）。

I/O 模型：

1. 同步阻塞 I/O：应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。
   - BIO (Blocking I/O)
2. 同步非阻塞 I/O
3. I/O 多路复用
   - NIO (Non-blocking/New I/O)：支持面向缓冲，基于通道的 I/O 操作方法。 用于高负载、高并发的（网络）应用；
4. 信号驱动 I/O 
5. 异步 I/O
   - AIO (Asynchronous I/O)

## Socket 网络编程

> 暂无

## JDK1.8 新特性

##### Interface

- interface 中的方法可用`default` 或 `static`修饰，这样就可有方法体，实现类也不必重写此方法。

##### Lambda 表达式

用于：

- 简化、替代（函数式接口的）匿名内部类写法；
- 集合迭代；
- 方法的引用；
- 访问变量；

语法格式

```
(parameters) -> expression 或
(parameters) ->{ statements; }
```

##### Stream

新增了 `java.util.stream` 包

##### Optional

用于解决 NPE 问题

##### Date-Time API

- 格式化；
- Java 8 前转换都需借助 `SimpleDateFormat` 类，而**Java 8 后**只需 `LocalDate`、`LocalTime`、`LocalDateTime`的 `of` 或 `parse` 方法；
- 之前都对应 `Date`；现在JDBC时间类型和 Java8 时间类型对应关系是：
  1. `Date` ---> `LocalDate`；
  2. `Time` ---> `LocalTime`；
  3. `Timestamp` ---> `LocalDateTime`。
- 引入 `java.time.ZonedDateTime `来表示带时区的时间，可看成是 `LocalDateTime + ZoneId`。

## 常用类

### Collections 类

```
int min = (int) Collections.min(Arrays.asList(numbers));
```

### Object 类

> 类中的方法及作用

如果定义类时并未显式指定父类，则默认继承 `java.lang.Object` 类

- `toString()`：默认返回类（带包的）全名`@`当前对象在堆内存的地址（类的名字实例的哈希码的 16 进制的字符串），通常重写来返回对象的内容；如`"org.webtree.www.User@Hello"`。

- `equals()`：默认比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。

```
// 方法一：
@Override
public boolean equals(Object obj) {
    if (obj instanceof Student) {
    	Student stu = (Student)obj;
      	return this.name.equals(stu.name); // this.name 无判空
    } else {
      	return false;
    }
}
// 方法二：IDEA自动生成
```

-  `clone()`：用于创建并返回当前对象的一份拷贝。慎用，默认是[浅拷贝](#深拷贝 vs 浅拷贝)，若想实现深拷贝需覆写 clone() 方法实现成员对象的深度遍历式拷贝。
- `finalize()`：实例被垃圾回收器回收时触发的操作；当GC准备好释放对象占用空间时，首先会调用finalize()，并在下一次垃圾回收动作发生时真正回收对象占用的内存。

```
// native 方法
// 用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
public final native Class<?> getClass()
// 用于返回对象的哈希码，主要使用在哈希表中，如 JDK 中的HashMap。
public native int hashCode()
```


### Objects 类

```
Objects.equals(o1, o2); // 推荐使用
```

### String 类

~~String类有11种构造方法：~~ 

##### String 类

String 用 [private finial](final 关键字) 修饰的字符数组保存，每次都创建新对象（多了会导致性能降低）。一旦创建，其值不可改变，适用于**不常改变长度**的字符串，`str.length()`；

   - [String 是 final 类，不可变](https://xmmarlowe.github.io/2021/09/10/Java/Java-String%E7%B1%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8final%E4%BF%AE%E9%A5%B0%EF%BC%9F/)；原因：

   ```
    private [final] char value[]

    // 通过反射修改String中的字符
    String s = “Hello World”; 
    // 获取String类中的value字段
    Field val = String.class.getDeclaredField("value");
    // 改变value属性的访问权限
    val.setAccessible(true);
    // 获取s对象上的属性value数组
    char[] value = (char[]) val.get(s);
    // 改变value所引用的数组中的第5个字符
    value[5] = ‘_’; // 变为 Hello_World
   ```

   - `final`：表示 char 数组的引用地址不可变；
   - `private`修饰符：表示值不会被外部修改。其实可通过反射机制改变值。
   - 二者配合保证用 String 类声明的对象的值不可变。
   - 好处：

     1. 使 JVM 可实现**字符串常量池**：复制 String 变量、new 同一字面量、不同的字符串变量指向相同的字面量，都是指向字符串常量池中（同一内存地址的）同一对象。
        - 可重复使用字符串常量，避免每次都重新创建相同对象，节省内存。
        - 不影响引用该对象的其他变量；如果字符串是可变的，当某个变量改变了该内存的值时，其他指向该内存地址的变量的值也会改变，不符合常量池设计的初衷。

      2. 保证了字符串对象在**多线程**环境下是**线程安全**的。常用字符串来传递数据，如数据库的用户名密码、网络编程中的 IP 和端口。因为字符串是不可变的，故其值不能被修改；如果可变，则可通过改变引用地址指向的值去修改字符串的值，从而导致安全漏洞。
      3. 内存地址不变，**hashcode** 由内存地址间接得到，保证了 hashcode 的唯一性：创建 String 时 hashcode 就被缓存了，不必每次重新计算，处理速度快，很适合作为 Map 的键。
   - 缺点：每次修改 String 对象都会产生新对象，占用内存。如 String 对象的 `+` 操作直接生成新常量，并把 String 对象引用指向新常量。
        - Java 语言本身并不支持运算符重载，`+` 和 `+=` 是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。
- `String.intern()` 是一个 native（本地）方法，作用是将指定的字符串对象的引用保存在字符串常量池中，可简单分为两种情况：
  1. 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。
  2. 如果字符串常量池中没有保存对应的字符串对象的引用，就在常量池中创建一个指向该字符串对象的引用并返回。

##### 字符数组、StringBuilder、StringBuffer

1. 字符数组；

   ```
   // 用字符数组构造字符串对象
   char[] strArr = { 'H', 'e', 'l', 'l', 'o' };
   String s = new String(strArr);
   ```

StringBuilder、StringBuffer 都是对**原对象**操作，都用无 final 修饰的字符数组保存。对象创建后，仍可修改值。

2. `StringBuilder`：性能最好，非线程安全，适用于**单线程**在字符串缓冲区中操作大量数据。重载 `toString()` ，在调用该类对象时自动返回一个字符串，用 `System.out.println(对象名)`可打印出来。

   - `String` 对象通过 `“+”` 拼接，实际上是通过创建 `StringBuilder` 调用 `append()` 方法实现的，最后调用 `toString()` 得到一个 `String` 对象 。
   - 在循环内用 `“+”` 拼接 `String` 对象，会导致创建过多的 `StringBuilder` 临时对象，造成内存资源浪费。可直接使用`StringBuilder` 调用 `append()` 方法代替。

   ```
   // 转为StringBuilder对象
   String str = "num is:";
   // 1. 通过强制类型转换
   StringBuilder strBuilder = (StringBuilder)str;
   // 2. 通过构造函数
   StringBuilder strBuilder = new StringBuilder(str);
   
   for (int i = 0; i < 1000; i++) {
       strBuilder.append(','); // 用`+`会产生大量临时StringBuilder对象
       strBuilder.append(i);
   }
   return strBuilder.toString();
   ```

3. `StringBuffer`：是`StringBuilder`的线程安全版本，很少用，适用于**多线程**在字符串缓冲区中操作大量数据。方法都是 `synchronized` 修饰的，用于多线程使用共享变量的情景。

- [Java String 类](https://www.runoob.com/java/java-string.html)
- [String字符串常用函数](https://blog.csdn.net/CSDN2497242041/article/details/106814072)

##### 获取

- `int length() `：字符数
- `char charAt(int index)`：返回指定索引处的 `char`；
  
  - 当访问不存在的下标时会发生 `StringIndexOutOfBoundsException`（下标越界异常）；
- `int indexOf(**int** ch, [int fromIndex])`：从指定位置开始，获取 ch 第一次出现的索引；
  
  - 未找到 ch 则返回 -1；
- `int indexOf(**String** str, [int fromIndex])`
  
  - `lastIndexOf()`：同 indexOf；
- `String substring(begin, [end])`：**切片**，截取指定位置 `[begin,end)` 的新**子串**。 
- `String[] split(String regex, [int limit])`：根据正则匹配**切割/拆分**，需检查最后一个分隔符后有无内容，否则会有抛 `IndexOutOfBoundsException` 的风险。
  
  - regex：正则表达式分隔符。
  - limit：分割份数。
  ```
  String str = "a,b,c,,";
  String[] ary = str.split(",");
  // 预期长度为5，其实第4、5个为空，未放入结果数组，实际长度等于 3
  System.out.println(ary.length);
  ```

##### 判断

- `boolean contains(str)`: 是否包含子串；
  - 同：`if (str.indexOf(str) != -1)`，区别：无法获取子串出现的位置。
- `boolean isEmpty()`: 是否有内容。原理是判断字符串长度是否为0；
- `boolean startsWith(String prefix)`：是否以指定前缀开头；
  - `boolean endsWith(String suffix)`：
- `boolean equals(str)`：判断字符串内容是否相同。重写了 `Object` 类中的 `equals()`，只判断字符串内容是否相同；需对当前字符串判空；
  - `boolean equalsIgnoreCase()`：忽略大小写，判断内容是否相同；
- `int compareTo(str)`：比较两字符串的字典顺序，基于字符的 Unicode 值。相等返回 0；小于str参数，返回负数。

##### 替换和合并

操作都不是在原有的字符串对象上进行的，而是生成了新的 String 对象，然后将原 String 的变量引用指向新对象。

- `String replace(char old, char new)`：如果被替换的**字符**不存在，则返回原串；
  - `String replace(" ","")`：消除字符串的所有空格；
  - `String trim()`：删除字符串的头尾空白符；
- `String replaceAll(String regex, String replaceStr)`：用 `replaceStr` 替换所有正则匹配的**子串**。
  - `String replaceFirst(String regex, String replaceStr)`：只替换匹配的第一个子串。
- `String concat(String str)`: 将 str 拼接到结尾，不能拼接其他类型，二者都不能为 null，否则运行时会报空指针异常 NPE（编译时不报错）。
  - `+`：可拼接字符，数字，字符串等数据类型；
- `String.join(String " ", List<String> wordList)`：合并 List，并插入 “ ”；
- `StringBuilder.setCharAt(index, char)`：替换单个字符；

```
String str = "Test string";
StringBuilder strBuilder = new StringBuilder(str);
strBuilder.setCharAt(1, 'X');
str = strBuilder.toString();
```

##### 转换

- `char[] toCharArray()`：将字符串转成字符数组，常用于 `for(char ch : str.toCharArray()){}`
- `byte[] getBytes()`：将字符串转成字节数组；
  - `String(byte[])`：将字节数组转成字符串；
- `static String String.valueOf(int)`： 将基本数据类型 int 转成字符串；
  - `static String valueOf(double)`：将基本数据类型 double 转成字符串；
- `String toUpperCase()`：将字符串全部转成大写；
  - `String toLowerCase()`

### Math 类

- `abs()`
- `ceil()`：取上限
- `floor()`
- `pow(2, 3)`
- `round(4.9999)`

### Date / Calendear / LocalDate 类

- `SimpleDateFormat` 是线程不安全的类，一般不定义为 static 变量，如果定义为 static，必须加锁，或用 DateUtils 工具类。

```
import java.util.Date;

Data d = new Date();
long ts =  d.getTime(); // 时间戳

System.currentTimeMillis(); // 获取当前毫秒数，而不是 new Date().getTime()

SimpleDataFormate sdf = new SimpleDateFormate("yyyy-MM-dd HH:mm:ss EEE a"); //统一为 GMT

String rs = sdf.format(d);
String rs2 = sdf.format(ts);

sdf.parse("2019-09-11");

// 获取今年的天数 365
int daysOfThisYear = LocalDate.now().lengthOfYear(); 
// 获取指定某年的天数
LocalDate.of(2011, 1, 1).lengthOfYear();

Calendar calendar = Calendar.getInstance();
calendar.add(Calendar.YEAR, 71); // after 71 year
calendar.set(2020, 1, 26);
calendar.add(Calendar.DATE, daysOfThisYear);//一年后
```

### BigInteger 类

64 位 long 整型是最大的整数类型，超过这个范围就会有数值溢出的风险；

```
long l = Long.MAX_VALUE;
l + 1; // -9223372036854775808
l + 1 == Long.MIN_VALUE; // true
```

BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。

```

```

### BigDecimal 类

作用：为了避免精度丢失，可用 `BigDecimal` 来进行浮点数的运算；

##### 浮点数精度陷阱

二进制无法精确表示浮点数：由于计算机（用"尾数+阶码"的编码方式）保存浮点数，二进制尾数宽度有限，无限循环的小数存储在计算机时，只能被截断；计算机内存放的值与实际值存在误差，导致浮点数精度陷阱。

因此，浮点数间的等值判断，

1. 基本数据类型不能用 `==` 来比较；
2. 包装数据类型不能用 equals 来判断。

[计算机系统基础（四）浮点数](http://kaito-kidd.com/2018/08/08/computer-system-float-point/)

```
float a = 1.0F - 0.9F; // 0.100000024，在计算机内4Byte，32bit，1符号位8指数位23有效数字，用"尾数+阶码"的编码方式，二进制无法精确表示大部分的十进制小数
float b = 0.9F - 0.8F; // 0.099999964
a == b？// 预期返回true，实际为false
```

##### 浮点数精度陷阱的解决

1. 指定一个误差范围，两个浮点数的差值在此范围内，则认为是相等的。

```
float diff = 1e-6F;
if (Math.abs(a - b) < diff) {
    System.out.println("true"); 
}
```

2. 用 `BigDecimal` 类来定义值，再进行浮点数的运算操作。推荐创建 `BigDecimal`  对象的方式：
   1. `BigDecimal(String val)`构造方法；
   2. `BigDecimal.valueOf(double val)` 静态方法：内部其实执行了 Double 的 toString，按 double 实际能表达的精度对尾数进行截断；
   3. `BigDecimal(double)`：存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。

```
BigDecimal a = new BigDecimal("1.0"); 
BigDecimal b = new BigDecimal("0.9");
BigDecimal c = new BigDecimal("0.8");

BigDecimal x = a.subtract(b); // 0.1，减法
BigDecimal y = b.subtract(c); // 0.1

// 大小比较
x.compareTo(y)? // true，只比较值、忽略精度
Objects.equals(x, y)? // 会比较值和精度，1.0与1.00返回false
```

常见方法：

```
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("0.9");

// 加减乘除
a.add(b); // 1.9
a.subtract(b); // 0.1
a.multiply(b); // 0.90
a.divide(b); // 无法除尽，抛出 ArithmeticException 异常
a.divide(b, 2, RoundingMode.HALF_UP); // 1.11，其中 scale 表示要保留几位小数；roundingMode 代表保留规则，不要选择 UNNECESSARY，否则很可能会遇到 ArithmeticException（无法除尽出现无限循环小数的时候）

// 设置保留几位小数及保留规则
BigDecimal c = a.setScale(3, RoundingMode.HALF_DOWN);

BigDecimal.doubleValue(); // 返回double
```

### 枚举类

用于信息标志和信息分类，元素为常量对象

多例模式

继承Enum类

```
Sex s = Sex.BOY;
s.ordinal();// index
Sex.values();//all values
```

### 正则表达式 Pattern类

适合做校验

```
"hello".matches("\\d{4,}");
"he2kele4we".splite("\\d+");
"he2kele4we".replaceAll("\\d+", "/");

Pattern pt = Pattern.compile("\\d+");
Matcher mt = pt.matcher("hjeiji@jhj@".);
while(matcher.find()) {
  matcher.group();
}
```

### System 类

- exit()
- cuurentTimeMilis()
- copyArray()基本不用